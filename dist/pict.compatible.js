"use strict";function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]};},e:function e(r){throw r;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var o,a=!0,u=!1;return{s:function s(){t=t.call(r);},n:function n(){var r=t.next();return a=r.done,r;},e:function e(r){u=!0,o=r;},f:function f(){try{a||null==t["return"]||t["return"]();}finally{if(u)throw o;}}};}function _toConsumableArray(r){return _arrayWithoutHoles(r)||_iterableToArray(r)||_unsupportedIterableToArray(r)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0;}}function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r);}function _arrayWithoutHoles(r){if(Array.isArray(r))return _arrayLikeToArray(r);}function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n;}function _defineProperty2(e,r,t){return(r=_toPropertyKey2(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _superPropGet(t,o,e,r){var p=_get(_getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t);}:p;}function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=_superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value;}},_get.apply(null,arguments);}function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=_getPrototypeOf(t)););return t;}function _classCallCheck2(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function");}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey2(o.key),o);}}function _createClass2(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e;}function _toPropertyKey2(t){var i=_toPrimitive2(t,"string");return"symbol"==_typeof(i)?i:i+"";}function _toPrimitive2(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return("string"===r?String:Number)(t);}function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e));}function _possibleConstructorReturn(t,e){if(e&&("object"==_typeof(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(t);}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e;}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t;})();}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t);},_getPrototypeOf(t);}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e);}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t;},_setPrototypeOf(t,e);}function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o;},_typeof(o);}(function(f){if((typeof exports==="undefined"?"undefined":_typeof(exports))==="object"&&typeof module!=="undefined"){module.exports=f();}else if(typeof define==="function"&&define.amd){define([],f);}else{var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else{g=this;}g.Pict=f();}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o;}return r;}()({1:[function(require,module,exports){'use strict';var eachOfLimit=require('async.util.eachoflimit');var withoutIndex=require('async.util.withoutindex');module.exports=function eachLimit(arr,limit,iterator,cb){return eachOfLimit(limit)(arr,withoutIndex(iterator),cb);};},{"async.util.eachoflimit":3,"async.util.withoutindex":14}],2:[function(require,module,exports){'use strict';module.exports=function(tasks){function makeCallback(index){function fn(){if(tasks.length){tasks[index].apply(null,arguments);}return fn.next();}fn.next=function(){return index<tasks.length-1?makeCallback(index+1):null;};return fn;}return makeCallback(0);};},{}],3:[function(require,module,exports){var once=require('async.util.once');var noop=require('async.util.noop');var onlyOnce=require('async.util.onlyonce');var keyIterator=require('async.util.keyiterator');module.exports=function eachOfLimit(limit){return function(obj,iterator,cb){cb=once(cb||noop);obj=obj||[];var nextKey=keyIterator(obj);if(limit<=0){return cb(null);}var done=false;var running=0;var errored=false;(function replenish(){if(done&&running<=0){return cb(null);}while(running<limit&&!errored){var key=nextKey();if(key===null){done=true;if(running<=0){cb(null);}return;}running+=1;iterator(obj[key],key,onlyOnce(function(err){running-=1;if(err){cb(err);errored=true;}else{replenish();}}));}})();};};},{"async.util.keyiterator":7,"async.util.noop":9,"async.util.once":10,"async.util.onlyonce":11}],4:[function(require,module,exports){'use strict';var setImmediate=require('async.util.setimmediate');var restParam=require('async.util.restparam');module.exports=function(fn){return restParam(function(args){var callback=args.pop();args.push(function(){var innerArgs=arguments;if(sync){setImmediate(function(){callback.apply(null,innerArgs);});}else{callback.apply(null,innerArgs);}});var sync=true;fn.apply(this,args);sync=false;});};},{"async.util.restparam":12,"async.util.setimmediate":13}],5:[function(require,module,exports){'use strict';module.exports=Array.isArray||function isArray(obj){return Object.prototype.toString.call(obj)==='[object Array]';};},{}],6:[function(require,module,exports){'use strict';var isArray=require('async.util.isarray');module.exports=function isArrayLike(arr){return isArray(arr)||// has a positive integer length property
typeof arr.length==='number'&&arr.length>=0&&arr.length%1===0;};},{"async.util.isarray":5}],7:[function(require,module,exports){'use strict';var _keys=require('async.util.keys');var isArrayLike=require('async.util.isarraylike');module.exports=function keyIterator(coll){var i=-1;var len;var keys;if(isArrayLike(coll)){len=coll.length;return function next(){i++;return i<len?i:null;};}else{keys=_keys(coll);len=keys.length;return function next(){i++;return i<len?keys[i]:null;};}};},{"async.util.isarraylike":6,"async.util.keys":8}],8:[function(require,module,exports){'use strict';module.exports=Object.keys||function keys(obj){var _keys=[];for(var k in obj){if(obj.hasOwnProperty(k)){_keys.push(k);}}return _keys;};},{}],9:[function(require,module,exports){'use strict';module.exports=function noop(){};},{}],10:[function(require,module,exports){'use strict';module.exports=function once(fn){return function(){if(fn===null)return;fn.apply(this,arguments);fn=null;};};},{}],11:[function(require,module,exports){'use strict';module.exports=function only_once(fn){return function(){if(fn===null)throw new Error('Callback was already called.');fn.apply(this,arguments);fn=null;};};},{}],12:[function(require,module,exports){'use strict';module.exports=function restParam(func,startIndex){startIndex=startIndex==null?func.length-1:+startIndex;return function(){var length=Math.max(arguments.length-startIndex,0);var rest=new Array(length);for(var index=0;index<length;index++){rest[index]=arguments[index+startIndex];}switch(startIndex){case 0:return func.call(this,rest);case 1:return func.call(this,arguments[0],rest);}};};},{}],13:[function(require,module,exports){(function(setImmediate){(function(){'use strict';var _setImmediate=typeof setImmediate==='function'&&setImmediate;var fallback=function fallback(fn){setTimeout(fn,0);};module.exports=function setImmediate(fn){// not a direct alias for IE10 compatibility
return(_setImmediate||fallback)(fn);};}).call(this);}).call(this,require("timers").setImmediate);},{"timers":184}],14:[function(require,module,exports){'use strict';module.exports=function withoutIndex(iterator){return function(value,index,callback){return iterator(value,callback);};};},{}],15:[function(require,module,exports){'use strict';var once=require('async.util.once');var noop=require('async.util.noop');var isArray=require('async.util.isarray');var restParam=require('async.util.restparam');var ensureAsync=require('async.util.ensureasync');var iterator=require('async.iterator');module.exports=function(tasks,cb){cb=once(cb||noop);if(!isArray(tasks))return cb(new Error('First argument to waterfall must be an array of functions'));if(!tasks.length)return cb();function wrapIterator(iterator){return restParam(function(err,args){if(err){cb.apply(null,[err].concat(args));}else{var next=iterator.next();if(next){args.push(wrapIterator(next));}else{args.push(cb);}ensureAsync(iterator).apply(null,args);}});}wrapIterator(iterator(tasks))();};},{"async.iterator":2,"async.util.ensureasync":4,"async.util.isarray":5,"async.util.noop":9,"async.util.once":10,"async.util.restparam":12}],16:[function(require,module,exports){'use strict';exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return[validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data
function byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars
var len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes
var parts=[];var maxChunkLength=16383;// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes
if(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}},{}],17:[function(require,module,exports){/*
 *  big.js v6.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2024 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */;(function(GLOBAL){'use strict';var Big,/************************************** EDITABLE DEFAULTS *****************************************/// The default values below must be integers within the stated ranges.
/*
     * The maximum number of decimal places (DP) of the results of operations involving division:
     * div and sqrt, and pow with negative exponents.
     */DP=20,// 0 to MAX_DP
/*
     * The rounding mode (RM) used when rounding to the above decimal places.
     *
     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
     *  3  Away from zero.                                  (ROUND_UP)
     */RM=1,// 0, 1, 2 or 3
// The maximum value of DP and Big.DP.
MAX_DP=1E6,// 0 to 1000000
// The maximum magnitude of the exponent argument to the pow method.
MAX_POWER=1E6,// 1 to 1000000
/*
     * The negative exponent (NE) at and beneath which toString returns exponential notation.
     * (JavaScript numbers: -7)
     * -1000000 is the minimum recommended exponent value of a Big.
     */NE=-7,// 0 to -1000000
/*
     * The positive exponent (PE) at and above which toString returns exponential notation.
     * (JavaScript numbers: 21)
     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
     */PE=21,// 0 to 1000000
/*
     * When true, an error will be thrown if a primitive number is passed to the Big constructor,
     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
     * primitive number without a loss of precision.
     */STRICT=false,// true or false
/**************************************************************************************************/// Error messages.
NAME='[big.js] ',INVALID=NAME+'Invalid ',INVALID_DP=INVALID+'decimal places',INVALID_RM=INVALID+'rounding mode',DIV_BY_ZERO=NAME+'Division by zero',// The shared prototype object.
P={},UNDEFINED=void 0,NUMERIC=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;/*
   * Create and return a Big constructor.
   */function _Big_(){/*
     * The Big constructor and exported function.
     * Create and return a new instance of a Big number object.
     *
     * n {number|string|Big} A numeric value.
     */function Big(n){var x=this;// Enable constructor usage without new.
if(!(x instanceof Big))return n===UNDEFINED?_Big_():new Big(n);// Duplicate.
if(n instanceof Big){x.s=n.s;x.e=n.e;x.c=n.c.slice();}else{if(typeof n!=='string'){if(Big.strict===true&&typeof n!=='bigint'){throw TypeError(INVALID+'value');}// Minus zero?
n=n===0&&1/n<0?'-0':String(n);}parse(x,n);}// Retain a reference to this Big constructor.
// Shadow Big.prototype.constructor which points to Object.
x.constructor=Big;}Big.prototype=P;Big.DP=DP;Big.RM=RM;Big.NE=NE;Big.PE=PE;Big.strict=STRICT;Big.roundDown=0;Big.roundHalfUp=1;Big.roundHalfEven=2;Big.roundUp=3;return Big;}/*
   * Parse the number or string value passed to a Big constructor.
   *
   * x {Big} A Big number instance.
   * n {number|string} A numeric value.
   */function parse(x,n){var e,i,nl;if(!NUMERIC.test(n)){throw Error(INVALID+'number');}// Determine sign.
x.s=n.charAt(0)=='-'?(n=n.slice(1),-1):1;// Decimal point?
if((e=n.indexOf('.'))>-1)n=n.replace('.','');// Exponential form?
if((i=n.search(/e/i))>0){// Determine exponent.
if(e<0)e=i;e+=+n.slice(i+1);n=n.substring(0,i);}else if(e<0){// Integer.
e=n.length;}nl=n.length;// Determine leading zeros.
for(i=0;i<nl&&n.charAt(i)=='0';)++i;if(i==nl){// Zero.
x.c=[x.e=0];}else{// Determine trailing zeros.
for(;nl>0&&n.charAt(--nl)=='0';);x.e=e-i-1;x.c=[];// Convert string to array of digits without leading/trailing zeros.
for(e=0;i<=nl;)x.c[e++]=+n.charAt(i++);}return x;}/*
   * Round Big x to a maximum of sd significant digits using rounding mode rm.
   *
   * x {Big} The Big to round.
   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   * [more] {boolean} Whether the result of division was truncated.
   */function round(x,sd,rm,more){var xc=x.c;if(rm===UNDEFINED)rm=x.constructor.RM;if(rm!==0&&rm!==1&&rm!==2&&rm!==3){throw Error(INVALID_RM);}if(sd<1){more=rm===3&&(more||!!xc[0])||sd===0&&(rm===1&&xc[0]>=5||rm===2&&(xc[0]>5||xc[0]===5&&(more||xc[1]!==UNDEFINED)));xc.length=1;if(more){// 1, 0.1, 0.01, 0.001, 0.0001 etc.
x.e=x.e-sd+1;xc[0]=1;}else{// Zero.
xc[0]=x.e=0;}}else if(sd<xc.length){// xc[sd] is the digit after the digit that may be rounded up.
more=rm===1&&xc[sd]>=5||rm===2&&(xc[sd]>5||xc[sd]===5&&(more||xc[sd+1]!==UNDEFINED||xc[sd-1]&1))||rm===3&&(more||!!xc[0]);// Remove any digits after the required precision.
xc.length=sd;// Round up?
if(more){// Rounding up may mean the previous digit has to be rounded up.
for(;++xc[--sd]>9;){xc[sd]=0;if(sd===0){++x.e;xc.unshift(1);break;}}}// Remove trailing zeros.
for(sd=xc.length;!xc[--sd];)xc.pop();}return x;}/*
   * Return a string representing the value of Big x in normal or exponential notation.
   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
   */function stringify(x,doExponential,isNonzero){var e=x.e,s=x.c.join(''),n=s.length;// Exponential notation?
if(doExponential){s=s.charAt(0)+(n>1?'.'+s.slice(1):'')+(e<0?'e':'e+')+e;// Normal notation.
}else if(e<0){for(;++e;)s='0'+s;s='0.'+s;}else if(e>0){if(++e>n){for(e-=n;e--;)s+='0';}else if(e<n){s=s.slice(0,e)+'.'+s.slice(e);}}else if(n>1){s=s.charAt(0)+'.'+s.slice(1);}return x.s<0&&isNonzero?'-'+s:s;}// Prototype/instance methods
/*
   * Return a new Big whose value is the absolute value of this Big.
   */P.abs=function(){var x=new this.constructor(this);x.s=1;return x;};/*
   * Return 1 if the value of this Big is greater than the value of Big y,
   *       -1 if the value of this Big is less than the value of Big y, or
   *        0 if they have the same value.
   */P.cmp=function(y){var isneg,x=this,xc=x.c,yc=(y=new x.constructor(y)).c,i=x.s,j=y.s,k=x.e,l=y.e;// Either zero?
if(!xc[0]||!yc[0])return!xc[0]?!yc[0]?0:-j:i;// Signs differ?
if(i!=j)return i;isneg=i<0;// Compare exponents.
if(k!=l)return k>l^isneg?1:-1;j=(k=xc.length)<(l=yc.length)?k:l;// Compare digit by digit.
for(i=-1;++i<j;){if(xc[i]!=yc[i])return xc[i]>yc[i]^isneg?1:-1;}// Compare lengths.
return k==l?0:k>l^isneg?1:-1;};/*
   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */P.div=function(y){var x=this,Big=x.constructor,a=x.c,// dividend
b=(y=new Big(y)).c,// divisor
k=x.s==y.s?1:-1,dp=Big.DP;if(dp!==~~dp||dp<0||dp>MAX_DP){throw Error(INVALID_DP);}// Divisor is zero?
if(!b[0]){throw Error(DIV_BY_ZERO);}// Dividend is 0? Return +-0.
if(!a[0]){y.s=k;y.c=[y.e=0];return y;}var bl,bt,n,cmp,ri,bz=b.slice(),ai=bl=b.length,al=a.length,r=a.slice(0,bl),// remainder
rl=r.length,q=y,// quotient
qc=q.c=[],qi=0,p=dp+(q.e=x.e-y.e)+1;// precision of the result
q.s=k;k=p<0?0:p;// Create version of divisor with leading zero.
bz.unshift(0);// Add zeros to make remainder as long as divisor.
for(;rl++<bl;)r.push(0);do{// n is how many times the divisor goes into current remainder.
for(n=0;n<10;n++){// Compare divisor and remainder.
if(bl!=(rl=r.length)){cmp=bl>rl?1:-1;}else{for(ri=-1,cmp=0;++ri<bl;){if(b[ri]!=r[ri]){cmp=b[ri]>r[ri]?1:-1;break;}}}// If divisor < remainder, subtract divisor from remainder.
if(cmp<0){// Remainder can't be more than 1 digit longer than divisor.
// Equalise lengths using divisor with extra leading zero?
for(bt=rl==bl?b:bz;rl;){if(r[--rl]<bt[rl]){ri=rl;for(;ri&&!r[--ri];)r[ri]=9;--r[ri];r[rl]+=10;}r[rl]-=bt[rl];}for(;!r[0];)r.shift();}else{break;}}// Add the digit n to the result array.
qc[qi++]=cmp?n:++n;// Update the remainder.
if(r[0]&&cmp)r[rl]=a[ai]||0;else r=[a[ai]];}while((ai++<al||r[0]!==UNDEFINED)&&k--);// Leading zero? Do not remove if result is simply zero (qi == 1).
if(!qc[0]&&qi!=1){// There can't be more than one zero.
qc.shift();q.e--;p--;}// Round?
if(qi>p)round(q,p,Big.RM,r[0]!==UNDEFINED);return q;};/*
   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
   */P.eq=function(y){return this.cmp(y)===0;};/*
   * Return true if the value of this Big is greater than the value of Big y, otherwise return
   * false.
   */P.gt=function(y){return this.cmp(y)>0;};/*
   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
   * return false.
   */P.gte=function(y){return this.cmp(y)>-1;};/*
   * Return true if the value of this Big is less than the value of Big y, otherwise return false.
   */P.lt=function(y){return this.cmp(y)<0;};/*
   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
   * return false.
   */P.lte=function(y){return this.cmp(y)<1;};/*
   * Return a new Big whose value is the value of this Big minus the value of Big y.
   */P.minus=P.sub=function(y){var i,j,t,xlty,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;// Signs differ?
if(a!=b){y.s=-b;return x.plus(y);}var xc=x.c.slice(),xe=x.e,yc=y.c,ye=y.e;// Either zero?
if(!xc[0]||!yc[0]){if(yc[0]){y.s=-b;}else if(xc[0]){y=new Big(x);}else{y.s=1;}return y;}// Determine which is the bigger number. Prepend zeros to equalise exponents.
if(a=xe-ye){if(xlty=a<0){a=-a;t=xc;}else{ye=xe;t=yc;}t.reverse();for(b=a;b--;)t.push(0);t.reverse();}else{// Exponents equal. Check digit by digit.
j=((xlty=xc.length<yc.length)?xc:yc).length;for(a=b=0;b<j;b++){if(xc[b]!=yc[b]){xlty=xc[b]<yc[b];break;}}}// x < y? Point xc to the array of the bigger number.
if(xlty){t=xc;xc=yc;yc=t;y.s=-y.s;}/*
     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
     * needs to start at yc.length.
     */if((b=(j=yc.length)-(i=xc.length))>0)for(;b--;)xc[i++]=0;// Subtract yc from xc.
for(b=i;j>a;){if(xc[--j]<yc[j]){for(i=j;i&&!xc[--i];)xc[i]=9;--xc[i];xc[j]+=10;}xc[j]-=yc[j];}// Remove trailing zeros.
for(;xc[--b]===0;)xc.pop();// Remove leading zeros and adjust exponent accordingly.
for(;xc[0]===0;){xc.shift();--ye;}if(!xc[0]){// n - n = +0
y.s=1;// Result must be zero.
xc=[ye=0];}y.c=xc;y.e=ye;return y;};/*
   * Return a new Big whose value is the value of this Big modulo the value of Big y.
   */P.mod=function(y){var ygtx,x=this,Big=x.constructor,a=x.s,b=(y=new Big(y)).s;if(!y.c[0]){throw Error(DIV_BY_ZERO);}x.s=y.s=1;ygtx=y.cmp(x)==1;x.s=a;y.s=b;if(ygtx)return new Big(x);a=Big.DP;b=Big.RM;Big.DP=Big.RM=0;x=x.div(y);Big.DP=a;Big.RM=b;return this.minus(x.times(y));};/*
   * Return a new Big whose value is the value of this Big negated.
   */P.neg=function(){var x=new this.constructor(this);x.s=-x.s;return x;};/*
   * Return a new Big whose value is the value of this Big plus the value of Big y.
   */P.plus=P.add=function(y){var e,k,t,x=this,Big=x.constructor;y=new Big(y);// Signs differ?
if(x.s!=y.s){y.s=-y.s;return x.minus(y);}var xe=x.e,xc=x.c,ye=y.e,yc=y.c;// Either zero?
if(!xc[0]||!yc[0]){if(!yc[0]){if(xc[0]){y=new Big(x);}else{y.s=x.s;}}return y;}xc=xc.slice();// Prepend zeros to equalise exponents.
// Note: reverse faster than unshifts.
if(e=xe-ye){if(e>0){ye=xe;t=yc;}else{e=-e;t=xc;}t.reverse();for(;e--;)t.push(0);t.reverse();}// Point xc to the longer array.
if(xc.length-yc.length<0){t=yc;yc=xc;xc=t;}e=yc.length;// Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
for(k=0;e;xc[e]%=10)k=(xc[--e]=xc[e]+yc[e]+k)/10|0;// No need to check for zero, as +x + +y != 0 && -x + -y != 0
if(k){xc.unshift(k);++ye;}// Remove trailing zeros.
for(e=xc.length;xc[--e]===0;)xc.pop();y.c=xc;y.e=ye;return y;};/*
   * Return a Big whose value is the value of this Big raised to the power n.
   * If n is negative, round to a maximum of Big.DP decimal places using rounding
   * mode Big.RM.
   *
   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
   */P.pow=function(n){var x=this,one=new x.constructor('1'),y=one,isneg=n<0;if(n!==~~n||n<-MAX_POWER||n>MAX_POWER){throw Error(INVALID+'exponent');}if(isneg)n=-n;for(;;){if(n&1)y=y.times(x);n>>=1;if(!n)break;x=x.times(x);}return isneg?one.div(y):y;};/*
   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
   * significant digits using rounding mode rm, or Big.RM if rm is not specified.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */P.prec=function(sd,rm){if(sd!==~~sd||sd<1||sd>MAX_DP){throw Error(INVALID+'precision');}return round(new this.constructor(this),sd,rm);};/*
   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
   * using rounding mode rm, or Big.RM if rm is not specified.
   * If dp is negative, round to an integer which is a multiple of 10**-dp.
   * If dp is not specified, round to 0 decimal places.
   *
   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */P.round=function(dp,rm){if(dp===UNDEFINED)dp=0;else if(dp!==~~dp||dp<-MAX_DP||dp>MAX_DP){throw Error(INVALID_DP);}return round(new this.constructor(this),dp+this.e+1,rm);};/*
   * Return a new Big whose value is the square root of the value of this Big, rounded, if
   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */P.sqrt=function(){var r,c,t,x=this,Big=x.constructor,s=x.s,e=x.e,half=new Big('0.5');// Zero?
if(!x.c[0])return new Big(x);// Negative?
if(s<0){throw Error(NAME+'No square root');}// Estimate.
s=Math.sqrt(+stringify(x,true,true));// Math.sqrt underflow/overflow?
// Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
if(s===0||s===1/0){c=x.c.join('');if(!(c.length+e&1))c+='0';s=Math.sqrt(c);e=((e+1)/2|0)-(e<0||e&1);r=new Big((s==1/0?'5e':(s=s.toExponential()).slice(0,s.indexOf('e')+1))+e);}else{r=new Big(s+'');}e=r.e+(Big.DP+=4);// Newton-Raphson iteration.
do{t=r;r=half.times(t.plus(x.div(t)));}while(t.c.slice(0,e).join('')!==r.c.slice(0,e).join(''));return round(r,(Big.DP-=4)+r.e+1,Big.RM);};/*
   * Return a new Big whose value is the value of this Big times the value of Big y.
   */P.times=P.mul=function(y){var c,x=this,Big=x.constructor,xc=x.c,yc=(y=new Big(y)).c,a=xc.length,b=yc.length,i=x.e,j=y.e;// Determine sign of result.
y.s=x.s==y.s?1:-1;// Return signed 0 if either 0.
if(!xc[0]||!yc[0]){y.c=[y.e=0];return y;}// Initialise exponent of result as x.e + y.e.
y.e=i+j;// If array xc has fewer digits than yc, swap xc and yc, and lengths.
if(a<b){c=xc;xc=yc;yc=c;j=a;a=b;b=j;}// Initialise coefficient array of result with zeros.
for(c=new Array(j=a+b);j--;)c[j]=0;// Multiply.
// i is initially xc.length.
for(i=b;i--;){b=0;// a is yc.length.
for(j=a+i;j>i;){// Current sum of products at this digit position, plus carry.
b=c[j]+yc[i]*xc[j-i-1]+b;c[j--]=b%10;// carry
b=b/10|0;}c[j]=b;}// Increment result exponent if there is a final carry, otherwise remove leading zero.
if(b)++y.e;else c.shift();// Remove trailing zeros.
for(i=c.length;!c[--i];)c.pop();y.c=c;return y;};/*
   * Return a string representing the value of this Big in exponential notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */P.toExponential=function(dp,rm){var x=this,n=x.c[0];if(dp!==UNDEFINED){if(dp!==~~dp||dp<0||dp>MAX_DP){throw Error(INVALID_DP);}x=round(new x.constructor(x),++dp,rm);for(;x.c.length<dp;)x.c.push(0);}return stringify(x,true,!!n);};/*
   * Return a string representing the value of this Big in normal notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   */P.toFixed=function(dp,rm){var x=this,n=x.c[0];if(dp!==UNDEFINED){if(dp!==~~dp||dp<0||dp>MAX_DP){throw Error(INVALID_DP);}x=round(new x.constructor(x),dp+x.e+1,rm);// x.e may have changed if the value is rounded up.
for(dp=dp+x.e+1;x.c.length<dp;)x.c.push(0);}return stringify(x,false,!!n);};/*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Omit the sign for negative zero.
   */P.toJSON=P.toString=function(){var x=this,Big=x.constructor;return stringify(x,x.e<=Big.NE||x.e>=Big.PE,!!x.c[0]);};/*
   * Return the value of this Big as a primitve number.
   */P.toNumber=function(){var n=+stringify(this,true,true);if(this.constructor.strict===true&&!this.eq(n.toString())){throw Error(NAME+'Imprecise conversion');}return n;};/*
   * Return a string representing the value of this Big rounded to sd significant digits using
   * rounding mode rm, or Big.RM if rm is not specified.
   * Use exponential notation if sd is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */P.toPrecision=function(sd,rm){var x=this,Big=x.constructor,n=x.c[0];if(sd!==UNDEFINED){if(sd!==~~sd||sd<1||sd>MAX_DP){throw Error(INVALID+'precision');}x=round(new Big(x),sd,rm);for(;x.c.length<sd;)x.c.push(0);}return stringify(x,sd<=x.e||x.e<=Big.NE||x.e>=Big.PE,!!n);};/*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Include the sign for negative zero.
   */P.valueOf=function(){var x=this,Big=x.constructor;if(Big.strict===true){throw Error(NAME+'valueOf disallowed');}return stringify(x,x.e<=Big.NE||x.e>=Big.PE,true);};// Export
Big=_Big_();Big['default']=Big.Big=Big;//AMD.
if(typeof define==='function'&&define.amd){define(function(){return Big;});// Node and other CommonJS-like environments that support module.exports.
}else if(typeof module!=='undefined'&&module.exports){module.exports=Big;//Browser.
}else{GLOBAL.Big=Big;}})(this);},{}],18:[function(require,module,exports){},{}],19:[function(require,module,exports){arguments[4][18][0].apply(exports,arguments);},{"dup":18}],20:[function(require,module,exports){(function(Buffer){(function(){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 *//* eslint-disable no-proto */'use strict';var base64=require('base64-js');var ieee754=require('ieee754');exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=0x7fffffff;exports.kMaxLength=K_MAX_LENGTH;/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?
try{var arr=new Uint8Array(1);arr.__proto__={__proto__:Uint8Array.prototype,foo:function foo(){return 42;}};return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value "'+length+'" is invalid for option "size"');}// Return an augmented `Uint8Array` instance
var buf=new Uint8Array(length);buf.__proto__=Buffer.prototype;return buf;}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */function Buffer(arg,encodingOrOffset,length){// Common case.
if(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The "string" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if(typeof Symbol!=='undefined'&&Symbol.species!=null&&Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true,enumerable:false,writable:false});}Buffer.poolSize=8192;// not used by this implementation
function from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayLike(value);}if(value==null){throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The "value" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__=Uint8Array.prototype;Buffer.__proto__=Uint8Array;function assertSize(size){if(typeof size!=='number'){throw new TypeError('"size" argument must be of type number');}else if(size<0){throw new RangeError('The value "'+size+'" is invalid for option "size"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This
// prevents accidentally sending in a number that would
// be interpretted as a start offset.
return typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will
// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
buf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('"offset" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('"length" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else{buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance
buf.__proto__=Buffer.prototype;return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq
length=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false
};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('"list" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){buf=Buffer.from(buf);}if(!Buffer.isBuffer(buf)){throw new TypeError('"list" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion
var loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8
}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
if(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
end>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.INSPECT_MAX_BYTES;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return'<Buffer '+str+'>';};Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match
if(buffer.length===0)return-1;// Normalize byteOffset
if(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.
if(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
byteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer
if(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val
if(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf
if(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails
if(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]
if(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)
if(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)
}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])
}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write
return base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else{return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
codePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)
codePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()
}// Decode in chunks to avoid "call stack size exceeded".
var res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=toHex(buf[i]);}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance
newBuf.__proto__=Buffer.prototype;return newBuf;};/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4,3.4028234663852886e+38,-3.4028234663852886e+38);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8,1.7976931348623157E+308,-1.7976931348623157E+308);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done
if(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions
if(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?
if(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11
this.copyWithin(targetStart,start,end);}else if(this===target&&start<targetStart&&targetStart<end){// descending copy from end
for(var i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else{Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:
if(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.
val=code;}}}else if(typeof val==='number'){val=val&255;}// Invalid ranges are not set to a default, so can range check early.
if(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value "'+val+'" is invalid for argument "value"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding
str=str.split('=')[0];// Node strips out invalid characters like \n and \t from the string, base64-js does not
str=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''
if(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while(str.length%4!==0){str=str+'=';}return str;}function toHex(n){if(n<16)return'0'+n.toString(16);return n.toString(16);}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component
if(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead
if(!leadSurrogate){// no lead yet
if(codePoint>0xDBFF){// unexpected trail
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead
leadSurrogate=codePoint;continue;}// 2 leads in a row
if(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair
codePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8
if(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..
byteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support
return obj!==obj;// eslint-disable-line no-self-compare
}}).call(this);}).call(this,require("buffer").Buffer);},{"base64-js":16,"buffer":20,"ieee754":111}],21:[function(require,module,exports){module.exports={"100":"Continue","101":"Switching Protocols","102":"Processing","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I'm a teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Unordered Collection","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"};},{}],22:[function(require,module,exports){/**
* Cache data structure with:
*  - enumerable items
*  - unique hash item access (if none is passed in, one is generated)
*  - size (length) expiration
*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)
*  - time-based expiration
*  - custom expiration based on passed-in function
*
* Also:
*  - built to work well with browserify
*  - no dependencies at all
*  - pet friendly
*
* @author Steven Velozo <steven@velozo.com>
*/var libFableServiceProviderBase=require('fable-serviceproviderbase');var libLinkedList=require("./LinkedList.js");var CashMoney=/*#__PURE__*/function(_libFableServiceProvi){function CashMoney(pFable,pManifest,pServiceHash){var _this3;_classCallCheck2(this,CashMoney);if(pFable===undefined){_this3=_callSuper(this,CashMoney,[{}]);}else{_this3=_callSuper(this,CashMoney,[pFable,pManifest,pServiceHash]);}_this3.serviceType='ObjectCache';// The map of node objects by hash because Reasons.
_this3._HashMap={};_this3._RecordMap={};_this3._List=new libLinkedList();// If the list gets over maxLength, we will automatically remove nodes on insertion.
_this3.maxLength=0;// If cache entries get over this age, they are removed with prune
_this3.maxAge=0;return _assertThisInitialized(_this3);}_inherits(CashMoney,_libFableServiceProvi);return _createClass2(CashMoney,[{key:"RecordMap",get:function get(){return this._RecordMap;}// Add (or update) a node in the cache
},{key:"put",value:function put(pData,pHash){// If the hash of the record exists
if(this._HashMap.hasOwnProperty(pHash)){// Just update the hashed records datum
this._HashMap[pHash].Datum=pData;this._RecordMap[pHash]=pData;return this._HashMap[pHash].Datum;}var tmpNode=this._List.push(pData,pHash);this._HashMap[tmpNode.Hash]=tmpNode;this._RecordMap[pHash]=pData;// Automatically prune if over length, but only prune this nodes worth.
if(this.maxLength>0&&this._List.length>this.maxLength){// Pop it off the head of the list
tmpNode=this._List.pop();// Also remove it from the hashmap
delete this._RecordMap[tmpNode.Hash];delete this._HashMap[tmpNode.Hash];}// Now some expiration properties on the node metadata... namely the birthdate in ms of the node
tmpNode.Metadata.Created=+new Date();return tmpNode.Datum;}// Read a datum by hash from the cache
},{key:"read",value:function read(pHash){if(!this._HashMap.hasOwnProperty(pHash)){return false;}return this._HashMap[pHash].Datum;}// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)
},{key:"touch",value:function touch(pHash){if(!this._HashMap.hasOwnProperty(pHash)){return false;}// Get the old node out of the list
var tmpNode=this._List.remove(this._HashMap[pHash]);// Remove it from the hash map
delete this._RecordMap[pHash];delete this._HashMap[pHash];// Now put it back, fresh.
return this.put(tmpNode.Datum,tmpNode.Hash);}// Expire a cached record based on hash
},{key:"expire",value:function expire(pHash){if(!this._HashMap.hasOwnProperty(pHash)){return false;}var tmpNode=this._HashMap[pHash];// Remove it from the list of cached records
tmpNode=this._List.remove(tmpNode);// Also remove it from the hashmap
delete this._RecordMap[tmpNode.Hash];delete this._HashMap[tmpNode.Hash];// Return it in case the consumer wants to do anything with it
return tmpNode;}// Prune records from the cached set based on maxAge
},{key:"pruneBasedOnExpiration",value:function pruneBasedOnExpiration(fComplete,pRemovedRecords){var tmpRemovedRecords=typeof pRemovedRecords==='undefined'?[]:pRemovedRecords;if(this.maxAge<1){return fComplete(tmpRemovedRecords);}// Now enumerate each record and remove any that are expired
var tmpNow=+new Date();var tmpKeys=Object.keys(this._HashMap);for(var i=0;i<tmpKeys.length;i++){// Expire the node if it is older than max age milliseconds
if(tmpNow-this._HashMap[tmpKeys[i]].Metadata.Created>=this.maxAge){tmpRemovedRecords.push(this.expire(tmpKeys[i]));}}fComplete(tmpRemovedRecords);}// Prune records from the cached set based on maxLength
},{key:"pruneBasedOnLength",value:function pruneBasedOnLength(fComplete,pRemovedRecords){var tmpRemovedRecords=typeof pRemovedRecords==='undefined'?[]:pRemovedRecords;// Pop records off until we have reached maxLength unless it's 0
if(this.maxLength>0){while(this._List.length>this.maxLength){tmpRemovedRecords.push(this._List.pop());}}return fComplete(tmpRemovedRecords);}// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it
},{key:"pruneCustom",value:function pruneCustom(fComplete,fPruneFunction,pRemovedRecords){var tmpRemovedRecords=typeof pRemovedRecords==='undefined'?[]:pRemovedRecords;var tmpKeys=Object.keys(this._HashMap);for(var i=0;i<tmpKeys.length;i++){var tmpNode=this._HashMap[tmpKeys[i]];// Expire the node if the passed in function returns true
if(fPruneFunction(tmpNode.Datum,tmpNode.Hash,tmpNode)){tmpRemovedRecords.push(this.expire(tmpKeys[i]));}}fComplete(tmpRemovedRecords);}// Prune the list down to the asserted rules (max age then max length if still too long)
},{key:"prune",value:function prune(fComplete){var _this4=this;var tmpRemovedRecords=[];// If there are no cached records, we are done.
if(this._List.length<1){return fComplete(tmpRemovedRecords);}// Now prune based on expiration time
this.pruneBasedOnExpiration(function(fExpirationPruneComplete){// Now prune based on length, then return the removed records in the callback.
_this4.pruneBasedOnLength(fComplete,tmpRemovedRecords);},tmpRemovedRecords);}// Get a low level node (including metadata statistics) by hash from the cache
},{key:"getNode",value:function getNode(pHash){if(!this._HashMap.hasOwnProperty(pHash))return false;return this._HashMap[pHash];}}]);}(libFableServiceProviderBase);module.exports=CashMoney;},{"./LinkedList.js":24,"fable-serviceproviderbase":59}],23:[function(require,module,exports){/**
* Double Linked List Node
*
* @author Steven Velozo <steven@velozo.com>
* @module CashMoney
*//**
* Linked List Node Prototype
*
* @class LinkedListNode
* @constructor
*/var LinkedListNode=/*#__PURE__*/_createClass2(function LinkedListNode(){_classCallCheck2(this,LinkedListNode);this.Hash=false;this.Datum=false;// This is where expiration and other elements are stored;
this.Metadata={};this.LeftNode=false;this.RightNode=false;// To allow safe specialty operations on nodes
this.__ISNODE=true;});module.exports=LinkedListNode;},{}],24:[function(require,module,exports){"use strict";/**
* Simple double linked list to hold the cache entries in, in order.
*
* @author Steven Velozo <steven@velozo.com>
* @module FeeFiFo
*/var libLinkedListNode=require('./LinkedList-Node.js');/**
* Quality Cache Goodness
*
* @class CashMoney
* @constructor
*/var LinkedList=/*#__PURE__*/function(){function LinkedList(){_classCallCheck2(this,LinkedList);// Total number of nodes ever processed by this ADT
this.totalNodes=0;// The length of the set of nodes currently in the list
this.length=0;this.head=false;this.tail=false;}// Create a node object.
return _createClass2(LinkedList,[{key:"initializeNode",value:function initializeNode(pDatum,pHash){// Don't allow undefined to be added to the list because of reasons
if(typeof pDatum==='undefined')return false;this.totalNodes++;// Get (or create) a unique hash
var tmpHash=typeof pHash!='undefined'?pHash:"NODE[".concat(this.totalNodes,"]");var tmpNode=new libLinkedListNode();tmpNode.Hash=tmpHash;tmpNode.Datum=pDatum;return tmpNode;}// Add a node to the end (right of tail) of the list.
},{key:"append",value:function append(pDatum,pHash){// TODO: Should we check if pDatum is actually a node and do the "right" thing?
var tmpNode=this.initializeNode(pDatum,pHash);if(!tmpNode)return false;// The list just got longer!
this.length++;// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)
if(this.length==1){this.head=tmpNode;this.tail=tmpNode;return tmpNode;}this.tail.RightNode=tmpNode;tmpNode.LeftNode=this.tail;this.tail=tmpNode;return tmpNode;}// Append to tail of list (FIFO)
},{key:"push",value:function push(pDatum,pHash){return this.append(pDatum,pHash);}// Add a node to the beginning (left of head) of the list.
},{key:"prepend",value:function prepend(pDatum,pHash){// TODO: Should we check if pDatum is actually a node and do the "right" thing?
var tmpNode=this.initializeNode(pDatum,pHash);if(!tmpNode)return false;// The list just got longer!
this.length++;// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)
if(this.length==1){this.head=tmpNode;this.tail=tmpNode;return tmpNode;}this.head.LeftNode=tmpNode;tmpNode.RightNode=this.head;this.head=tmpNode;return tmpNode;}// Remove a node from the list
},{key:"remove",value:function remove(pNode){if(typeof pNode==='undefined')return false;if(!pNode.__ISNODE)return false;this.length--;// Last element in list.  Empty it out.
if(this.length<1){this.head=false;this.tail=false;return pNode;}// It's somewhere in the middle, surgically remove it.
if(pNode.LeftNode&&pNode.RightNode){pNode.LeftNode.RightNode=pNode.RightNode;pNode.RightNode.LeftNode=pNode.LeftNode;pNode.RightNode=false;pNode.LeftNode=false;return pNode;}// It's the tail
if(pNode.LeftNode){pNode.LeftNode.RightNode=false;this.tail=pNode.LeftNode;pNode.LeftNode=false;return pNode;}// It must be the head
pNode.RightNode.LeftNode=false;this.head=pNode.RightNode;pNode.RightNode=false;return pNode;}// Remove the head of the list (FIFO)
},{key:"pop",value:function pop(){return this.remove(this.head);}// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done
},{key:"each",value:function each(fAction,fComplete){var _this5=this;if(this.length<1)return fComplete();var tmpNode=false;var _fIterator=function fIterator(pError){// If the user passed in a callback with an error, call their callback with the error
if(pError)return fComplete(pError);// If there is no node, this must be the initial run.
if(!tmpNode)tmpNode=_this5.head;// Check if we are at the tail of the list
else if(!tmpNode.RightNode)return fComplete();// Proceed to the next node
else tmpNode=tmpNode.RightNode;// Call the actual action
// I hate this pattern because long tails eventually cause stack overflows.
fAction(tmpNode.Datum,tmpNode.Hash,_fIterator);};// Now kick off the iterator
return _fIterator();}// Seek a specific node, 0 is the index of the first node.
},{key:"seek",value:function seek(pNodeIndex){if(!pNodeIndex)return false;if(this.length<1)return false;if(pNodeIndex>=this.length)return false;var tmpNode=this.head;for(var i=0;i<pNodeIndex;i++){tmpNode=tmpNode.RightNode;}return tmpNode;}}]);}();module.exports=LinkedList;},{"./LinkedList-Node.js":23}],25:[function(require,module,exports){'use strict';var bind=require('function-bind');var $apply=require('./functionApply');var $call=require('./functionCall');var $reflectApply=require('./reflectApply');/** @type {import('./actualApply')} */module.exports=$reflectApply||bind.call($call,$apply);},{"./functionApply":26,"./functionCall":27,"./reflectApply":29,"function-bind":100}],26:[function(require,module,exports){'use strict';/** @type {import('./functionApply')} */module.exports=Function.prototype.apply;},{}],27:[function(require,module,exports){'use strict';/** @type {import('./functionCall')} */module.exports=Function.prototype.call;},{}],28:[function(require,module,exports){'use strict';var bind=require('function-bind');var $TypeError=require('es-errors/type');var $call=require('./functionCall');var $actualApply=require('./actualApply');/** @type {import('.')} */module.exports=function callBindBasic(args){if(args.length<1||typeof args[0]!=='function'){throw new $TypeError('a function is required');}return $actualApply(bind,$call,args);};},{"./actualApply":25,"./functionCall":27,"es-errors/type":47,"function-bind":100}],29:[function(require,module,exports){'use strict';/** @type {import('./reflectApply')} */module.exports=typeof Reflect!=='undefined'&&Reflect&&Reflect.apply;},{}],30:[function(require,module,exports){'use strict';var GetIntrinsic=require('get-intrinsic');var callBindBasic=require('call-bind-apply-helpers');/** @type {(thisArg: string, searchString: string, position?: number) => number} */var $indexOf=callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);/** @type {import('.')} */module.exports=function callBoundIntrinsic(name,allowMissing){// eslint-disable-next-line no-extra-parens
var intrinsic=/** @type {Parameters<typeof callBindBasic>[0][0]} */GetIntrinsic(name,!!allowMissing);if(typeof intrinsic==='function'&&$indexOf(name,'.prototype.')>-1){return callBindBasic([intrinsic]);}return intrinsic;};},{"call-bind-apply-helpers":28,"get-intrinsic":101}],31:[function(require,module,exports){/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */'use strict';/**
 * Module exports.
 * @public
 */exports.parse=parse;exports.serialize=serialize;/**
 * Module variables.
 * @private
 */var __toString=Object.prototype.toString;/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */var fieldContentRegExp=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */function parse(str,options){if(typeof str!=='string'){throw new TypeError('argument str must be a string');}var obj={};var opt=options||{};var dec=opt.decode||decode;var index=0;while(index<str.length){var eqIdx=str.indexOf('=',index);// no more cookie pairs
if(eqIdx===-1){break;}var endIdx=str.indexOf(';',index);if(endIdx===-1){endIdx=str.length;}else if(endIdx<eqIdx){// backtrack on prior semicolon
index=str.lastIndexOf(';',eqIdx-1)+1;continue;}var key=str.slice(index,eqIdx).trim();// only assign once
if(undefined===obj[key]){var val=str.slice(eqIdx+1,endIdx).trim();// quoted values
if(val.charCodeAt(0)===0x22){val=val.slice(1,-1);}obj[key]=tryDecode(val,dec);}index=endIdx+1;}return obj;}/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */function serialize(name,val,options){var opt=options||{};var enc=opt.encode||encode;if(typeof enc!=='function'){throw new TypeError('option encode is invalid');}if(!fieldContentRegExp.test(name)){throw new TypeError('argument name is invalid');}var value=enc(val);if(value&&!fieldContentRegExp.test(value)){throw new TypeError('argument val is invalid');}var str=name+'='+value;if(null!=opt.maxAge){var maxAge=opt.maxAge-0;if(isNaN(maxAge)||!isFinite(maxAge)){throw new TypeError('option maxAge is invalid');}str+='; Max-Age='+Math.floor(maxAge);}if(opt.domain){if(!fieldContentRegExp.test(opt.domain)){throw new TypeError('option domain is invalid');}str+='; Domain='+opt.domain;}if(opt.path){if(!fieldContentRegExp.test(opt.path)){throw new TypeError('option path is invalid');}str+='; Path='+opt.path;}if(opt.expires){var expires=opt.expires;if(!isDate(expires)||isNaN(expires.valueOf())){throw new TypeError('option expires is invalid');}str+='; Expires='+expires.toUTCString();}if(opt.httpOnly){str+='; HttpOnly';}if(opt.secure){str+='; Secure';}if(opt.partitioned){str+='; Partitioned';}if(opt.priority){var priority=typeof opt.priority==='string'?opt.priority.toLowerCase():opt.priority;switch(priority){case'low':str+='; Priority=Low';break;case'medium':str+='; Priority=Medium';break;case'high':str+='; Priority=High';break;default:throw new TypeError('option priority is invalid');}}if(opt.sameSite){var sameSite=typeof opt.sameSite==='string'?opt.sameSite.toLowerCase():opt.sameSite;switch(sameSite){case true:str+='; SameSite=Strict';break;case'lax':str+='; SameSite=Lax';break;case'strict':str+='; SameSite=Strict';break;case'none':str+='; SameSite=None';break;default:throw new TypeError('option sameSite is invalid');}}return str;}/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */function decode(str){return str.indexOf('%')!==-1?decodeURIComponent(str):str;}/**
 * URL-encode value.
 *
 * @param {string} val
 * @returns {string}
 */function encode(val){return encodeURIComponent(val);}/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */function isDate(val){return __toString.call(val)==='[object Date]'||val instanceof Date;}/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */function tryDecode(str,decode){try{return decode(str);}catch(e){return str;}}},{}],32:[function(require,module,exports){!function(t,e){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).dayjs=e();}(this,function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function ordinal(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]";}},m=function m(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t;},v={s:m,z:function z(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0");},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0);},a:function a(t){return t<0?Math.ceil(t)||0:Math.floor(t);},p:function p(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"");},u:function u(t){return void 0===t;}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function S(t){return t instanceof _||!(!t||!t[p]);},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0]);}else{var a=e.name;D[a]=e,i=a;}return!r&&i&&(g=i),i||!r&&g;},O=function O(t,e){if(S(t))return t.clone();var n="object"==_typeof(e)?e:{};return n.date=t,n.args=arguments,new _(n);},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset});};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0;}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date();if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s);}}return new Date(e);}(t),this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return b;},m.isValid=function(){return!(this.$d.toString()===l);},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e);},m.isAfter=function(t,e){return O(t)<this.startOf(e);},m.isBefore=function(t,e){return this.endOf(e)<O(t);},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t);},m.unix=function(){return Math.floor(this.valueOf()/1e3);},m.valueOf=function(){return this.$d.getTime();},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function l(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a);},$=function $(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n);},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone();}},m.endOf=function(t){return this.startOf(t,!1);},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this;},m.set=function(t,e){return this.clone().$set(t,e);},m.get=function(t){return this[b.p(t)]();},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function y(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l);};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this);},m.subtract=function(t,e){return this.add(-1*t,e);},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function h(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s);},d=function d(t){return b.s(s%12||12,t,"0");},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r;};return r.replace(y,function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i;}return null;}(t)||i.replace(":","");});},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15);},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function D(){return b.m(y,m);};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g;}return l?$:b.a($);},m.daysInMonth=function(){return this.endOf(c).$D;},m.$locale=function(){return D[this.$L];},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n;},m.clone=function(){return b.w(this.$d,this);},m.toDate=function(){return new Date(this.valueOf());},m.toJSON=function(){return this.isValid()?this.toISOString():null;},m.toISOString=function(){return this.$d.toISOString();},m.toString=function(){return this.$d.toUTCString();},M;}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach(function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1]);};}),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O;},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t);},O.en=D[g],O.Ls=D,O.p={},O;});},{}],33:[function(require,module,exports){!function(e,t){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).dayjs_plugin_advancedFormat=t();}(this,function(){"use strict";return function(e,t){var r=t.prototype,n=r.format;r.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return n.bind(this)(e);var s=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return s.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return s.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return s.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e;}});return n.bind(this)(a);};};});},{}],34:[function(require,module,exports){!function(e,t){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).dayjs_plugin_isoWeek=t();}(this,function(){"use strict";var e="day";return function(t,i,s){var a=function a(t){return t.add(4-t.isoWeekday(),e);},d=i.prototype;d.isoWeekYear=function(){return a(this).year();},d.isoWeek=function(t){if(!this.$utils().u(t))return this.add(7*(t-this.isoWeek()),e);var i,d,n,o,r=a(this),u=(i=this.isoWeekYear(),d=this.$u,n=(d?s.utc:s)().year(i).startOf("year"),o=4-n.isoWeekday(),n.isoWeekday()>4&&(o+=7),n.add(o,e));return r.diff(u,"week")+1;},d.isoWeekday=function(e){return this.$utils().u(e)?this.day()||7:this.day(this.day()%7?e:e-7);};var n=d.startOf;d.startOf=function(e,t){var i=this.$utils(),s=!!i.u(t)||t;return"isoweek"===i.p(e)?s?this.date(this.date()-(this.isoWeekday()-1)).startOf("day"):this.date(this.date()-1-(this.isoWeekday()-1)+7).endOf("day"):n.bind(this)(e,t);};};});},{}],35:[function(require,module,exports){!function(r,e){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(r="undefined"!=typeof globalThis?globalThis:r||self).dayjs_plugin_relativeTime=e();}(this,function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o);}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break;}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a);},n.to=function(r,e){return i(r,e,this,!0);},n.from=function(r,e){return i(r,e,this);};var d=function d(r){return r.$u?t.utc():t();};n.toNow=function(r){return this.to(d(this),r);},n.fromNow=function(r){return this.from(d(this),r);};};});},{}],36:[function(require,module,exports){!function(t,e){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).dayjs_plugin_timezone=e();}(this,function(){"use strict";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function a(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r;}(n,i);return r.formatToParts(o);},u=function u(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10));}var d=r[3],l=24===d?0:d,h=r[0]+"-"+r[1]+"-"+r[2]+" "+l+":"+r[4]+":"+r[5]+":000",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4;},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n,i=this.utcOffset(),a=this.toDate(),u=a.toLocaleString("en-US",{timeZone:t}),f=Math.round((a-new Date(u))/1e3/60),s=15*-Math.round(a.getTimezoneOffset()/15)-f;if(!Number(s))n=this.utcOffset(0,e);else if(n=o(u,{locale:this.$L}).$set("millisecond",this.$ms).utcOffset(s,!0),e){var m=n.utcOffset();n=n.add(i-m,"minute");}return n.$x.$timezone=t,n;},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find(function(t){return"timezonename"===t.type.toLowerCase();});return n&&n.value;};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0);},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if("string"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)];}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d;},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone;},o.tz.setDefault=function(t){r=t;};};});},{}],37:[function(require,module,exports){!function(t,i){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).dayjs_plugin_utc=i();}(this,function(){"use strict";var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i);},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e;},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1});};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t);};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else r.call(this);};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u;}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r;}else o=this.utc();return o;};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i);},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t;},u.isUTC=function(){return!!this.$u;},u.toISOString=function(){return this.toDate().toISOString();},u.toString=function(){return this.toDate().toUTCString();};var l=u.toDate;u.toDate=function(t){return"s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this);};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e);};};});},{}],38:[function(require,module,exports){!function(e,t){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekOfYear=t();}(this,function(){"use strict";var e="week",t="year";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),"day");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1;}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,"millisecond"),o=this.diff(a,e,!0);return o<0?r(this).startOf("week").week():Math.ceil(o);},f.weeks=function(e){return void 0===e&&(e=null),this.week(e);};};});},{}],39:[function(require,module,exports){!function(e,t){"object"==_typeof(exports)&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).dayjs_plugin_weekday=t();}(this,function(){"use strict";return function(e,t){t.prototype.weekday=function(e){var t=this.$locale().weekStart||0,i=this.$W,n=(i<t?i+7:i)-t;return this.$utils().u(e)?n:this.subtract(n,"day").add(e,"day");};};});},{}],40:[function(require,module,exports){'use strict';var callBind=require('call-bind-apply-helpers');var gOPD=require('gopd');var hasProtoAccessor;try{// eslint-disable-next-line no-extra-parens, no-proto
hasProtoAccessor=/** @type {{ __proto__?: typeof Array.prototype }} */[].__proto__===Array.prototype;}catch(e){if(!e||_typeof(e)!=='object'||!('code'in e)||e.code!=='ERR_PROTO_ACCESS'){throw e;}}// eslint-disable-next-line no-extra-parens
var desc=!!hasProtoAccessor&&gOPD&&gOPD(Object.prototype,/** @type {keyof typeof Object.prototype} */'__proto__');var $Object=Object;var $getPrototypeOf=$Object.getPrototypeOf;/** @type {import('./get')} */module.exports=desc&&typeof desc.get==='function'?callBind([desc.get]):typeof $getPrototypeOf==='function'?/** @type {import('./get')} */function getDunder(value){// eslint-disable-next-line eqeqeq
return $getPrototypeOf(value==null?value:$Object(value));}:false;},{"call-bind-apply-helpers":28,"gopd":106}],41:[function(require,module,exports){'use strict';/** @type {import('.')} */var $defineProperty=Object.defineProperty||false;if($defineProperty){try{$defineProperty({},'a',{value:1});}catch(e){// IE 8 has a broken defineProperty
$defineProperty=false;}}module.exports=$defineProperty;},{}],42:[function(require,module,exports){'use strict';/** @type {import('./eval')} */module.exports=EvalError;},{}],43:[function(require,module,exports){'use strict';/** @type {import('.')} */module.exports=Error;},{}],44:[function(require,module,exports){'use strict';/** @type {import('./range')} */module.exports=RangeError;},{}],45:[function(require,module,exports){'use strict';/** @type {import('./ref')} */module.exports=ReferenceError;},{}],46:[function(require,module,exports){'use strict';/** @type {import('./syntax')} */module.exports=SyntaxError;},{}],47:[function(require,module,exports){'use strict';/** @type {import('./type')} */module.exports=TypeError;},{}],48:[function(require,module,exports){'use strict';/** @type {import('./uri')} */module.exports=URIError;},{}],49:[function(require,module,exports){'use strict';/** @type {import('.')} */module.exports=Object;},{}],50:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var R=(typeof Reflect==="undefined"?"undefined":_typeof(Reflect))==='object'?Reflect:null;var ReflectApply=R&&typeof R.apply==='function'?R.apply:function ReflectApply(target,receiver,args){return Function.prototype.apply.call(target,receiver,args);};var ReflectOwnKeys;if(R&&typeof R.ownKeys==='function'){ReflectOwnKeys=R.ownKeys;}else if(Object.getOwnPropertySymbols){ReflectOwnKeys=function ReflectOwnKeys(target){return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));};}else{ReflectOwnKeys=function ReflectOwnKeys(target){return Object.getOwnPropertyNames(target);};}function ProcessEmitWarning(warning){if(console&&console.warn)console.warn(warning);}var NumberIsNaN=Number.isNaN||function NumberIsNaN(value){return value!==value;};function EventEmitter(){EventEmitter.init.call(this);}module.exports=EventEmitter;module.exports.once=once;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._eventsCount=0;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners=10;function checkListener(listener){if(typeof listener!=='function'){throw new TypeError('The "listener" argument must be of type Function. Received type '+_typeof(listener));}}Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){if(typeof arg!=='number'||arg<0||NumberIsNaN(arg)){throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+arg+'.');}defaultMaxListeners=arg;}});EventEmitter.init=function(){if(this._events===undefined||this._events===Object.getPrototypeOf(this)._events){this._events=Object.create(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;};// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||NumberIsNaN(n)){throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+n+'.');}this._maxListeners=n;return this;};function _getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return _getMaxListeners(this);};EventEmitter.prototype.emit=function emit(type){var args=[];for(var i=1;i<arguments.length;i++)args.push(arguments[i]);var doError=type==='error';var events=this._events;if(events!==undefined)doError=doError&&events.error===undefined;else if(!doError)return false;// If there is no 'error' event listener then throw.
if(doError){var er;if(args.length>0)er=args[0];if(er instanceof Error){// Note: The comments on the `throw` lines are intentional, they show
// up in Node's output if this results in an unhandled exception.
throw er;// Unhandled 'error' event
}// At least give some kind of context to the user
var err=new Error('Unhandled error.'+(er?' ('+er.message+')':''));err.context=er;throw err;// Unhandled 'error' event
}var handler=events[type];if(handler===undefined)return false;if(typeof handler==='function'){ReflectApply(handler,this,args);}else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i)ReflectApply(listeners[i],this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;checkListener(listener);events=target._events;if(events===undefined){events=target._events=Object.create(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(events.newListener!==undefined){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
events=target._events;}existing=events[type];}if(existing===undefined){// Optimize the case of one listener. Don't need the extra array object.
existing=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.
existing=events[type]=prepend?[listener,existing]:[existing,listener];// If we've already got an array, just append.
}else if(prepend){existing.unshift(listener);}else{existing.push(listener);}// Check for listener leak
m=_getMaxListeners(target);if(m>0&&existing.length>m&&!existing.warned){existing.warned=true;// No error code for this since it is a Warning
// eslint-disable-next-line no-restricted-syntax
var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' '+String(type)+' listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;ProcessEmitWarning(w);}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;if(arguments.length===0)return this.listener.call(this.target);return this.listener.apply(this.target,arguments);}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=onceWrapper.bind(state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){checkListener(listener);this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){checkListener(listener);this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;checkListener(listener);events=this._events;if(events===undefined)return this;list=events[type];if(list===undefined)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=Object.create(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else{spliceOne(list,position);}if(list.length===1)events[type]=list[0];if(events.removeListener!==undefined)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(events===undefined)return this;// not listening for removeListener, no need to emit
if(events.removeListener===undefined){if(arguments.length===0){this._events=Object.create(null);this._eventsCount=0;}else if(events[type]!==undefined){if(--this._eventsCount===0)this._events=Object.create(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){var keys=Object.keys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=Object.create(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners!==undefined){// LIFO order
for(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(events===undefined)return[];var evlistener=events[type];if(evlistener===undefined)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events!==undefined){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener!==undefined){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?ReflectOwnKeys(this._events):[];};function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i)copy[i]=arr[i];return copy;}function spliceOne(list,index){for(;index+1<list.length;index++)list[index]=list[index+1];list.pop();}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function once(emitter,name){return new Promise(function(resolve,reject){function errorListener(err){emitter.removeListener(name,resolver);reject(err);}function resolver(){if(typeof emitter.removeListener==='function'){emitter.removeListener('error',errorListener);}resolve([].slice.call(arguments));};eventTargetAgnosticAddListener(emitter,name,resolver,{once:true});if(name!=='error'){addErrorHandlerIfEventEmitter(emitter,errorListener,{once:true});}});}function addErrorHandlerIfEventEmitter(emitter,handler,flags){if(typeof emitter.on==='function'){eventTargetAgnosticAddListener(emitter,'error',handler,flags);}}function eventTargetAgnosticAddListener(emitter,name,listener,flags){if(typeof emitter.on==='function'){if(flags.once){emitter.once(name,listener);}else{emitter.on(name,listener);}}else if(typeof emitter.addEventListener==='function'){// EventTarget does not have `error` event semantics like Node
// EventEmitters, we do not listen for `error` events here.
emitter.addEventListener(name,function wrapListener(arg){// IE does not have builtin `{ once: true }` support so we
// have to do it manually.
if(flags.once){emitter.removeEventListener(name,wrapListener);}listener(arg);});}else{throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+_typeof(emitter));}}},{}],51:[function(require,module,exports){module.exports={"name":"fable-log","version":"3.0.16","description":"A simple logging wrapper.","main":"source/Fable-Log.js","scripts":{"start":"node source/Fable-Log.js","coverage":"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec","test":"./node_modules/.bin/mocha -u tdd -R spec","tests":"npx mocha -u tdd --exit -R spec --grep"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"browser":{"./source/Fable-Log-DefaultProviders-Node.js":"./source/Fable-Log-DefaultProviders-Web.js"},"repository":{"type":"git","url":"https://github.com/stevenvelozo/fable-log.git"},"keywords":["logging"],"author":"Steven Velozo <steven@velozo.com> (http://velozo.com/)","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/fable-log/issues"},"homepage":"https://github.com/stevenvelozo/fable-log","devDependencies":{"quackage":"^1.0.33"},"dependencies":{"fable-serviceproviderbase":"^3.0.15"}};},{}],52:[function(require,module,exports){/**
* Base Logger Class
*
*
* @author Steven Velozo <steven@velozo.com>
*/var libFableServiceProviderBase=require('fable-serviceproviderbase').CoreServiceProviderBase;var BaseLogger=/*#__PURE__*/function(_libFableServiceProvi2){function BaseLogger(pLogStreamSettings,pLogStreamHash){var _this6;_classCallCheck2(this,BaseLogger);_this6=_callSuper(this,BaseLogger,[pLogStreamSettings,pLogStreamHash]);// This should not possibly be able to be instantiated without a settings object
_this6._Settings=_typeof(pLogStreamSettings)=='object'?pLogStreamSettings:{};_this6.serviceType='Logging-Provider';// The base logger does nothing but associate a UUID with itself
// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams
// to the same provider.
_this6.loggerUUID=_this6.generateInsecureUUID();// Eventually we can use this array to ompute which levels the provider allows.
// For now it's just used to precompute some string concatenations.
_this6.levels=["trace","debug","info","warn","error","fatal"];return _this6;}// This is meant to generate programmatically insecure UUIDs to identify loggers
_inherits(BaseLogger,_libFableServiceProvi2);return _createClass2(BaseLogger,[{key:"generateInsecureUUID",value:function generateInsecureUUID(){var tmpDate=new Date().getTime();var tmpUUID='LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,function(pCharacter){// Funny algorithm from w3resource that is twister-ish without the deep math and security
// ..but good enough for unique log stream identifiers
var tmpRandomData=(tmpDate+Math.random()*16)%16|0;tmpDate=Math.floor(tmpDate/16);return(pCharacter=='x'?tmpRandomData:tmpRandomData&0x3|0x8).toString(16);});return tmpUUID;}},{key:"initialize",value:function initialize(){// No operation.
}},{key:"trace",value:function trace(pLogText,pLogObject){this.write("trace",pLogText,pLogObject);}},{key:"debug",value:function debug(pLogText,pLogObject){this.write("debug",pLogText,pLogObject);}},{key:"info",value:function info(pLogText,pLogObject){this.write("info",pLogText,pLogObject);}},{key:"warn",value:function warn(pLogText,pLogObject){this.write("warn",pLogText,pLogObject);}},{key:"error",value:function error(pLogText,pLogObject){this.write("error",pLogText,pLogObject);}},{key:"fatal",value:function fatal(pLogText,pLogObject){this.write("fatal",pLogText,pLogObject);}},{key:"write",value:function write(pLogLevel,pLogText,pLogObject){// The base logger does nothing.
return true;}}]);}(libFableServiceProviderBase);module.exports=BaseLogger;},{"fable-serviceproviderbase":59}],53:[function(require,module,exports){/**
* Default Logger Provider Function
*
*
* @author Steven Velozo <steven@velozo.com>
*/// Return the providers that are available without extensions loaded
var getDefaultProviders=function getDefaultProviders(){var tmpDefaultProviders={};tmpDefaultProviders.console=require('./Fable-Log-Logger-Console.js');tmpDefaultProviders["default"]=tmpDefaultProviders.console;return tmpDefaultProviders;};module.exports=getDefaultProviders();},{"./Fable-Log-Logger-Console.js":55}],54:[function(require,module,exports){module.exports=[{"loggertype":"console","streamtype":"console","level":"trace"}];},{}],55:[function(require,module,exports){var libBaseLogger=require('./Fable-Log-BaseLogger.js');var ConsoleLogger=/*#__PURE__*/function(_libBaseLogger){function ConsoleLogger(pLogStreamSettings,pFableLog){var _this7;_classCallCheck2(this,ConsoleLogger);_this7=_callSuper(this,ConsoleLogger,[pLogStreamSettings]);_this7._ShowTimeStamps='showtimestamps'in _this7._Settings?_this7._Settings.showtimestamps==true:true;_this7._FormattedTimeStamps='formattedtimestamps'in _this7._Settings?_this7._Settings.formattedtimestamps==true:true;_this7._ContextMessage='Context'in _this7._Settings?"(".concat(_this7._Settings.Context,")"):'Product'in pFableLog._Settings?"(".concat(pFableLog._Settings.Product,")"):'Unnamed_Log_Context';// Allow the user to decide what gets output to the console
_this7._OutputLogLinesToConsole='outputloglinestoconsole'in _this7._Settings?_this7._Settings.outputloglinestoconsole:true;_this7._OutputObjectsToConsole='outputobjectstoconsole'in _this7._Settings?_this7._Settings.outputobjectstoconsole:true;// Precompute the prefix for each level
_this7.prefixCache={};for(var i=0;i<=_this7.levels.length;i++){_this7.prefixCache[_this7.levels[i]]="[".concat(_this7.levels[i],"] ").concat(_this7._ContextMessage,": ");if(_this7._ShowTimeStamps){// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first
_this7.prefixCache[_this7.levels[i]]=' '+_this7.prefixCache[_this7.levels[i]];}}return _this7;}_inherits(ConsoleLogger,_libBaseLogger);return _createClass2(ConsoleLogger,[{key:"write",value:function write(pLevel,pLogText,pObject){var tmpTimeStamp='';if(this._ShowTimeStamps&&this._FormattedTimeStamps){tmpTimeStamp=new Date().toISOString();}else if(this._ShowTimeStamps){tmpTimeStamp=+new Date();}var tmpLogLine="".concat(tmpTimeStamp).concat(this.prefixCache[pLevel]).concat(pLogText);if(this._OutputLogLinesToConsole){console.log(tmpLogLine);}// Write out the object on a separate line if it is passed in
if(this._OutputObjectsToConsole&&typeof pObject!=='undefined'){console.log(JSON.stringify(pObject,null,2));}// Provide an easy way to be overridden and be consistent
return tmpLogLine;}}]);}(libBaseLogger);module.exports=ConsoleLogger;},{"./Fable-Log-BaseLogger.js":52}],56:[function(require,module,exports){var libConsoleLog=require('./Fable-Log-Logger-Console.js');var libFS=require('fs');var libPath=require('path');var SimpleFlatFileLogger=/*#__PURE__*/function(_libConsoleLog){function SimpleFlatFileLogger(pLogStreamSettings,pFableLog){var _this8;_classCallCheck2(this,SimpleFlatFileLogger);_this8=_callSuper(this,SimpleFlatFileLogger,[pLogStreamSettings,pFableLog]);// If a path isn't provided for the logfile, it tries to use the ProductName or Context
_this8.logFileRawPath=_this8._Settings.hasOwnProperty('path')?_this8._Settings.path:"./".concat(_this8._ContextMessage,".log");_this8.logFilePath=libPath.normalize(_this8.logFileRawPath);_this8.logFileStreamOptions=_this8._Settings.hasOwnProperty('fileStreamoptions')?_this8._Settings.fileStreamOptions:{"flags":"a","encoding":"utf8"};_this8.fileWriter=libFS.createWriteStream(_this8.logFilePath,_this8.logFileStreamOptions);_this8.activelyWriting=false;_this8.logLineStrings=[];_this8.logObjectStrings=[];_this8.defaultWriteCompleteCallback=function(){};_this8.defaultBufferFlushCallback=function(){};return _this8;}_inherits(SimpleFlatFileLogger,_libConsoleLog);return _createClass2(SimpleFlatFileLogger,[{key:"closeWriter",value:function closeWriter(fCloseComplete){var tmpCloseComplete=typeof fCloseComplete=='function'?fCloseComplete:function(){};if(this.fileWriter){this.fileWriter.end('\n');return this.fileWriter.once('finish',tmpCloseComplete.bind(this));}}},{key:"completeBufferFlushToLogFile",value:function completeBufferFlushToLogFile(fFlushComplete){this.activelyWriting=false;var tmpFlushComplete=typeof fFlushComplete=='function'?fFlushComplete:this.defaultBufferFlushCallback;if(this.logLineStrings.length>0){this.flushBufferToLogFile(tmpFlushComplete);}else{return tmpFlushComplete();}}},{key:"flushBufferToLogFile",value:function flushBufferToLogFile(fFlushComplete){if(!this.activelyWriting){// Only want to be writing one thing at a time....
this.activelyWriting=true;var tmpFlushComplete=typeof fFlushComplete=='function'?fFlushComplete:this.defaultBufferFlushCallback;// Get the current buffer arrays.  These should always have matching number of elements.
var tmpLineStrings=this.logLineStrings;var tmpObjectStrings=this.logObjectStrings;// Reset these to be filled while we process this queue...
this.logLineStrings=[];this.logObjectStrings=[];// This is where we will put each line before writing it to the file...
var tmpConstructedBufferOutputString='';for(var i=0;i<tmpLineStrings.length;i++){// TODO: Windows Newline?   ....... yo no se!
tmpConstructedBufferOutputString+="".concat(tmpLineStrings[i],"\n");if(tmpObjectStrings[i]!==false){tmpConstructedBufferOutputString+="".concat(tmpObjectStrings[i],"\n");}}if(!this.fileWriter.write(tmpConstructedBufferOutputString,'utf8')){// If the streamwriter returns false, we need to wait for it to drain.
this.fileWriter.once('drain',this.completeBufferFlushToLogFile.bind(this,tmpFlushComplete));}else{return this.completeBufferFlushToLogFile(tmpFlushComplete);}}}},{key:"write",value:function write(pLevel,pLogText,pObject){var tmpLogLine=_superPropGet(SimpleFlatFileLogger,"write",this,3)([pLevel,pLogText,pObject]);// Use a very simple array as the write buffer
this.logLineStrings.push(tmpLogLine);// Write out the object on a separate line if it is passed in
if(typeof pObject!=='undefined'){this.logObjectStrings.push(JSON.stringify(pObject,null,4));}else{this.logObjectStrings.push(false);}this.flushBufferToLogFile();}}]);}(libConsoleLog);module.exports=SimpleFlatFileLogger;},{"./Fable-Log-Logger-Console.js":55,"fs":19,"path":135}],57:[function(require,module,exports){/**
* Fable Logging Service
*/var libFableServiceProviderBase=require('fable-serviceproviderbase').CoreServiceProviderBase;var libPackage=require('../package.json');var FableLog=/*#__PURE__*/function(_libFableServiceProvi3){function FableLog(pSettings,pServiceHash){var _this9;_classCallCheck2(this,FableLog);_this9=_callSuper(this,FableLog,[pSettings,pServiceHash]);_this9.serviceType='Logging';/** @type {Object} */_this9._Package=libPackage;var tmpSettings=_typeof(pSettings)==='object'?pSettings:{};_this9._Settings=tmpSettings;_this9._Providers=require('./Fable-Log-DefaultProviders-Node.js');_this9._StreamDefinitions='LogStreams'in tmpSettings?tmpSettings.LogStreams:require('./Fable-Log-DefaultStreams.json');_this9.logStreams=[];// This object gets decorated for one-time instantiated providers that
//  have multiple outputs, such as bunyan.
_this9.logProviders={};// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time
_this9.activeLogStreams={};_this9.logStreamsTrace=[];_this9.logStreamsDebug=[];_this9.logStreamsInfo=[];_this9.logStreamsWarn=[];_this9.logStreamsError=[];_this9.logStreamsFatal=[];_this9.datumDecorator=function(pDatum){return pDatum;};_this9.uuid=typeof tmpSettings.Product==='string'?tmpSettings.Product:'Default';return _this9;}_inherits(FableLog,_libFableServiceProvi3);return _createClass2(FableLog,[{key:"addLogger",value:function addLogger(pLogger,pLevel){// Bail out if we've already created one.
if(pLogger.loggerUUID in this.activeLogStreams){return false;}// Add it to the streams and to the mutex
this.logStreams.push(pLogger);this.activeLogStreams[pLogger.loggerUUID]=true;// Make sure a kosher level was passed in
switch(pLevel){case'trace':this.logStreamsTrace.push(pLogger);case'debug':this.logStreamsDebug.push(pLogger);case'info':this.logStreamsInfo.push(pLogger);case'warn':this.logStreamsWarn.push(pLogger);case'error':this.logStreamsError.push(pLogger);case'fatal':this.logStreamsFatal.push(pLogger);break;}return true;}},{key:"setDatumDecorator",value:function setDatumDecorator(fDatumDecorator){if(typeof fDatumDecorator==='function'){this.datumDecorator=fDatumDecorator;}else{this.datumDecorator=function(pDatum){return pDatum;};}}},{key:"trace",value:function trace(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsTrace.length;i++){this.logStreamsTrace[i].trace(pMessage,tmpDecoratedDatum);}}},{key:"debug",value:function debug(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsDebug.length;i++){this.logStreamsDebug[i].debug(pMessage,tmpDecoratedDatum);}}},{key:"info",value:function info(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsInfo.length;i++){this.logStreamsInfo[i].info(pMessage,tmpDecoratedDatum);}}},{key:"warn",value:function warn(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsWarn.length;i++){this.logStreamsWarn[i].warn(pMessage,tmpDecoratedDatum);}}},{key:"error",value:function error(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsError.length;i++){this.logStreamsError[i].error(pMessage,tmpDecoratedDatum);}}},{key:"fatal",value:function fatal(pMessage,pDatum){var tmpDecoratedDatum=this.datumDecorator(pDatum);for(var i=0;i<this.logStreamsFatal.length;i++){this.logStreamsFatal[i].fatal(pMessage,tmpDecoratedDatum);}}},{key:"initialize",value:function initialize(){// "initialize" each logger as defined in the logging parameters
for(var i=0;i<this._StreamDefinitions.length;i++){var tmpStreamDefinition=Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);if(!(tmpStreamDefinition.loggertype in this._Providers)){console.log("Error initializing log stream: bad loggertype in stream definition ".concat(JSON.stringify(tmpStreamDefinition)));}else{this.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition,this),tmpStreamDefinition.level);}}// Now initialize each one.
for(var _i=0;_i<this.logStreams.length;_i++){this.logStreams[_i].initialize();}}},{key:"logTime",value:function logTime(pMessage,pDatum){var tmpMessage=typeof pMessage!=='undefined'?pMessage:'Time';var tmpTime=new Date();this.info("".concat(tmpMessage," ").concat(tmpTime," (epoch ").concat(+tmpTime,")"),pDatum);}// Get a timestamp
},{key:"getTimeStamp",value:function getTimeStamp(){return+new Date();}},{key:"getTimeDelta",value:function getTimeDelta(pTimeStamp){var tmpEndTime=+new Date();return tmpEndTime-pTimeStamp;}// Log the delta between a timestamp, and now with a message
},{key:"logTimeDelta",value:function logTimeDelta(pTimeDelta,pMessage,pDatum){var tmpMessage=typeof pMessage!=='undefined'?pMessage:'Time Measurement';var tmpDatum=_typeof(pDatum)==='object'?pDatum:{};var tmpEndTime=+new Date();this.info("".concat(tmpMessage," logged at (epoch ").concat(+tmpEndTime,") took (").concat(pTimeDelta,"ms)"),pDatum);}},{key:"logTimeDeltaHuman",value:function logTimeDeltaHuman(pTimeDelta,pMessage,pDatum){var tmpMessage=typeof pMessage!=='undefined'?pMessage:'Time Measurement';var tmpEndTime=+new Date();var tmpMs=parseInt(pTimeDelta%1000);var tmpSeconds=parseInt(pTimeDelta/1000%60);var tmpMinutes=parseInt(pTimeDelta/(1000*60)%60);var tmpHours=parseInt(pTimeDelta/(1000*60*60));tmpMs=tmpMs<10?"00"+tmpMs:tmpMs<100?"0"+tmpMs:tmpMs;tmpSeconds=tmpSeconds<10?"0"+tmpSeconds:tmpSeconds;tmpMinutes=tmpMinutes<10?"0"+tmpMinutes:tmpMinutes;tmpHours=tmpHours<10?"0"+tmpHours:tmpHours;this.info("".concat(tmpMessage," logged at (epoch ").concat(+tmpEndTime,") took (").concat(pTimeDelta,"ms) or (").concat(tmpHours,":").concat(tmpMinutes,":").concat(tmpSeconds,".").concat(tmpMs,")"),pDatum);}},{key:"logTimeDeltaRelative",value:function logTimeDeltaRelative(pStartTime,pMessage,pDatum){this.logTimeDelta(this.getTimeDelta(pStartTime),pMessage,pDatum);}},{key:"logTimeDeltaRelativeHuman",value:function logTimeDeltaRelativeHuman(pStartTime,pMessage,pDatum){this.logTimeDeltaHuman(this.getTimeDelta(pStartTime),pMessage,pDatum);}}]);}(libFableServiceProviderBase);module.exports=FableLog;module.exports.LogProviderBase=require('./Fable-Log-BaseLogger.js');module.exports.LogProviderConsole=require('./Fable-Log-Logger-Console.js');module.exports.LogProviderFlatfile=require('./Fable-Log-Logger-SimpleFlatFile.js');},{"../package.json":51,"./Fable-Log-BaseLogger.js":52,"./Fable-Log-DefaultProviders-Node.js":53,"./Fable-Log-DefaultStreams.json":54,"./Fable-Log-Logger-Console.js":55,"./Fable-Log-Logger-SimpleFlatFile.js":56,"fable-serviceproviderbase":59}],58:[function(require,module,exports){module.exports={"name":"fable-serviceproviderbase","version":"3.0.15","description":"Simple base classes for fable services.","main":"source/Fable-ServiceProviderBase.js","scripts":{"start":"node source/Fable-ServiceProviderBase.js","test":"npx mocha -u tdd -R spec","tests":"npx mocha -u tdd --exit -R spec --grep","coverage":"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec","build":"npx quack build"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"repository":{"type":"git","url":"https://github.com/stevenvelozo/fable-serviceproviderbase.git"},"keywords":["entity","behavior"],"author":"Steven Velozo <steven@velozo.com> (http://velozo.com/)","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/fable-serviceproviderbase/issues"},"homepage":"https://github.com/stevenvelozo/fable-serviceproviderbase","devDependencies":{"fable":"^3.0.143","quackage":"^1.0.33"}};},{}],59:[function(require,module,exports){/**
* Fable Service Base
* @author <steven@velozo.com>
*/var libPackage=require('../package.json');var FableServiceProviderBase=/*#__PURE__*/function(){// The constructor can be used in two ways:
// 1) With a fable, options object and service hash (the options object and service hash are optional)
// 2) With an object or nothing as the first parameter, where it will be treated as the options object
function FableServiceProviderBase(pFable,pOptions,pServiceHash){_classCallCheck2(this,FableServiceProviderBase);// Check if a fable was passed in; connect it if so
if(_typeof(pFable)==='object'&&pFable.isFable){this.connectFable(pFable);}else{this.fable=false;}// Initialize the services map if it wasn't passed in
/** @type {Object} */this._PackageFableServiceProvider=libPackage;// initialize options and UUID based on whether the fable was passed in or not.
if(this.fable){this.UUID=pFable.getUUID();this.options=_typeof(pOptions)==='object'?pOptions:{};}else{// With no fable, check to see if there was an object passed into either of the first two
// Parameters, and if so, treat it as the options object
this.options=_typeof(pFable)==='object'&&!pFable.isFable?pFable:_typeof(pOptions)==='object'?pOptions:{};this.UUID="CORE-SVC-".concat(Math.floor(Math.random()*(99999-10000)+10000));}// It's expected that the deriving class will set this
this.serviceType="Unknown-".concat(this.UUID);// The service hash is used to identify the specific instantiation of the service in the services map
this.Hash=typeof pServiceHash==='string'?pServiceHash:!this.fable&&typeof pOptions==='string'?pOptions:"".concat(this.UUID);}return _createClass2(FableServiceProviderBase,[{key:"connectFable",value:function connectFable(pFable){if(_typeof(pFable)!=='object'||!pFable.isFable){var tmpErrorMessage="Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [".concat(_typeof(pFable),"].}");console.log(tmpErrorMessage);return new Error(tmpErrorMessage);}if(!this.fable){this.fable=pFable;}if(!this.log){this.log=this.fable.Logging;}if(!this.services){this.services=this.fable.services;}if(!this.servicesMap){this.servicesMap=this.fable.servicesMap;}return true;}}]);}();_defineProperty2(FableServiceProviderBase,"isFableService",true);module.exports=FableServiceProviderBase;// This is left here in case we want to go back to having different code/base class for "core" services
module.exports.CoreServiceProviderBase=FableServiceProviderBase;},{"../package.json":58}],60:[function(require,module,exports){module.exports={"name":"fable-settings","version":"3.0.12","description":"A simple, tolerant configuration chain.","main":"source/Fable-Settings.js","scripts":{"start":"node source/Fable-Settings.js","coverage":"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec","test":"./node_modules/.bin/mocha -u tdd -R spec","build":"./node_modules/.bin/gulp build","docker-dev-build-image":"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-settings:local","docker-dev-run":"docker run -it -d --name retold-fable-settings-dev -p 30003:8080 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/fable-settings\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" retold/fable-settings:local"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"repository":{"type":"git","url":"https://github.com/stevenvelozo/fable-settings.git"},"keywords":["configuration"],"author":"Steven Velozo <steven@velozo.com> (http://velozo.com/)","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/fable-settings/issues"},"homepage":"https://github.com/stevenvelozo/fable-settings","devDependencies":{"quackage":"^1.0.33"},"dependencies":{"fable-serviceproviderbase":"^3.0.15","precedent":"^1.0.15"}};},{}],61:[function(require,module,exports){module.exports={"Product":"ApplicationNameHere","ProductVersion":"0.0.0","ConfigFile":false,"LogStreams":[{"level":"trace"}]};},{}],62:[function(require,module,exports){(function(process){(function(){/**
* Fable Settings Template Processor
*
* This class allows environment variables to come in via templated expressions, and defaults to be set.
*
*
* @author Steven Velozo <steven@velozo.com>
* @module Fable Settings
*/var libPrecedent=require('precedent');var FableSettingsTemplateProcessor=/*#__PURE__*/function(){function FableSettingsTemplateProcessor(pDependencies){_classCallCheck2(this,FableSettingsTemplateProcessor);// Use a no-dependencies templating engine to parse out environment variables
this.templateProcessor=new libPrecedent();// TODO: Make the environment variable wrap expression demarcation characters configurable?
this.templateProcessor.addPattern('${','}',function(pTemplateValue){var tmpTemplateValue=pTemplateValue.trim();var tmpSeparatorIndex=tmpTemplateValue.indexOf('|');var tmpDefaultValue=tmpSeparatorIndex>=0?tmpTemplateValue.substring(tmpSeparatorIndex+1):'';var tmpEnvironmentVariableName=tmpSeparatorIndex>-1?tmpTemplateValue.substring(0,tmpSeparatorIndex):tmpTemplateValue;if(tmpEnvironmentVariableName in process.env){return process.env[tmpEnvironmentVariableName];}else{return tmpDefaultValue;}});}return _createClass2(FableSettingsTemplateProcessor,[{key:"parseSetting",value:function parseSetting(pString){return this.templateProcessor.parseString(pString);}}]);}();module.exports=FableSettingsTemplateProcessor;}).call(this);}).call(this,require('_process'));},{"_process":147,"precedent":144}],63:[function(require,module,exports){/**
* Fable Settings Add-on
*
*
* @author Steven Velozo <steven@velozo.com>
* @module Fable Settings
*/var libFableServiceProviderBase=require('fable-serviceproviderbase').CoreServiceProviderBase;var libFableSettingsTemplateProcessor=require('./Fable-Settings-TemplateProcessor.js');var FableSettings=/*#__PURE__*/function(_libFableServiceProvi4){function FableSettings(pSettings,pServiceHash){var _this10;_classCallCheck2(this,FableSettings);_this10=_callSuper(this,FableSettings,[pSettings,pServiceHash]);_this10.serviceType='SettingsManager';_this10._Package=require('../package.json');// Initialize the settings value template processor
_this10.settingsTemplateProcessor=new libFableSettingsTemplateProcessor();// set straight away so anything that uses it respects the initial setting
_this10._configureEnvTemplating(pSettings);_this10["default"]=_this10.buildDefaultSettings();// Construct a new settings object
var tmpSettings=_this10.merge(pSettings,_this10.buildDefaultSettings());// The base settings object (what they were on initialization, before other actors have altered them)
_this10.base=JSON.parse(JSON.stringify(tmpSettings));if(tmpSettings.DefaultConfigFile){try{// If there is a DEFAULT configuration file, try to load and merge it.
tmpSettings=_this10.merge(require(tmpSettings.DefaultConfigFile),tmpSettings);}catch(pException){// Why this?  Often for an app we want settings to work out of the box, but
// would potentially want to have a config file for complex settings.
console.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');console.log('     Loading Exception: '+pException);}}if(tmpSettings.ConfigFile){try{// If there is a configuration file, try to load and merge it.
tmpSettings=_this10.merge(require(tmpSettings.ConfigFile),tmpSettings);}catch(pException){// Why this?  Often for an app we want settings to work out of the box, but
// would potentially want to have a config file for complex settings.
console.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');console.log('     Loading Exception: '+pException);}}_this10.settings=tmpSettings;return _this10;}// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.
_inherits(FableSettings,_libFableServiceProvi4);return _createClass2(FableSettings,[{key:"buildDefaultSettings",value:function buildDefaultSettings(){return JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));}// Update the configuration for environment variable templating based on the current settings object
},{key:"_configureEnvTemplating",value:function _configureEnvTemplating(pSettings){// default environment variable templating to on
this._PerformEnvTemplating=!pSettings||pSettings.NoEnvReplacement!==true;}// Resolve (recursive) any environment variables found in settings object.
},{key:"_resolveEnv",value:function _resolveEnv(pSettings){for(var tmpKey in pSettings){if(_typeof(pSettings[tmpKey])==='object'){this._resolveEnv(pSettings[tmpKey]);}else if(typeof pSettings[tmpKey]==='string'){pSettings[tmpKey]=this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);}}}/**
	 * Check to see if a value is an object (but not an array).
	 */},{key:"_isObject",value:function _isObject(value){return _typeof(value)==='object'&&!Array.isArray(value);}/**
	 * Merge two plain objects. Keys that are objects in both will be merged property-wise.
	 */},{key:"_deepMergeObjects",value:function _deepMergeObjects(toObject,fromObject){var _this11=this;if(!fromObject||!this._isObject(fromObject)){return;}Object.keys(fromObject).forEach(function(key){var fromValue=fromObject[key];if(_this11._isObject(fromValue)){var toValue=toObject[key];if(toValue&&_this11._isObject(toValue)){// both are objects, so do a recursive merge
_this11._deepMergeObjects(toValue,fromValue);return;}}toObject[key]=fromValue;});return toObject;}// Merge some new object into the existing settings.
},{key:"merge",value:function merge(pSettingsFrom,pSettingsTo){// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work
var tmpSettingsFrom=_typeof(pSettingsFrom)==='object'?pSettingsFrom:{};// Default to the settings object if none is passed in for the merge.
var tmpSettingsTo=_typeof(pSettingsTo)==='object'?pSettingsTo:this.settings;// do not mutate the From object property values
var tmpSettingsFromCopy=JSON.parse(JSON.stringify(tmpSettingsFrom));tmpSettingsTo=this._deepMergeObjects(tmpSettingsTo,tmpSettingsFromCopy);if(this._PerformEnvTemplating){this._resolveEnv(tmpSettingsTo);}// Update env tempating config, since we just updated the config object, and it may have changed
this._configureEnvTemplating(tmpSettingsTo);return tmpSettingsTo;}// Fill in settings gaps without overwriting settings that are already there
},{key:"fill",value:function fill(pSettingsFrom){// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work
var tmpSettingsFrom=_typeof(pSettingsFrom)==='object'?pSettingsFrom:{};// do not mutate the From object property values
var tmpSettingsFromCopy=JSON.parse(JSON.stringify(tmpSettingsFrom));this.settings=this._deepMergeObjects(tmpSettingsFromCopy,this.settings);return this.settings;}}]);}(libFableServiceProviderBase);;// This is for backwards compatibility
function autoConstruct(pSettings){return new FableSettings(pSettings);}module.exports=FableSettings;module.exports["new"]=autoConstruct;},{"../package.json":60,"./Fable-Settings-Default":61,"./Fable-Settings-TemplateProcessor.js":62,"fable-serviceproviderbase":59}],64:[function(require,module,exports){module.exports={"name":"fable-uuid","version":"3.0.11","description":"A simple UUID Generator.","main":"source/Fable-UUID.js","scripts":{"start":"node source/Fable-UUID.js","coverage":"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec","test":"./node_modules/.bin/mocha -u tdd -R spec","build":"./node_modules/.bin/gulp build","docker-dev-build-image":"docker build ./ -f Dockerfile_LUXURYCode -t retold/fable-uuid:local","docker-dev-run":"docker run -it -d --name retold-fable-uuid-dev -p 30002:8080 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/fable-uuid\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" retold/fable-uuid:local"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"repository":{"type":"git","url":"https://github.com/stevenvelozo/fable-uuid.git"},"keywords":["logging"],"author":"Steven Velozo <steven@velozo.com> (http://velozo.com/)","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/fable-uuid/issues"},"browser":{"./source/Fable-UUID-Random.js":"./source/Fable-UUID-Random-Browser.js"},"homepage":"https://github.com/stevenvelozo/fable-uuid","devDependencies":{"quackage":"^1.0.33"},"dependencies":{"fable-serviceproviderbase":"^3.0.15"}};},{}],65:[function(require,module,exports){/**
* Random Byte Generator - Browser version
*
*
* @author Steven Velozo <steven@velozo.com>
*/// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var RandomBytes=/*#__PURE__*/function(){function RandomBytes(){_classCallCheck2(this,RandomBytes);// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
this.getRandomValues=typeof crypto!='undefined'&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!='undefined'&&typeof window.msCrypto.getRandomValues=='function'&&msCrypto.getRandomValues.bind(msCrypto);}// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
return _createClass2(RandomBytes,[{key:"generateWhatWGBytes",value:function generateWhatWGBytes(){var tmpBuffer=new Uint8Array(16);// eslint-disable-line no-undef
this.getRandomValues(tmpBuffer);return tmpBuffer;}// Math.random()-based (RNG)
},{key:"generateRandomBytes",value:function generateRandomBytes(){// If all else fails, use Math.random().  It's fast, but is of unspecified
// quality.
var tmpBuffer=new Uint8Array(16);// eslint-disable-line no-undef
for(var i=0,tmpValue;i<16;i++){if((i&0x03)===0){tmpValue=Math.random()*0x100000000;}tmpBuffer[i]=tmpValue>>>((i&0x03)<<3)&0xff;}return tmpBuffer;}},{key:"generate",value:function generate(){if(this.getRandomValues){return this.generateWhatWGBytes();}else{return this.generateRandomBytes();}}}]);}();module.exports=RandomBytes;},{}],66:[function(require,module,exports){/**
* Fable UUID Generator
*/var libFableServiceProviderBase=require('fable-serviceproviderbase').CoreServiceProviderBase;0;var libRandomByteGenerator=require('./Fable-UUID-Random.js');var libPackage=require('../package.json');var FableUUID=/*#__PURE__*/function(_libFableServiceProvi5){function FableUUID(pSettings,pServiceHash){var _this12;_classCallCheck2(this,FableUUID);_this12=_callSuper(this,FableUUID,[pSettings,pServiceHash]);_this12.serviceType='UUID';/** @type {Object} */_this12._Package=libPackage;// Determine if the module is in "Random UUID Mode" which means just use the random character function rather than the v4 random UUID spec.
// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.
_this12._UUIDModeRandom=_typeof(pSettings)==='object'&&'UUIDModeRandom'in pSettings?pSettings.UUIDModeRandom==true:false;// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec
// Length for "Random UUID Mode" is set -- if not set it to 8
_this12._UUIDLength=_typeof(pSettings)==='object'&&'UUIDLength'in pSettings?pSettings.UUIDLength+0:8;// Dictionary for "Random UUID Mode"
_this12._UUIDRandomDictionary=_typeof(pSettings)==='object'&&'UUIDDictionary'in pSettings?pSettings.UUIDDictionary+0:'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';_this12.randomByteGenerator=new libRandomByteGenerator();// Lookup table for hex codes
_this12._HexLookup=[];for(var i=0;i<256;++i){_this12._HexLookup[i]=(i+0x100).toString(16).substr(1);}return _this12;}// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)
_inherits(FableUUID,_libFableServiceProvi5);return _createClass2(FableUUID,[{key:"bytesToUUID",value:function bytesToUUID(pBuffer){var i=0;// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
return[this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],'-',this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],'-',this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],'-',this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],'-',this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]],this._HexLookup[pBuffer[i++]]].join('');}// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)
},{key:"generateUUIDv4",value:function generateUUIDv4(){var tmpBuffer=new Array(16);var tmpRandomBytes=this.randomByteGenerator.generate();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
tmpRandomBytes[6]=tmpRandomBytes[6]&0x0f|0x40;tmpRandomBytes[8]=tmpRandomBytes[8]&0x3f|0x80;return this.bytesToUUID(tmpRandomBytes);}// Simple random UUID generation
},{key:"generateRandom",value:function generateRandom(){var tmpUUID='';for(var i=0;i<this._UUIDLength;i++){tmpUUID+=this._UUIDRandomDictionary.charAt(Math.floor(Math.random()*(this._UUIDRandomDictionary.length-1)));}return tmpUUID;}// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)
},{key:"getUUID",value:function getUUID(){if(this._UUIDModeRandom){return this.generateRandom();}else{return this.generateUUIDv4();}}}]);}(libFableServiceProviderBase);// This is for backwards compatibility
function autoConstruct(pSettings){return new FableUUID(pSettings);}module.exports=FableUUID;module.exports["new"]=autoConstruct;},{"../package.json":64,"./Fable-UUID-Random.js":65,"fable-serviceproviderbase":59}],67:[function(require,module,exports){module.exports={"name":"fable","version":"3.0.148","description":"A service dependency injection, configuration and logging library.","main":"source/Fable.js","scripts":{"start":"node source/Fable.js","coverage":"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec","test":"./node_modules/.bin/mocha -u tdd -R spec","build":"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t fable-image:local","docker-dev-run":"docker run -it -d --name fable-dev -p 30001:8080 -p 38086:8086 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/fable\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" fable-image:local","docker-dev-shell":"docker exec -it fable-dev /bin/bash","tests":"./node_modules/mocha/bin/_mocha -u tdd --exit -R spec --grep"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"browser":{"./source/service/Fable-Service-EnvironmentData.js":"./source/service/Fable-Service-EnvironmentData-Web.js","./source/service/Fable-Service-FilePersistence.js":"./source/service/Fable-Service-FilePersistence-Web.js"},"repository":{"type":"git","url":"https://github.com/stevenvelozo/fable.git"},"keywords":["entity","behavior"],"author":"Steven Velozo <steven@velozo.com> (http://velozo.com/)","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/fable/issues"},"homepage":"https://github.com/stevenvelozo/fable","devDependencies":{"quackage":"^1.0.36"},"dependencies":{"async.eachlimit":"^0.5.2","async.waterfall":"^0.5.2","big.js":"^6.2.2","cachetrax":"^1.0.4","cookie":"^0.6.0","data-arithmatic":"^1.0.7","dayjs":"^1.11.13","fable-log":"^3.0.16","fable-serviceproviderbase":"^3.0.15","fable-settings":"^3.0.12","fable-uuid":"^3.0.11","manyfest":"^1.0.38","simple-get":"^4.0.1"}};},{}],68:[function(require,module,exports){/**
* Fable Application Services Support Library
* @author <steven@velozo.com>
*/// Pre-init services
var libFableSettings=require('fable-settings');var libFableUUID=require('fable-uuid');var libFableLog=require('fable-log');var libPackage=require('../package.json');var libFableServiceBase=require('fable-serviceproviderbase');var Fable=/*#__PURE__*/function(_libFableServiceBase$){function Fable(pSettings){var _this13;_classCallCheck2(this,Fable);_this13=_callSuper(this,Fable,[pSettings]);// Initialization Phase 0: Set up the lowest level state (fable is a utility service manager at heart)
_this13.serviceType='ServiceManager';/** @type {Object} */_this13._Package=libPackage;// An array of the types of services available
_this13.serviceTypes=[];// A map of instantiated services
_this13.servicesMap={};// A map of the default instantiated service by type
_this13.services={};// A map of class constructors for services
_this13.serviceClasses={};// If we need extra service initialization capabilities
_this13.extraServiceInitialization=false;// Set how noisy the system is about signaling complexity
_this13.LogNoisiness=0;// Initialization Phase 1: Set up the core utility services
// These are things like power, water, and sewage.  They are required for fable to run (e.g. logging, settings, etc)
// Instantiate the default Settings Manager
_this13.SettingsManager=new libFableSettings(pSettings);_this13.SettingsManager=_this13.SettingsManager;// Instantiate the UUID generator
_this13.UUID=new libFableUUID(_this13.SettingsManager.settings);// Instantiate the logging system
_this13.Logging=new libFableLog(_this13.SettingsManager.settings);_this13.Logging.initialize();// Initialization Phase 1.5: Instantiate the service manager
// This is the start actual bootstrapping point for fable.
// For consistency fable is treated as a service.
_this13.ServiceManager=_this13;// TODO: Remove this when Orator and meadow-endpoints are shifted to this new pattern
_this13.serviceManager=_this13;// END TODO
_this13.connectFable(_this13);// --> Bootstrapping of fable into the Service Manager is complete
// Initialization Phase 2: Map in the default services.
// They will then be available in the Default service provider set as well.
_this13.connectPreinitServiceProviderInstance(_this13.UUID);_this13.connectPreinitServiceProviderInstance(_this13.Logging);_this13.connectPreinitServiceProviderInstance(_this13.SettingsManager);// Initialize and instantiate the default baked-in Data Arithmatic service
_this13.addAndInstantiateServiceType('EnvironmentData',require('./services/Fable-Service-EnvironmentData.js'));_this13.addServiceType('Template',require('./services/Fable-Service-Template.js'));_this13.addServiceType('MetaTemplate',require('./services/Fable-Service-MetaTemplate.js'));_this13.addServiceType('Anticipate',require('./services/Fable-Service-Anticipate.js'));_this13.addAndInstantiateServiceType('Dates',require('./services/Fable-Service-DateManipulation.js'));_this13.addAndInstantiateServiceType('DataFormat',require('./services/Fable-Service-DataFormat.js'));_this13.addAndInstantiateServiceType('DataGeneration',require('./services/Fable-Service-DataGeneration.js'));_this13.addAndInstantiateServiceType('Utility',require('./services/Fable-Service-Utility.js'));_this13.addAndInstantiateServiceType('Math',require('./services/Fable-Service-Math.js'));_this13.addServiceType('ExpressionParser',require('./services/Fable-Service-ExpressionParser.js'));_this13.addServiceType('RestClient',require('./services/Fable-Service-RestClient.js'));_this13.addServiceType('Manifest',require('manyfest'));_this13.addServiceType('ObjectCache',require('cachetrax'));_this13.addAndInstantiateServiceType('ProgressTime',require('./services/Fable-Service-ProgressTime.js'));_this13.addServiceType('ProgressTrackerSet',require('./services/Fable-Service-ProgressTrackerSet.js'));_this13.addServiceType('Operation',require('./services/Fable-Service-Operation.js'));_this13.addServiceType('CSVParser',require('./services/Fable-Service-CSVParser.js'));_this13.addServiceType('FilePersistence',require('./services/Fable-Service-FilePersistence.js'));return _this13;}/* State Accessors */_inherits(Fable,_libFableServiceBase$);return _createClass2(Fable,[{key:"isFable",get:function get(){return true;}},{key:"settings",get:function get(){return this.SettingsManager.settings;}},{key:"settingsManager",get:function get(){return this.SettingsManager;}// For backwards compatibility
},{key:"getUUID",value:function getUUID(){return this.UUID.getUUID();}},{key:"newAnticipate",value:function newAnticipate(){return this.instantiateServiceProviderWithoutRegistration('Anticipate');}},{key:"newManyfest",value:function newManyfest(pManifestDefinition){return this.instantiateServiceProviderWithoutRegistration('Manifest',pManifestDefinition);}/* Service Manager Methods */},{key:"addServiceType",value:function addServiceType(pServiceType,pServiceClass){if(pServiceType in this.servicesMap){// TODO: Check if any services are running?
this.log.warn("Adding a service type [".concat(pServiceType,"] that already exists.  This will change the default class prototype for this service."));}else{// Add the container for instantiated services to go in
this.servicesMap[pServiceType]={};// Add the type to the list of types
this.serviceTypes.push(pServiceType);}// Using the static member of the class is a much more reliable way to check if it is a service class than instanceof
if(typeof pServiceClass=='function'&&pServiceClass.isFableService){// Add the class to the list of classes
this.serviceClasses[pServiceType]=pServiceClass;}else{// Add the base class to the list of classes
this.log.error("Attempted to add service type [".concat(pServiceType,"] with an invalid class.  Using base service class, which will not crash but won't provide meaningful services."));this.serviceClasses[pServiceType]=libFableServiceBase;}return this.serviceClasses[pServiceType];}},{key:"addServiceTypeIfNotExists",value:function addServiceTypeIfNotExists(pServiceType,pServiceClass){if(!(pServiceType in this.servicesMap)){return this.addServiceType(pServiceType,pServiceClass);}else{return this.serviceClasses[pServiceType];}}// This is for the services that are meant to run mostly single-instance so need a default at initialization
},{key:"addAndInstantiateServiceType",value:function addAndInstantiateServiceType(pServiceType,pServiceClass){this.addServiceType(pServiceType,pServiceClass);return this.instantiateServiceProvider(pServiceType,{},"".concat(pServiceType,"-Default"));}},{key:"addAndInstantiateServiceTypeIfNotExists",value:function addAndInstantiateServiceTypeIfNotExists(pServiceType,pServiceClass){this.addServiceTypeIfNotExists(pServiceType,pServiceClass);if(!(pServiceType in this.servicesMap)||!(pServiceType in this.fable)){return this.instantiateServiceProvider(pServiceType,{},"".concat(pServiceType,"-Default"));}else{return this[pServiceType];}}},{key:"addAndInstantiateSingletonService",value:function addAndInstantiateSingletonService(pServiceType,pOptions,pServiceClass){this.addServiceTypeIfNotExists(pServiceType,pServiceClass);if(!(pServiceType in this.servicesMap)||!(pServiceType in this.fable)){return this.instantiateServiceProvider(pServiceType,{},"".concat(pServiceType,"-Default"));}else{return this[pServiceType];}}// Some services expect to be overloaded / customized class.
},{key:"instantiateServiceProviderFromPrototype",value:function instantiateServiceProviderFromPrototype(pServiceType,pOptions,pCustomServiceHash,pServicePrototype){// Instantiate the service
var tmpService=new pServicePrototype(this,pOptions,pCustomServiceHash);if(this.extraServiceInitialization){tmpService=this.extraServiceInitialization(tmpService);}// Add the service to the service map
this.servicesMap[pServiceType][tmpService.Hash]=tmpService;// If this is the first service of this type, make it the default
if(!(pServiceType in this.services)){this.setDefaultServiceInstantiation(pServiceType,tmpService.Hash);}return tmpService;}},{key:"instantiateServiceProvider",value:function instantiateServiceProvider(pServiceType,pOptions,pCustomServiceHash){// Instantiate the service
var tmpService=this.instantiateServiceProviderWithoutRegistration(pServiceType,pOptions,pCustomServiceHash);// Add the service to the service map
this.servicesMap[pServiceType][tmpService.Hash]=tmpService;// If this is the first service of this type, make it the default
if(!(pServiceType in this.services)){this.setDefaultServiceInstantiation(pServiceType,tmpService.Hash);}return tmpService;}},{key:"instantiateServiceProviderIfNotExists",value:function instantiateServiceProviderIfNotExists(pServiceType,pOptions,pCustomServiceHash){if(pServiceType in this.services){return this.services[pServiceType];}else{return this.instantiateServiceProvider(pServiceType,pOptions,pCustomServiceHash);}}// Create a service provider but don't register it to live forever in fable.services
},{key:"instantiateServiceProviderWithoutRegistration",value:function instantiateServiceProviderWithoutRegistration(pServiceType,pOptions,pCustomServiceHash){// Instantiate the service
var tmpService=new this.serviceClasses[pServiceType](this,pOptions,pCustomServiceHash);if(this.extraServiceInitialization){tmpService=this.extraServiceInitialization(tmpService);}return tmpService;}// Connect an initialized service provider that came before Fable was initialized
},{key:"connectPreinitServiceProviderInstance",value:function connectPreinitServiceProviderInstance(pServiceInstance){var tmpServiceType=pServiceInstance.serviceType;var tmpServiceHash=pServiceInstance.Hash;// The service should already be instantiated, so just connect it to fable
pServiceInstance.connectFable(this);// Add the service type to the map if it isn't there yet
if(!(tmpServiceType in this.servicesMap)){// If the core service hasn't registered itself yet, create the service container for it.
// This means you couldn't register another with this type unless it was later registered with a constructor class.
this.servicesMap[tmpServiceType]={};}// Add the service to the service map
this.servicesMap[tmpServiceType][tmpServiceHash]=pServiceInstance;// If this is the first service of this type, make it the default
if(!(tmpServiceType in this.services)){this.setDefaultServiceInstantiation(tmpServiceType,tmpServiceHash,false);}return pServiceInstance;}},{key:"setDefaultServiceInstantiation",value:function setDefaultServiceInstantiation(pServiceType,pServiceHash,pOverwriteService){// Overwrite services by default, unless told not to
var tmpOverwriteService=typeof pOverwriteService==='undefined'?true:pOverwriteService;// Make sure the service exists
if(pServiceHash in this.servicesMap[pServiceType]){if(!(pServiceType in this)||tmpOverwriteService){this[pServiceType]=this.servicesMap[pServiceType][pServiceHash];}if(!(pServiceType in this.services)||tmpOverwriteService){this.services[pServiceType]=this.servicesMap[pServiceType][pServiceHash];}return true;}return false;}/**
	 * Generate a safe string to use in filenames for a date.  Useful for log file uniqueness and temporary outputs.
	 *
	 * @static
	 * @param {Date} pDate - An optional javascript Date object to generate a datestamp for.
	 * @returns {string} - A string formatted as YYYY-MM-DD-HH-MM-SS
	 */}],[{key:"generateFileNameDateStamp",value:function generateFileNameDateStamp(pDate){var tmpDate=pDate||new Date();var tmpYear=tmpDate.getFullYear();var tmpMonth=String(tmpDate.getMonth()+1).padStart(2,'0');var tmpDay=String(tmpDate.getDate()).padStart(2,'0');var tmpHour=String(tmpDate.getHours()).padStart(2,'0');var tmpMinute=String(tmpDate.getMinutes()).padStart(2,'0');var tmpSecond=String(tmpDate.getSeconds()).padStart(2,'0');return"".concat(tmpYear,"-").concat(tmpMonth,"-").concat(tmpDay,"-").concat(tmpHour,"-").concat(tmpMinute,"-").concat(tmpSecond);}}]);}(libFableServiceBase.CoreServiceProviderBase);// This is for backwards compatibility
function autoConstruct(pSettings){return new Fable(pSettings);}module.exports=Fable;module.exports["new"]=autoConstruct;module.exports.LogProviderBase=libFableLog.LogProviderBase;module.exports.ServiceProviderBase=libFableServiceBase;module.exports.CoreServiceProviderBase=libFableServiceBase.CoreServiceProviderBase;module.exports.precedent=libFableSettings.precedent;},{"../package.json":67,"./services/Fable-Service-Anticipate.js":69,"./services/Fable-Service-CSVParser.js":70,"./services/Fable-Service-DataFormat.js":71,"./services/Fable-Service-DataGeneration.js":73,"./services/Fable-Service-DateManipulation.js":74,"./services/Fable-Service-EnvironmentData.js":75,"./services/Fable-Service-ExpressionParser.js":76,"./services/Fable-Service-FilePersistence.js":86,"./services/Fable-Service-Math.js":87,"./services/Fable-Service-MetaTemplate.js":88,"./services/Fable-Service-Operation.js":92,"./services/Fable-Service-ProgressTime.js":93,"./services/Fable-Service-ProgressTrackerSet.js":95,"./services/Fable-Service-RestClient.js":96,"./services/Fable-Service-Template.js":97,"./services/Fable-Service-Utility.js":98,"cachetrax":22,"fable-log":57,"fable-serviceproviderbase":59,"fable-settings":63,"fable-uuid":66,"manyfest":124}],69:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var FableServiceAnticipate=/*#__PURE__*/function(_libFableServiceBase){function FableServiceAnticipate(pFable,pOptions,pServiceHash){var _this14;_classCallCheck2(this,FableServiceAnticipate);_this14=_callSuper(this,FableServiceAnticipate,[pFable,pOptions,pServiceHash]);_this14.serviceType='AsyncAnticipate';// The queue of operations waiting to run.
_this14.operationQueue=[];_this14.erroredOperations=[];_this14.executingOperationCount=0;_this14.completedOperationCount=0;_this14.callDepth=0;_this14.maxOperations=1;_this14.lastError=undefined;_this14.waitingFunctions=[];return _this14;}_inherits(FableServiceAnticipate,_libFableServiceBase);return _createClass2(FableServiceAnticipate,[{key:"checkQueue",value:function checkQueue(){// This could be combined with the last else if stanza but the logic for errors and non-errors would be blended and more complex to follow so keeping it unrolled.
if(this.lastError){// If there are no operations left, and we have waiting functions, call them.
for(var i=0;i<this.waitingFunctions.length;i++){//this.log.trace('Calling waiting function.')
this.waitingFunctions[i](this.lastError);}// Reset our state
this.lastError=undefined;this.waitingFunctions=[];}// This checks to see if we need to start any operations.
else if(this.operationQueue.length>0&&this.executingOperationCount<this.maxOperations){var tmpOperation=this.operationQueue.shift();this.executingOperationCount+=1;tmpOperation(this.buildAnticipatorCallback());}else if(this.waitingFunctions.length>0&&this.executingOperationCount<1){// If there are no operations left, and we have waiting functions, call them.
for(var _i2=0;_i2<this.waitingFunctions.length;_i2++){//this.log.trace('Calling waiting function.')
this.waitingFunctions[_i2](this.lastError);}// Reset our state
this.lastError=undefined;this.waitingFunctions=[];}}// Expects a function fAsynchronousFunction(fCallback)
},{key:"anticipate",value:function anticipate(fAsynchronousFunction){//this.log.trace('Adding a function...')
this.operationQueue.push(fAsynchronousFunction);this.checkQueue();}},{key:"buildAnticipatorCallback",value:function buildAnticipatorCallback(){// This uses closure-scoped state to track the callback state
var tmpCallbackState={Called:false,Error:undefined,OperationSet:this};return hoistedCallback.bind(this);function hoistedCallback(pError){if(tmpCallbackState.Called){// If they call the callback twice, throw an error
throw new Error("Anticipation async callback called twice...");}tmpCallbackState.Called=true;this.lastError=pError;tmpCallbackState.OperationSet.executingOperationCount-=1;tmpCallbackState.OperationSet.completedOperationCount+=1;tmpCallbackState.OperationSet.callDepth++;// TODO: Figure out a better pattern for chaining templates so the call stack doesn't get abused.
if(tmpCallbackState.OperationSet.callDepth>400){tmpCallbackState.OperationSet.callDepth=0;setTimeout(tmpCallbackState.OperationSet.checkQueue.bind(this),0);}else{tmpCallbackState.OperationSet.checkQueue();}}}},{key:"wait",value:function wait(fCallback){this.waitingFunctions.push(fCallback);this.checkQueue();}}]);}(libFableServiceBase);module.exports=FableServiceAnticipate;},{"fable-serviceproviderbase":59}],70:[function(require,module,exports){var libFableServiceProviderBase=require('fable-serviceproviderbase');/**
* Parsing CSVs.  Why?  Because it's a thing that needs to be done.
*
* 1. And the other node CSV parsers had issues with the really messy files we had.
* 
*
* 2. None of the CSV parsers dealt with and multi-line quoted string columns
*    which are apparently a-ok according to the official spec.
* Plus a lot of them are asynchronous because apparently that's the best way to
* do anything; unfortunately some files have a sequence issue with that.
*
* @class CSVParser
*/var CSVParser=/*#__PURE__*/function(_libFableServiceProvi6){function CSVParser(pFable,pOptions,pServiceHash){var _this15;_classCallCheck2(this,CSVParser);_this15=_callSuper(this,CSVParser,[pFable,pOptions,pServiceHash]);_this15.serviceType='CSVParser';_this15.Header=[];_this15.HeaderFieldNames=[];_this15.Delimiter=',';_this15.QuoteCharacter='"';_this15.CleanCharacters=['\r'];_this15.HeaderLineIndex=0;_this15.HasHeader=true;_this15.HasSetHeader=false;_this15.EmitHeader=false;_this15.EmitJSON=true;_this15.EscapedQuoteString='&quot;';// Current Line Parsing State
_this15.CurrentLine='';_this15.CurrentRecord=[];_this15.InQuote=false;_this15.InEscapedQuote=false;_this15.LinesParsed=0;_this15.RowsEmitted=0;return _this15;}_inherits(CSVParser,_libFableServiceProvi6);return _createClass2(CSVParser,[{key:"marshalRowToJSON",value:function marshalRowToJSON(pRowArray){if(!Array.isArray(pRowArray)){return false;}for(var i=this.HeaderFieldNames.length;i<pRowArray.length;i++){this.HeaderFieldNames[i]="".concat(i);}var tmpObject={};for(var _i3=0;_i3<pRowArray.length;_i3++){tmpObject[this.HeaderFieldNames[_i3]]=pRowArray[_i3];}return tmpObject;}// Set the header data, for use in marshalling to JSON.
},{key:"setHeader",value:function setHeader(pHeaderArray){this.Header=pHeaderArray;for(var i=0;i<this.Header.length;i++){if(typeof this.Header[i]=='undefined'){this.HeaderFieldNames[i]="".concat(i);}else{this.HeaderFieldNames[i]=this.Header[i].toString().trim();}}}},{key:"resetRowState",value:function resetRowState(){this.CurrentRecord=[];}},{key:"pushLine",value:function pushLine(){for(var i=0;i<this.CleanCharacters.length;i++){this.CurrentLine=this.CurrentLine.replace(this.CleanCharacters[i],'');}this.CurrentRecord.push(this.CurrentLine);this.CurrentLine='';}},{key:"emitRow",value:function emitRow(pFormatAsJSON){var tmpFormatAsJSON=typeof pFormatAsJSON=='undefined'?this.EmitJSON:pFormatAsJSON;this.RowsEmitted++;var tmpCompletedRecord=this.CurrentRecord;this.CurrentRecord=[];if(tmpFormatAsJSON){return this.marshalRowToJSON(tmpCompletedRecord);}else{return tmpCompletedRecord;}}},{key:"parseCSVLine",value:function parseCSVLine(pLineString){this.LinesParsed++;for(var i=0;i<pLineString.length;i++){if(!this.InQuote&&pLineString[i]==this.Delimiter){this.pushLine();}else if(pLineString[i]==this.QuoteCharacter){// If we are in the second part of an escaped quote, ignore it.
if(this.InEscapedQuote){this.InEscapedQuote=false;}// If we aren't in a quote, enter quote
else if(!this.InQuote){this.InQuote=true;}// We are in a quote, so peek forward to see if this is an "escaped" quote pair
else if(i<pLineString.length&&pLineString[i+1]==this.QuoteCharacter){this.CurrentLine+=this.EscapedQuoteString;this.InEscapedQuote=true;}// We are in a quote, this isn't an "escaped" quote pair, so go out of quote mode
else{this.InQuote=false;}}else{this.CurrentLine+=pLineString[i];}}// See if we are in a multiline quoted entry -- if not, emit the row.
if(!this.InQuote){// Push the last remaining column from the buffer to the current line.
this.pushLine();// Check to see if there is a header -- and if so, if this is the header row
if(this.HasHeader&&!this.HasSetHeader&&this.RowsEmitted==this.HeaderLineIndex){this.HasSetHeader=true;// Override the format as json bit
this.setHeader(this.emitRow(false));// No matter what, formatting this as JSON is silly and we don't want to go there anyway.
if(this.EmitHeader){return this.Header;}else{return false;}}else{return this.emitRow();}}else{return false;}}}]);}(libFableServiceProviderBase);module.exports=CSVParser;},{"fable-serviceproviderbase":59}],71:[function(require,module,exports){var libFableServiceProviderBase=require('fable-serviceproviderbase');/**
* Data Formatting and Translation Functions
*
* @class DataFormat
*/var DataFormat=/*#__PURE__*/function(_libFableServiceProvi7){function DataFormat(pFable,pOptions,pServiceHash){var _this16;_classCallCheck2(this,DataFormat);_this16=_callSuper(this,DataFormat,[pFable,pOptions,pServiceHash]);/**
	 * Pad the start of a string.
	 *
	 * @param {*} pString
	 * @param {number} pTargetLength
	 * @returns {string} pPadString
	 */_defineProperty2(_this16,"stringPadStart",function(pString,pTargetLength,pPadString){var tmpString=pString.toString();return this.stringGeneratePaddingString(tmpString,pTargetLength,pPadString)+tmpString;});/**
	 * Pad the end of a string.
	 *
	 * @param {*} pString
	 * @param {number} pTargetLength
	 * @returns {string} pPadString
	 */_defineProperty2(_this16,"stringPadEnd",function(pString,pTargetLength,pPadString){var tmpString=pString.toString();return tmpString+this.stringGeneratePaddingString(tmpString,pTargetLength,pPadString);});_this16.serviceType='DataArithmatic';// Regular Expressions (so they don't have to be recompiled every time)
// These could be defined as static, but I'm not sure if that will work with browserify ... and specifically the QT browser.
_this16._Regex_formatterInsertCommas=/.{1,3}/g;// Match Function:
// function(pMatch, pSign, pZeros, pBefore, pDecimal, pAfter)
// Thoughts about below:   /^([+-]?)(0*)(\d+)(\.(\d+))?$/;
_this16._Regex_formatterAddCommasToNumber=/^([-+]?)(0?)(\d+)(.?)(\d+)$/g;_this16._Regex_formatterDollarsRemoveCommas=/,/gi;_this16._Regex_formatterCleanNonAlphaChar=/[^a-zA-Z]/gi;_this16._Regex_formatterCapitalizeEachWord=/([a-zA-Z]+)/g;// TODO: Potentially pull these in from a configuration.
// TODO: Use locale data for this if it's defaults all the way down.
_this16._Value_MoneySign_Currency='$';_this16._Value_NaN_Currency='--';_this16._Value_GroupSeparator_Number=',';_this16._Value_Prefix_StringHash='HSH';_this16._Value_Clean_formatterCleanNonAlpha='';_this16._UseEngineStringStartsWith=typeof String.prototype.startsWith==='function';_this16._UseEngineStringEndsWith=typeof String.prototype.endsWith==='function';return _this16;}/*************************************************************************
	 * String Manipulation and Comparison Functions
	 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//**
	 * Reverse a string
	 *
	 * @param {string} pString - The string to reverse
	 * @returns {string}
	 */_inherits(DataFormat,_libFableServiceProvi7);return _createClass2(DataFormat,[{key:"stringReverse",value:function stringReverse(pString){// TODO: Benchmark if there are faster ways we want to do this with all the newer JS stuff
//       ... and if it will work with browserify in a clean way.
return pString.split('').reverse().join('');}/**
	 * Test if a string starts with a given substring.
	 *
	 * @param {*} pString
	 * @param {*} pSearchString
	 * @param {*} pStartIndex
	 * @returns {boolean}
	 */},{key:"stringStartsWith",value:function stringStartsWith(pString,pSearchString,pStartIndex){if(this._UseEngineStringStartsWith){return pString.startsWith(pSearchString,pStartIndex);}else{return this.stringStartsWith_Polyfill.call(pString,pSearchString,pStartIndex);}}/**
	 * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.
	 *
	 * @param {*} pSearchString - The string to search for
	 * @param {*} pStartIndex - The index to start the search at
	 * @returns {boolean}
	 */},{key:"stringStartsWith_Polyfill",value:function stringStartsWith_Polyfill(pSearchString,pStartIndex){return this.slice(pStartIndex||0,pSearchString.length)===pSearchString;}/**
	 * Test if a string starts with a given substring.
	 *
	 * @param {*} pString
	 * @param {*} pSearchString
	 * @param {*} pEndIndex
	 * @returns {*}
	 */},{key:"stringEndsWith",value:function stringEndsWith(pString,pSearchString,pEndIndex){if(this._UseEngineStringEndsWith){return pString.endsWith(pSearchString,pEndIndex);}else{return this.stringEndsWith_Polyfill.call(pString,pSearchString,pEndIndex);}}/**
	 * Check if a string starts with a given substring.  This is a safe polyfill for the ES6 string.startsWith() function.
	 *
	 * @param {*} pSearchString - The string to search for
	 * @param {*} pEndIndex - The index to end the search at
	 * @returns {boolean}
	 */},{key:"stringEndsWith_Polyfill",value:function stringEndsWith_Polyfill(pSearchString,pEndIndex){// This works much better than >= because
// it compensates for NaN:
if(!(pEndIndex<this.length)){pEndIndex=this.length;}else{pEndIndex|=0;// round position
}return this.substr(pEndIndex-pSearchString.length,pSearchString.length)===pSearchString;}/**
	 * Generate an insecure string hash.  Not meant to be secure, just a quick way to generate a hash for a string.  This is not a cryptographic hash.  Additional warranty and disclaimer ... this is not for passwords!
	 *
	 * @param {string} pString
	 * @returns {string}
	 */},{key:"insecureStringHash",value:function insecureStringHash(pString){var tmpHash=0;var tmpStringLength=pString.length;var tmpCharacterIndex=0;while(tmpCharacterIndex<tmpStringLength){tmpHash=(tmpHash<<5)-tmpHash+pString.charCodeAt(tmpCharacterIndex++)|0;}return"".concat(this._Value_Prefix_StringHash).concat(tmpHash);}},{key:"capitalizeEachWord",value:function capitalizeEachWord(pString){return pString.replace(this._Regex_formatterCapitalizeEachWord,function(pMatch){return pMatch.charAt(0).toUpperCase()+pMatch.substr(1);});}/**
	 * Clean wrapping characters if they exist consistently around the string.  If they do not, the string is returned unchanged.
	 *
	 * @param {string} pWrapCharacter - The character expected as the wrapping character
	 * @param {string} pString - the string to clean
	 * @returns {string}
	 */},{key:"cleanEnclosureWrapCharacters",value:function cleanEnclosureWrapCharacters(pWrapCharacter,pString){// # Use case from ManyFest DSL:
//
// When a boxed property is passed in, it should have quotes of some
// kind around it.
//
// For instance:
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// This function is necessary to remove the wrapping quotes before object
// resolution can occur.
if(pString.startsWith(pWrapCharacter)&&pString.endsWith(pWrapCharacter)){return pString.substring(1,pString.length-1);}else{return pString;}}/**
	 * Clean a string of any non-alpha characters (including numbers)
	 *
	 * @param {*} pString
	 * @returns
	 */},{key:"cleanNonAlphaCharacters",value:function cleanNonAlphaCharacters(pString){if(typeof pString=='string'&&pString!=''){return pString.replace(this._Regex_formatterCleanNonAlphaChar,this._Value_Clean_formatterCleanNonAlpha);}return'';}/*************************************************************************
	 * Number Formatting Functions
	 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//**
	 * Insert commas every 3 characters from the right.  Used by formatterAddCommasToNumber().
	 *
	 * @param {*} pString
	 * @returns {*}
	 */},{key:"formatterInsertCommas",value:function formatterInsertCommas(pString){// Reverse, because it's easier to do things from the left, given arbitrary digit counts
var tmpReversed=this.stringReverse(pString);// Add commas every three characters
var tmpReversedWithCommas=tmpReversed.match(this._Regex_formatterInsertCommas).join(',');// Reverse again (back to normal direction)
return this.stringReverse(tmpReversedWithCommas);}},{key:"processAddCommasToNumberRegex",value:function processAddCommasToNumberRegex(pMatch,pSign,pZeros,pBefore,pDecimal,pAfter){// If there was no decimal, the last capture grabs the final digit, so
// we have to put it back together with the 'before' substring
return pSign+(pDecimal?this.formatterInsertCommas(pBefore)+pDecimal+pAfter:this.formatterInsertCommas(pBefore+pAfter));}/**
	 * Add Commas to a Number for readability.
	 *
	 * @param {*} pNumber
	 * @returns {string}
	 */},{key:"formatterAddCommasToNumber",value:function formatterAddCommasToNumber(pNumber){// If the regex doesn't match, `replace` returns the string unmodified
return pNumber.toString().replace(this._Regex_formatterAddCommasToNumber,this.processAddCommasToNumberRegex.bind(this));}/**
	 * This will take a number and format it as a dollar string.  It will also add commas to the number.  If the number is not a number, it will return '--'.
	 *
	 * @param {*} pValue
	 * @returns {string}
	 */},{key:"formatterDollars",value:function formatterDollars(pValue,pPrecision,pRoundingMethod){if(isNaN(pValue)){return this._Value_NaN_Currency;}if(pValue===null||pValue===undefined){return this._Value_NaN_Currency;}var tmpDollarAmountArbitrary=this.fable.Math.parsePrecise(pValue);var tmpPrecision=typeof pPrecision=='undefined'?2:pPrecision;var tmpDollarAmount=this.fable.Math.toFixedPrecise(tmpDollarAmountArbitrary,tmpPrecision,pRoundingMethod);// TODO: Get locale data and use that for this stuff.
return"$".concat(this.formatterAddCommasToNumber(tmpDollarAmount));}/**
	 * Round a number to a certain number of digits.  If the number is not a number, it will return 0.  If no digits are specified, it will default to 2 significant digits.
	 *
	 * @param {*} pValue
	 * @param {number} pDigits
	 * @returns {string}
	 */},{key:"formatterRoundNumber",value:function formatterRoundNumber(pValue,pDigits){var tmpDigits=typeof pDigits=='undefined'?2:pDigits;if(isNaN(pValue)){var tmpZed=0;return tmpZed.toFixed(tmpDigits);}if(pValue===null||pValue===undefined){return'';}var tmpAmountArbitrary=this.fable.Utility.bigNumber(pValue);var tmpValue=tmpAmountArbitrary.toFixed(tmpDigits);if(isNaN(tmpValue)){var _tmpZed=0;return _tmpZed.toFixed(tmpDigits);}else{return tmpValue;}}/**
	 * Generate a reapeating padding string to be appended before or after depending on 
	 * which padding function it uses.
	 *
	 * @param {*} pString
	 * @param {number} pTargetLength
	 * @returns {string} pPadString
	 */},{key:"stringGeneratePaddingString",value:function stringGeneratePaddingString(pString,pTargetLength,pPadString){var tmpTargetLength=pTargetLength>>0;var tmpPadString=String(typeof pPadString!=='undefined'?pPadString:' ');if(pString.length>pTargetLength){// No padding string if the source string is already longer than the target length, return an empty string
return'';}else{var tmpPadLength=pTargetLength-pString.length;if(tmpPadLength>tmpPadString.length){tmpPadString+=tmpPadString.repeat(tmpTargetLength/tmpPadString.length);}return tmpPadString.slice(0,tmpPadLength);}}},{key:"formatTimeSpan",value:/*************************************************************************
	 * Time Formatting Functions (milliseconds)
	 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//**
	 * Format a time length in milliseconds into a human readable string.
	 * @param {number} pTimeSpan 
	 * @returns {string} - HH:MM:SS.mmm
	 */function formatTimeSpan(pTimeSpan){if(typeof pTimeSpan!='number'){return'';}var tmpMs=parseInt(pTimeSpan%1000);var tmpSeconds=parseInt(pTimeSpan/1000%60);var tmpMinutes=parseInt(pTimeSpan/(1000*60)%60);var tmpHours=parseInt(pTimeSpan/(1000*60*60));return"".concat(this.stringPadStart(tmpHours,2,'0'),":").concat(this.stringPadStart(tmpMinutes,2,'0'),":").concat(this.stringPadStart(tmpSeconds,2,'0'),".").concat(this.stringPadStart(tmpMs,3,'0'));}/**
	 * Format the time delta between two times in milliseconds into a human readable string.
	 * 
	 * @param {number} pTimeStart 
	 * @param {number} pTimeEnd 
	 * @returns {string} - HH:MM:SS.mmm
	 */},{key:"formatTimeDelta",value:function formatTimeDelta(pTimeStart,pTimeEnd){if(typeof pTimeStart!='number'||typeof pTimeEnd!='number'){return'';}return this.formatTimeSpan(pTimeEnd-pTimeStart);}// THE FOLLOWING TERRIBLE FUNCTIONS ARE FOR QT / WKHTMLTOPDF when luxon and moment don't work so well
},{key:"getMonthFromDate",value:function getMonthFromDate(pJavascriptDate){var tmpMonths=["January","February","March","April","May","June","July","August","September","October","November","December"];return tmpMonths[pJavascriptDate.getMonth()];}},{key:"getMonthAbbreviatedFromDate",value:function getMonthAbbreviatedFromDate(pJavascriptDate){var tmpMonths=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];return tmpMonths[pJavascriptDate.getMonth()];}},{key:"formatMonthDayYearFromDate",value:function formatMonthDayYearFromDate(pJavascriptDate,pStrict){var tmpStrict=typeof pStrict!=='undefined'?pStrict:false;var tmpMonth=pJavascriptDate.getMonth()+1;var tmpDay=pJavascriptDate.getDate();var tmpYear=pJavascriptDate.getFullYear();if(tmpStrict){tmpMonth=this.stringPadStart(tmpMonth,2,'0');tmpDay=this.stringPadStart(tmpDay,2,'0');tmpYear=this.stringPadStart(tmpYear,4,'0');}return"".concat(tmpMonth,"/").concat(tmpDay,"/").concat(tmpYear);}},{key:"formatSortableStringFromDate",value:function formatSortableStringFromDate(pDate){return pDate.getFullYear()+this.stringPadStart(pDate.getMonth(),2,'0')+this.stringPadStart(pDate.getDate(),2,'0');}/*************************************************************************
	 * String Tokenization Functions
	 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//**
	 * Return the string before the matched substring.
	 *
	 * If the substring is not found, the entire string is returned.  This only deals with the *first* match.
	 *
	 * @param {string} pString
	 * @param {string} pMatch
	 * @returns {string}
	 */},{key:"stringBeforeMatch",value:function stringBeforeMatch(pString,pMatch){return pString.split(pMatch)[0];}/**
	 * Return the string after the matched substring.
	 *
	 * If the substring is not found, an empty string is returned.  This only deals with the *first* match.
	 *
	 * @param {string} pString
	 * @param {string} pMatch
	 * @returns {string}
	 */},{key:"stringAfterMatch",value:function stringAfterMatch(pString,pMatch){var tmpStringSplitLocation=pString.indexOf(pMatch);if(tmpStringSplitLocation<0||tmpStringSplitLocation+pMatch.length>=pString.length){return'';}return pString.substring(tmpStringSplitLocation+pMatch.length);}/**
	 * Count the number of segments in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the count of segments in the string as a number
	 */},{key:"stringCountSegments",value:function stringCountSegments(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2};if(pString.length<1){return 0;}var tmpSegmentCount=1;var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Increment the segment count
tmpSegmentCount++;}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}return tmpSegmentCount;}/**
	 * Get all segments in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the first segment in the string as a string
	 */},{key:"stringGetSegments",value:function stringGetSegments(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2,'"':3,"'":4};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2,'"':3,"'":4};var tmpCurrentSegmentStart=0;var tmpSegmentList=[];if(pString.length<1){return tmpSegmentList;}var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Return the segment
tmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart,i));tmpCurrentSegmentStart=i+1;}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}if(tmpCurrentSegmentStart<tmpString.length){tmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));}return tmpSegmentList;}/**
	 * Get the first segment in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the first segment in the string as a string
	 */},{key:"stringGetFirstSegment",value:function stringGetFirstSegment(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2};if(pString.length<1){return 0;}var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Return the segment
return tmpString.substring(0,i);}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}return tmpString;}/**
	 * Count the number of enclosures in a string based on the start and end characters.
	 *
	 * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.
	 *
	 * @param {string} pString
	 * @param {string} pEnclosureStart
	 * @param {string} pEnclosureEnd
	 * @returns the count of full in the string
	 */},{key:"stringCountEnclosures",value:function stringCountEnclosures(pString,pEnclosureStart,pEnclosureEnd){var tmpString=typeof pString=='string'?pString:'';var tmpEnclosureStart=typeof pEnclosureStart=='string'?pEnclosureStart:'(';var tmpEnclosureEnd=typeof pEnclosureEnd=='string'?pEnclosureEnd:')';var tmpEnclosureCount=0;var tmpEnclosureDepth=0;for(var i=0;i<tmpString.length;i++){// This is the start of an enclosure
if(tmpString[i]==tmpEnclosureStart){if(tmpEnclosureDepth==0){tmpEnclosureCount++;}tmpEnclosureDepth++;}else if(tmpString[i]==tmpEnclosureEnd){tmpEnclosureDepth--;}}return tmpEnclosureCount;}/**
	 * Get the value of the enclosure at the specified index.
	 *
	 * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure
	 *
	 * @param {string} pString
	 * @param {number} pEnclosureIndexToGet
	 * @param {string} pEnclosureStart
	 * @param {string}} pEnclosureEnd
	 * @returns {string}
	 */},{key:"stringGetEnclosureValueByIndex",value:function stringGetEnclosureValueByIndex(pString,pEnclosureIndexToGet,pEnclosureStart,pEnclosureEnd){var tmpString=typeof pString=='string'?pString:'';var tmpEnclosureIndexToGet=typeof pEnclosureIndexToGet=='number'?pEnclosureIndexToGet:0;var tmpEnclosureStart=typeof pEnclosureStart=='string'?pEnclosureStart:'(';var tmpEnclosureEnd=typeof pEnclosureEnd=='string'?pEnclosureEnd:')';var tmpEnclosureCount=0;var tmpEnclosureDepth=0;var tmpMatchedEnclosureIndex=false;var tmpEnclosedValueStartIndex=0;var tmpEnclosedValueEndIndex=0;for(var i=0;i<tmpString.length;i++){// This is the start of an enclosure
if(tmpString[i]==tmpEnclosureStart){tmpEnclosureDepth++;// Only count enclosures at depth 1, but still this parses both pairs of all of them.
if(tmpEnclosureDepth==1){tmpEnclosureCount++;if(tmpEnclosureIndexToGet==tmpEnclosureCount-1){// This is the start of *the* enclosure
tmpMatchedEnclosureIndex=true;tmpEnclosedValueStartIndex=i;}}}// This is the end of an enclosure
else if(tmpString[i]==tmpEnclosureEnd){tmpEnclosureDepth--;// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.
if(tmpEnclosureDepth==0&&tmpMatchedEnclosureIndex&&tmpEnclosedValueEndIndex<=tmpEnclosedValueStartIndex){tmpEnclosedValueEndIndex=i;tmpMatchedEnclosureIndex=false;}}}if(tmpEnclosureCount<=tmpEnclosureIndexToGet){// Return an empty string if the enclosure is not found
return'';}if(tmpEnclosedValueEndIndex>0&&tmpEnclosedValueEndIndex>tmpEnclosedValueStartIndex){return tmpString.substring(tmpEnclosedValueStartIndex+1,tmpEnclosedValueEndIndex);}else{return tmpString.substring(tmpEnclosedValueStartIndex+1);}}/**
	 * Remove an enclosure from a string based on the index of the enclosure.
	 *
	 * @param {string} pString
	 * @param {number} pEnclosureIndexToRemove
	 * @param {number} pEnclosureStart
	 * @param {number} pEnclosureEnd
	 * @returns {string}
	 */},{key:"stringRemoveEnclosureByIndex",value:function stringRemoveEnclosureByIndex(pString,pEnclosureIndexToRemove,pEnclosureStart,pEnclosureEnd){var tmpString=typeof pString=='string'?pString:'';var tmpEnclosureIndexToRemove=typeof pEnclosureIndexToRemove=='number'?pEnclosureIndexToRemove:0;var tmpEnclosureStart=typeof pEnclosureStart=='string'?pEnclosureStart:'(';var tmpEnclosureEnd=typeof pEnclosureEnd=='string'?pEnclosureEnd:')';var tmpEnclosureCount=0;var tmpEnclosureDepth=0;var tmpMatchedEnclosureIndex=false;var tmpEnclosureStartIndex=0;var tmpEnclosureEndIndex=0;for(var i=0;i<tmpString.length;i++){// This is the start of an enclosure
if(tmpString[i]==tmpEnclosureStart){tmpEnclosureDepth++;if(tmpEnclosureDepth==1){tmpEnclosureCount++;if(tmpEnclosureIndexToRemove==tmpEnclosureCount-1){tmpMatchedEnclosureIndex=true;tmpEnclosureStartIndex=i;}}}else if(tmpString[i]==tmpEnclosureEnd){tmpEnclosureDepth--;if(tmpEnclosureDepth==0&&tmpMatchedEnclosureIndex&&tmpEnclosureEndIndex<=tmpEnclosureStartIndex){tmpEnclosureEndIndex=i;tmpMatchedEnclosureIndex=false;}}}if(tmpEnclosureCount<=tmpEnclosureIndexToRemove){return tmpString;}var tmpReturnString='';if(tmpEnclosureStartIndex>1){tmpReturnString=tmpString.substring(0,tmpEnclosureStartIndex);}if(tmpString.length>tmpEnclosureEndIndex+1&&tmpEnclosureEndIndex>tmpEnclosureStartIndex){tmpReturnString+=tmpString.substring(tmpEnclosureEndIndex+1);}return tmpReturnString;}}]);}(libFableServiceProviderBase);module.exports=DataFormat;},{"fable-serviceproviderbase":59}],72:[function(require,module,exports){module.exports={"DefaultIntegerMinimum":0,"DefaultIntegerMaximum":9999999,"DefaultNumericStringLength":10,"MonthSet":["January","February","March","April","May","June","July","August","September","October","November","December"],"WeekDaySet":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"ColorSet":["Red","Orange","Yellow","Green","Blue","Indigo","Violet","Pink","Purple","Turquoise","Gold","Lime","Maroon","Navy","Coral","Teal","Brown","White","Black","Sky","Berry","Grey","Straw","Silver","Sapphire"],"SurNameSet":["Smith","Johnson","Williams","Brown","Jones","Miller","Davis","Garcia","Rodriguez","Wilson","Martinez","Anderson","Taylor","Thomas","Hernandez","Moore","Martin","Jackson","Thompson","White","Lopez","Lee","Gonzalez","Harris","Clark","Lewis","Robinson","Walker","Perez","Hall","Young","Allen","Sanchez","Wright","King","Scott","Green","Baker","Adams","Nelson","Hill","Ramirez","Campbell","Mitchell","Roberts","Carter","Phillips","Evans","Turner","Torres","Parker","Collins","Edwards","Stewart","Flores","Morris","Nguyen","Murphy","Rivera","Cook","Rogers","Morgan","Peterson","Cooper","Reed","Bailey","Bell","Gomez","Kelly","Howard","Ward","Cox","Diaz","Richardson","Wood","Watson","Brooks","Bennett","Gray","James","Reyes","Cruz","Hughes","Price","Myers","Long","Foster","Sanders","Ross","Morales","Powell","Sullivan","Russell","Ortiz","Jenkins","Gutierrez","Perry","Butler","Barnes","Fisher"],"NameSet":["Mary","Patricia","Jennifer","Linda","Elizabeth","Barbara","Susan","Jessica","Sarah","Karen","Lisa","Nancy","Betty","Sandra","Margaret","Ashley","Kimberly","Emily","Donna","Michelle","Carol","Amanda","Melissa","Deborah","Stephanie","Dorothy","Rebecca","Sharon","Laura","Cynthia","Amy","Kathleen","Angela","Shirley","Brenda","Emma","Anna","Pamela","Nicole","Samantha","Katherine","Christine","Helen","Debra","Rachel","Carolyn","Janet","Maria","Catherine","Heather","Diane","Olivia","Julie","Joyce","Victoria","Ruth","Virginia","Lauren","Kelly","Christina","Joan","Evelyn","Judith","Andrea","Hannah","Megan","Cheryl","Jacqueline","Martha","Madison","Teresa","Gloria","Sara","Janice","Ann","Kathryn","Abigail","Sophia","Frances","Jean","Alice","Judy","Isabella","Julia","Grace","Amber","Denise","Danielle","Marilyn","Beverly","Charlotte","Natalie","Theresa","Diana","Brittany","Doris","Kayla","Alexis","Lori","Marie","James","Robert","John","Michael","David","William","Richard","Joseph","Thomas","Christopher","Charles","Daniel","Matthew","Anthony","Mark","Donald","Steven","Andrew","Paul","Joshua","Kenneth","Kevin","Brian","George","Timothy","Ronald","Jason","Edward","Jeffrey","Ryan","Jacob","Gary","Nicholas","Eric","Jonathan","Stephen","Larry","Justin","Scott","Brandon","Benjamin","Samuel","Gregory","Alexander","Patrick","Frank","Raymond","Jack","Dennis","Jerry","Tyler","Aaron","Jose","Adam","Nathan","Henry","Zachary","Douglas","Peter","Kyle","Noah","Ethan","Jeremy","Walter","Christian","Keith","Roger","Terry","Austin","Sean","Gerald","Carl","Harold","Dylan","Arthur","Lawrence","Jordan","Jesse","Bryan","Billy","Bruce","Gabriel","Joe","Logan","Alan","Juan","Albert","Willie","Elijah","Wayne","Randy","Vincent","Mason","Roy","Ralph","Bobby","Russell","Bradley","Philip","Eugene"]};},{}],73:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');/**
 * FableServiceDataGeneration class provides various methods for generating random data.
 * 
 * @extends libFableServiceBase
 */var FableServiceDataGeneration=/*#__PURE__*/function(_libFableServiceBase2){function FableServiceDataGeneration(pFable,pOptions,pServiceHash){var _this17;_classCallCheck2(this,FableServiceDataGeneration);_this17=_callSuper(this,FableServiceDataGeneration,[pFable,pOptions,pServiceHash]);_this17.serviceType='DataGeneration';_this17.defaultData=require('./Fable-Service-DataGeneration-DefaultValues.json');return _this17;}/**
     * Generates a random integer between the specified minimum and maximum values.
     * 
     * @param {number} pMinimum - The minimum value (inclusive).
     * @param {number} pMaximum - The maximum value (exclusive).
     * @returns {number} A random integer between pMinimum and pMaximum.
     */_inherits(FableServiceDataGeneration,_libFableServiceBase2);return _createClass2(FableServiceDataGeneration,[{key:"randomIntegerBetween",value:function randomIntegerBetween(pMinimum,pMaximum){try{var tmpMinimum=parseInt(pMinimum,10);var tmpMaximum=parseInt(pMaximum,10);return Math.floor(Math.random()*(tmpMaximum-tmpMinimum))+tmpMinimum;}catch(pError){this.fable.log.error('Error in randomIntegerBetween',pError,{'Minimum':pMinimum,'Maximum':pMaximum});return NaN;}}/**
     * Generates a random integer between 0 (inclusive) and the specified maximum value (exclusive).
     * 
     * @param {number} pMaximum - The maximum value (exclusive).
     * @returns {number} A random integer between 0 and pMaximum.
     */},{key:"randomIntegerUpTo",value:function randomIntegerUpTo(pMaximum){return this.randomIntegerBetween(0,pMaximum);}/**
     * Generates a random integer between 0 (inclusive) and the default maximum value.
     * 
     * @returns {number} A random integer between 0 and the default maximum value.
     */},{key:"randomInteger",value:function randomInteger(){return Math.floor(Math.random()*this.defaultData.DefaultIntegerMaximum);}/**
     * Generates a random float between the specified minimum and maximum values.
     * 
     * @param {number} pMinimum - The minimum value (inclusive).
     * @param {number} pMaximum - The maximum value (exclusive).
     * @returns {number} A random float between pMinimum and pMaximum.
     */},{key:"randomFloatBetween",value:function randomFloatBetween(pMinimum,pMaximum){try{var tmpMinimum=parseFloat(pMinimum);var tmpMaximum=parseFloat(pMaximum);return this.fable.Math.addPrecise(this.fable.Math.multiplyPrecise(Math.random(),this.fable.Math.subtractPrecise(tmpMaximum,tmpMinimum)),tmpMinimum);}catch(pError){this.fable.log.error('Error in randomFloatBetween',pError,{'Minimum':pMinimum,'Maximum':pMaximum});return NaN;}}/**
     * Generates a random float between 0 (inclusive) and the specified maximum value (exclusive).
     * 
     * @param {number} pMaximum - The maximum value (exclusive).
     * @returns {number} A random float between 0 and pMaximum.
     */},{key:"randomFloatUpTo",value:function randomFloatUpTo(pMaximum){return this.randomFloatBetween(0,pMaximum);}/**
     * Generates a random float between 0 (inclusive) and 1 (exclusive).
     * 
     * @returns {number} A random float between 0 and 1.
     */},{key:"randomFloat",value:function randomFloat(){return Math.random();}/**
     * Generates a random numeric string of the specified length.
     * 
     * @param {number} pLength - The length of the numeric string.
     * @param {number} pMaxNumber - The maximum number to generate.
     * @returns {string} A random numeric string of the specified length.
     */},{key:"randomNumericString",value:function randomNumericString(pLength,pMaxNumber){var tmpLength=typeof pLength==='undefined'?10:pLength;var tmpMaxNumber=typeof pMaxNumber==='undefined'?9999999999:pMaxNumber;return this.services.DataFormat.stringPadStart(this.randomIntegerUpTo(tmpMaxNumber),pLength,'0');}/**
     * Generates a random month from the default month set.
     * 
     * @returns {string} A random month.
     */},{key:"randomMonth",value:function randomMonth(){return this.defaultData.MonthSet[this.randomIntegerUpTo(this.defaultData.MonthSet.length-1)];}/**
     * Generates a random day of the week from the default week day set.
     * 
     * @returns {string} A random day of the week.
     */},{key:"randomDayOfWeek",value:function randomDayOfWeek(){return this.defaultData.WeekDaySet[this.randomIntegerUpTo(this.defaultData.WeekDaySet.length-1)];}/**
     * Generates a random color from the default color set.
     * 
     * @returns {string} A random color.
     */},{key:"randomColor",value:function randomColor(){return this.defaultData.ColorSet[this.randomIntegerUpTo(this.defaultData.ColorSet.length-1)];}/**
     * Generates a random name from the default name set.
     * 
     * @returns {string} A random name.
     */},{key:"randomName",value:function randomName(){return this.defaultData.NameSet[this.randomIntegerUpTo(this.defaultData.NameSet.length-1)];}/**
     * Generates a random surname from the default surname set.
     * 
     * @returns {string} A random surname.
     */},{key:"randomSurname",value:function randomSurname(){return this.defaultData.SurNameSet[this.randomIntegerUpTo(this.defaultData.SurNameSet.length-1)];}}]);}(libFableServiceBase);module.exports=FableServiceDataGeneration;},{"./Fable-Service-DataGeneration-DefaultValues.json":72,"fable-serviceproviderbase":59}],74:[function(require,module,exports){var libFableServiceProviderBase=require('fable-serviceproviderbase');/**
* Date management a la Moment using days.js
*
* @class DateManipulation
*/var DateManipulation=/*#__PURE__*/function(_libFableServiceProvi8){function DateManipulation(pFable,pOptions,pServiceHash){var _this18;_classCallCheck2(this,DateManipulation);_this18=_callSuper(this,DateManipulation,[pFable,pOptions,pServiceHash]);_this18.serviceType='Dates';_this18.dayJS=require('dayjs');// Include the `weekOfYear` plugin
_this18.plugin_weekOfYear=require('dayjs/plugin/weekOfYear');_this18.dayJS.extend(_this18.plugin_weekOfYear);// Include the `weekday` plugin
_this18.plugin_weekday=require('dayjs/plugin/weekday');_this18.dayJS.extend(_this18.plugin_weekday);// Include the `isoWeek` plugin
_this18.plugin_isoWeek=require('dayjs/plugin/isoWeek');_this18.dayJS.extend(_this18.plugin_isoWeek);// Include the `timezone` plugin
_this18.plugin_timezone=require('dayjs/plugin/timezone');_this18.dayJS.extend(_this18.plugin_timezone);// Include the `relativetime` plugin
_this18.plugin_relativetime=require('dayjs/plugin/relativeTime');_this18.dayJS.extend(_this18.plugin_relativetime);// Include the `utc` plugin
_this18.plugin_utc=require('dayjs/plugin/utc');_this18.dayJS.extend(_this18.plugin_utc);// Include the `advancedFormat` plugin
_this18.plugin_advancedFormat=require('dayjs/plugin/advancedFormat');_this18.dayJS.extend(_this18.plugin_advancedFormat);// A developer can include locales if they want
// You would do the following:
// const localeDE = require('dayjs/locale/de');
// _Fable.Dates.dayJS.locale('de');
return _this18;}_inherits(DateManipulation,_libFableServiceProvi8);return _createClass2(DateManipulation);}(libFableServiceProviderBase);module.exports=DateManipulation;},{"dayjs":32,"dayjs/plugin/advancedFormat":33,"dayjs/plugin/isoWeek":34,"dayjs/plugin/relativeTime":35,"dayjs/plugin/timezone":36,"dayjs/plugin/utc":37,"dayjs/plugin/weekOfYear":38,"dayjs/plugin/weekday":39,"fable-serviceproviderbase":59}],75:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var FableServiceEnvironmentData=/*#__PURE__*/function(_libFableServiceBase3){function FableServiceEnvironmentData(pFable,pOptions,pServiceHash){var _this19;_classCallCheck2(this,FableServiceEnvironmentData);_this19=_callSuper(this,FableServiceEnvironmentData,[pFable,pOptions,pServiceHash]);_this19.serviceType='EnvironmentData';_this19.Environment="node.js";return _this19;}_inherits(FableServiceEnvironmentData,_libFableServiceBase3);return _createClass2(FableServiceEnvironmentData);}(libFableServiceBase);module.exports=FableServiceEnvironmentData;},{"fable-serviceproviderbase":59}],76:[function(require,module,exports){var _require3=require('big.js'),PE=_require3.PE;var libFableServiceBase=require('fable-serviceproviderbase');/* Trying a different pattern for this service ...
 *
 * This service is a simple expression parser that can handle math expressions, with magic(tm) lookup of addresses with a manifest.
 * 
 * Each method works multiple ways.
 * 
 * 1. You can pass in a results object, and, it will put the state for that step outcome into the results object.
 * 2. It always returns the state, and works without the results object.
 * 
 * 
 * Learned a lot from this npm package: https://www.npmjs.com/package/math-expression-evaluator
 * And its related code at github: https://github.com/bugwheels94/math-expression-evaluator
 * 
 * There were two problems with the codebase above...
 * 
 * First, the code was very unreadable and determining it was correct or extending it
 * was out of the question.
 * 
 * Second, and this is a larger issue, is that we need the expressions to be parsed as
 * arbitrary precision.  When I determined that extending the library to use string-based
 * numbers and an arbitrary precision library as the back-end would have taken a significantly
 * longer amount of time than just writing the parser from scratch... et voila.
 */var FableServiceExpressionParser=/*#__PURE__*/function(_libFableServiceBase4){/**
	 * Constructs a new instance of the ExpressionParser service.
	 * @param {Object} pFable - The Fable object.
	 * @param {Object} pOptions - The options for the service.
	 * @param {string} pServiceHash - The hash of the service.
	 */function FableServiceExpressionParser(pFable,pOptions,pServiceHash){var _this20;_classCallCheck2(this,FableServiceExpressionParser);_this20=_callSuper(this,FableServiceExpressionParser,[pFable,pOptions,pServiceHash]);// The configuration for tokens that the solver recognizes, with precedence and friendly names.
_this20.tokenMap=require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json');// Keep track of maximum token precedence
_this20.tokenMaxPrecedence=4;// This isn't exactly a radix tree but close enough.  It's a map of the first character of the token to the token.
_this20.tokenRadix={};var tmpTokenKeys=Object.keys(_this20.tokenMap);for(var i=0;i<tmpTokenKeys.length;i++){var tmpTokenKey=tmpTokenKeys[i];var tmpToken=_this20.tokenMap[tmpTokenKey];tmpToken.Token=tmpTokenKey;tmpToken.Length=tmpTokenKey.length;var tmpTokenStartCharacter=tmpToken.Token[0];if(!(tmpTokenStartCharacter in _this20.tokenRadix)){// With a token count of 1 and a literal of true, we can assume it being in the radix is the token.
_this20.tokenRadix[tmpTokenStartCharacter]={TokenCount:0,Literal:false,TokenKeys:[],TokenMap:{}};}_this20.tokenRadix[tmpTokenStartCharacter].TokenCount++;if(tmpTokenKey==tmpTokenStartCharacter){_this20.tokenRadix[tmpTokenStartCharacter].Literal=true;}_this20.tokenRadix[tmpTokenStartCharacter].TokenMap[tmpToken.Token]=tmpToken;_this20.tokenRadix[tmpTokenStartCharacter].TokenKeys.push(tmpTokenKey);_this20.tokenRadix[tmpTokenStartCharacter].TokenKeys.sort(function(pLeft,pRight){return pRight.length-pLeft.length;});if(_this20.tokenMaxPrecedence<tmpToken.Precedence){_this20.tokenMaxPrecedence=tmpToken.Precedence;}}// The configuration for which functions are available to the solver.
_this20.functionMap=require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json');_this20.serviceType='ExpressionParser';// These are sub-services for the tokenizer, linter, compiler, marshaler and solver.
_this20.fable.addServiceTypeIfNotExists('ExpressionParser-Tokenizer',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js'));_this20.fable.addServiceTypeIfNotExists('ExpressionParser-Linter',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js'));_this20.fable.addServiceTypeIfNotExists('ExpressionParser-Postfix',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js'));_this20.fable.addServiceTypeIfNotExists('ExpressionParser-ValueMarshal',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js'));_this20.fable.addServiceTypeIfNotExists('ExpressionParser-Solver',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js'));// And the sub-service for the friendly user messaging
_this20.fable.addServiceTypeIfNotExists('ExpressionParser-Messaging',require('./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js'));// This code instantitates these fable services to child objects of this service, but does not pollute the main fable with them.
_this20.Tokenizer=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Tokenizer');_this20.Linter=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Linter');_this20.Postfix=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Postfix');_this20.ValueMarshal=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-ValueMarshal');_this20.Solver=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Solver');_this20.Messaging=_this20.fable.instantiateServiceProviderWithoutRegistration('ExpressionParser-Messaging');// Wire each sub service into this instance of the solver.
_this20.Tokenizer.connectExpressionParser(_this20);_this20.Linter.connectExpressionParser(_this20);_this20.Postfix.connectExpressionParser(_this20);_this20.ValueMarshal.connectExpressionParser(_this20);_this20.Solver.connectExpressionParser(_this20);_this20.Messaging.connectExpressionParser(_this20);_this20.GenericManifest=_this20.fable.newManyfest();// This will look for a LogNoisiness on fable (or one that falls in from pict) and if it doesn't exist, set one for this service.
_this20.LogNoisiness='LogNoisiness'in _this20.fable?_this20.fable.LogNoisiness:0;return _this20;}/**
	 * Tokenizes the given mathematical expression string.
	 *
	 * @param {string} pExpression - The expression to tokenize.
	 * @param {object} pResultObject - The result object to store the tokenized expression.
	 * @returns {object} - The tokenized expression.
	 */_inherits(FableServiceExpressionParser,_libFableServiceBase4);return _createClass2(FableServiceExpressionParser,[{key:"tokenize",value:function tokenize(pExpression,pResultObject){return this.Tokenizer.tokenize(pExpression,pResultObject);}/**
	 * Lints a tokenized expression.
	 *
	 * @param {Array} pTokenizedExpression - The tokenized expression to lint.
	 * @param {Object} pResultObject - The result object where we store the linting result.
	 * @returns {Object} - The linting result object.
	 */},{key:"lintTokenizedExpression",value:function lintTokenizedExpression(pTokenizedExpression,pResultObject){return this.Linter.lintTokenizedExpression(pTokenizedExpression,pResultObject);}/**
	 * Builds a postfix solve list for the given tokenized expression and result object.
	 *
	 * @param {Array} pTokenizedExpression - The tokenized expression.
	 * @param {Object} pResultObject - The result object where the algorithm "shows its work".
	 * @returns {Array} The postfix solve list.
	 */},{key:"buildPostfixedSolveList",value:function buildPostfixedSolveList(pTokenizedExpression,pResultObject){return this.Postfix.buildPostfixedSolveList(pTokenizedExpression,pResultObject);}/**
	 * Substitutes values in tokenized objects.
	 * 
	 * This means marshaling data from pDataSource into the array of objects with the passed in Manifest (or a generic manifest) to prepare for solving.
	 *
	 * @param {Array} pTokenizedObjects - The array of tokenized objects.
	 * @param {Object} pDataSource - The data source object.
	 * @param {Object} pResultObject - The result object.
	 * @param {Object} pManifest - The manifest object.
	 * @returns {Object} - The updated result object.
	 */},{key:"substituteValuesInTokenizedObjects",value:function substituteValuesInTokenizedObjects(pTokenizedObjects,pDataSource,pResultObject,pManifest){return this.ValueMarshal.substituteValuesInTokenizedObjects(pTokenizedObjects,pDataSource,pResultObject,pManifest);}/**
	 * Solves a postfixed expression Array.
	 *
	 * @param {Array} pPostfixedExpression - The postfixed expression to solve.
	 * @param {object} pDataDestinationObject - The data destination object where data gets marshaled to after solving.
	 * @param {object} pResultObject - The result object where the algorithm "shows its work".
	 * @param {object} pManifest - The manifest object.
	 * @returns {any} The result of the solved expression.
	 */},{key:"solvePostfixedExpression",value:function solvePostfixedExpression(pPostfixedExpression,pDataDestinationObject,pResultObject,pManifest){return this.Solver.solvePostfixedExpression(pPostfixedExpression,pDataDestinationObject,pResultObject,pManifest);}/**
	 * Solves the given expression using the provided data and manifest.
	 * 
	 * @param {string} pExpression - The expression to solve.
	 * @param {object} pDataSourceObject - (optional) The data source object (e.g. AppData).
	 * @param {object} pResultObject - (optional) The result object containing the full postfix expression list, internal variables and solver history.
	 * @param {object} pManifest - (optional) The manifest object for dereferencing variables.
	 * @param {object} pDataDestinationObject - (optional) The data destination object for where to marshal the result into.
	 * @returns {any} - The result of solving the expression.
	 */},{key:"solve",value:function solve(pExpression,pDataSourceObject,pResultObject,pManifest,pDataDestinationObject){var tmpResultsObject=_typeof(pResultObject)==='object'?pResultObject:{};var tmpDataSourceObject=_typeof(pDataSourceObject)==='object'?pDataSourceObject:{};var tmpDataDestinationObject=_typeof(pDataDestinationObject)==='object'?pDataDestinationObject:{};// This is technically a "pre-compile" and we can keep this Results Object around to reuse for better performance.  Not required.
this.tokenize(pExpression,tmpResultsObject);this.lintTokenizedExpression(tmpResultsObject.RawTokens,tmpResultsObject);this.buildPostfixedSolveList(tmpResultsObject.RawTokens,tmpResultsObject);// This is where the data from variables gets marshaled into their symbols (from AppData or the like)
this.substituteValuesInTokenizedObjects(tmpResultsObject.PostfixTokenObjects,tmpDataSourceObject,tmpResultsObject,pManifest);// Finally this is the expr solving method, which returns a string and also marshals it into tmpDataDestinationObject
return this.solvePostfixedExpression(tmpResultsObject.PostfixSolveList,tmpDataDestinationObject,tmpResultsObject,pManifest);}}]);}(libFableServiceBase);module.exports=FableServiceExpressionParser;},{"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ExpressionTokenizer.js":78,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-FunctionMap.json":79,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Linter.js":80,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Messaging.js":81,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-Postfix.js":82,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-SolvePostfixedExpression.js":83,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-TokenMap.json":84,"./Fable-Service-ExpressionParser/Fable-Service-ExpressionParser-ValueMarshal.js":85,"big.js":17,"fable-serviceproviderbase":59}],77:[function(require,module,exports){var libFableServiceProviderBase=require('fable-serviceproviderbase');var ExpressionParserOperationBase=/*#__PURE__*/function(_libFableServiceProvi9){function ExpressionParserOperationBase(pFable,pOptions,pServiceHash){var _this21;_classCallCheck2(this,ExpressionParserOperationBase);_this21=_callSuper(this,ExpressionParserOperationBase,[pFable,pOptions,pServiceHash]);_this21.serviceType='ExpressionParserOperationBase';_this21.numberTest=/^-{0,1}\d*\.{0,1}\d+$/;_this21.ExpressionParser=false;return _this21;}_inherits(ExpressionParserOperationBase,_libFableServiceProvi9);return _createClass2(ExpressionParserOperationBase,[{key:"connectExpressionParser",value:function connectExpressionParser(pExpressionParser){this.ExpressionParser=pExpressionParser;}},{key:"getTokenType",value:function getTokenType(pToken){if(pToken in this.ExpressionParser.tokenMap){return"Token.".concat(this.ExpressionParser.tokenMap[pToken].Type);}else if(pToken.length>2&&pToken[0]==='{'&&pToken[pToken.length-1]==='}'){return'Token.StateAddress';}else if(pToken.length>2&&pToken[0]==='"'&&pToken[pToken.length-1]==='"'){return'Token.String';}else if(this.numberTest.test(pToken)){return'Token.Constant';}else{return'Token.Symbol';}// Just for documentation sake:
// There is a fifth token type, VirtualSymbol
// This is a value that's added during solve and looked up by address in the VirtualSymbol object.
}},{key:"getTokenContainerObject",value:function getTokenContainerObject(pToken,pTokenType){return{Token:pToken,Type:typeof pTokenType==='undefined'?this.getTokenType(pToken):pTokenType,Descriptor:pToken in this.ExpressionParser.tokenMap?this.ExpressionParser.tokenMap[pToken]:false};}}]);}(libFableServiceProviderBase);module.exports=ExpressionParserOperationBase;},{"fable-serviceproviderbase":59}],78:[function(require,module,exports){var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');var ExpressionTokenizer=/*#__PURE__*/function(_libExpressionParserO){function ExpressionTokenizer(pFable,pOptions,pServiceHash){var _this22;_classCallCheck2(this,ExpressionTokenizer);_this22=_callSuper(this,ExpressionTokenizer,[pFable,pOptions,pServiceHash]);_this22.serviceType='ExpressionParser-Tokenizer';return _this22;}_inherits(ExpressionTokenizer,_libExpressionParserO);return _createClass2(ExpressionTokenizer,[{key:"tokenize",value:function tokenize(pExpression,pResultObject){var tmpResults=_typeof(pResultObject)==='object'?pResultObject:{ExpressionParserLog:[]};tmpResults.RawExpression=pExpression;tmpResults.RawTokens=[];tmpResults.ExpressionParserLog=[];if(typeof pExpression!=='string'){this.log.warn('ExpressionParser.tokenize was passed a non-string expression.');return tmpResults.RawTokens;}/* Tokenize the expression
		 *
		 * Current token types:
		 * 	- Value
		 *    : could be a symbol representation e.g. "x", "depth", "Cost", etc. --- symbol representations are looked up first as manifest hashes
		 *    : could be a number e.g. "5", "3.14159", etc.
		 *    : could be a function name e.g. sin(x), sqrt(3+5) where sin or sqrt are known function names
		 *  - StateAddress
		 *    : these are always wrapped in squiggly brackets
		 *    : e.g. {Moisture.Percentage}, {Ending.Temperature.Fahrenheit}, {AppData.Download.Size}, etc.
		 *  - Token
		 *    : could be an operator e.g. "+", "-", "*", "/"
		 *    : could be a parenthesis e.g. "(", ")"
		 */var tmpCurrentTokenType=false;var tmpCurrentToken='';for(var i=0;i<pExpression.length;i++){var tmpCharacter=pExpression[i];// [ WHITESPACE ]
// 1. Space breaks tokens except when we're in an address that's been scoped by a {}
if(tmpCharacter===' '&&tmpCurrentTokenType!=='StateAddress'){if(tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpCurrentToken);}tmpCurrentToken='';tmpCurrentTokenType=false;continue;}// [ STATE ADDRESS BLOCKS ]
// 2. If we're in an address, we keep going until we hit the closing brace
if(tmpCurrentTokenType==='StateAddress'&&tmpCharacter!=='}'){tmpCurrentToken+=tmpCharacter;continue;}// 3. If we're in an address and we hit the closing brace, we close the token, push it and reset
if(tmpCurrentTokenType==='StateAddress'&&tmpCharacter==='}'){tmpCurrentToken+=tmpCharacter;tmpResults.RawTokens.push(tmpCurrentToken);tmpCurrentToken='';tmpCurrentTokenType=false;continue;}// 4. If we're not in an address and we hit a closing brace it's a problem
//    TODO: Should we just ignore it?  We do at the moment.
if(tmpCharacter=='}'){if(tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpCurrentToken);}tmpCurrentToken='';tmpCurrentTokenType=false;tmpResults.ExpressionParserLog.push("ExpressionParser.tokenize found a closing brace without an opening brace in the expression: ".concat(pExpression," at character index ").concat(i));this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);continue;}// 5. If we're not in an address and we hit an opening brace, we start an address
if(tmpCharacter=='{'){if(tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpCurrentToken);}tmpCurrentToken='';tmpCurrentTokenType='StateAddress';tmpCurrentToken=tmpCharacter;continue;}// [ TOKENS ]
if(tmpCharacter in this.ExpressionParser.tokenRadix){var tmpTokenRadix=this.ExpressionParser.tokenRadix[tmpCharacter];// If the token is a literal and has only one entry, it is a single character token and we can just safely add it.
if(tmpTokenRadix.TokenCount==1&&tmpTokenRadix.Literal){if(tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpCurrentToken);}tmpCurrentToken='';tmpCurrentTokenType=false;tmpResults.RawTokens.push(tmpCharacter);continue;}else{// This one has multiple options, so literals don't matter.  We need to check the token map.
// The token radix TokenKeys array is sorted longest to shortest
for(var j=0;j<tmpTokenRadix.TokenKeys.length;j++){var tmpTokenKey=tmpTokenRadix.TokenKeys[j];if(pExpression.substr(i,tmpTokenKey.length)==tmpTokenKey){if(tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpTokenKey);}tmpCurrentToken='';tmpCurrentTokenType=false;tmpResults.RawTokens.push(tmpTokenKey);i+=tmpTokenKey.length-1;break;}}continue;}}// If it's not an operator, it's a number or address.
// At the moment we aren't going to gate it on whether it's a valid address or not
// Just treat anything not a known token on its own as a value identifier
/* Per this stack overflow article: https://stackoverflow.com/questions/4434076/best-way-to-alphanumeric-check-in-javascript
			 * We could use a regex but it is slower than the charCodeAt method.
			 * This also doesn't solve the problem of unicode characters, but we won't support those for now.
			 */// if (pExpression.charAt(i) == '.')
// {
// 	console.log('Found a period')
// }
// let tmpCharCode = pExpression.charCodeAt(i);
// // Match that the character code is any of...
// if (
// 	// Number [0-9]
// 	(tmpCharCode > 47 && tmpCharCode < 58)
// 	// Upper Case
// 	|| (tmpCharCode > 64 && tmpCharCode < 91)
// 	// LOWER CASE
// 	|| (tmpCharCode > 96 && tmpCharCode < 123)
// 	)
// {
// NOTE: Not having this guard makes a lot of interesting things possible.
tmpCurrentTokenType='Value';tmpCurrentToken+=tmpCharacter;// 	continue;
// }
// tmpResults.ExpressionParserLog.push(`ExpressionParser.tokenize found an unknown character code ${tmpCharCode} character ${tmpCharacter} in the expression: ${pExpression} at index ${i}`);
// this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);
}if(tmpCurrentTokenType&&tmpCurrentToken.length>0){tmpResults.RawTokens.push(tmpCurrentToken);}return tmpResults.RawTokens;}}]);}(libExpressionParserOperationBase);module.exports=ExpressionTokenizer;},{"./Fable-Service-ExpressionParser-Base.js":77}],79:[function(require,module,exports){module.exports={"sqrt":{"Name":"Square Root","Address":"fable.Math.sqrtPrecise"},"abs":{"Name":"Absolute Value","Address":"fable.Math.absPrecise"},"rad":{"Name":"Degrees to Radians","Address":"fable.Math.radPrecise"},"pi":{"Name":"Pi","Address":"fable.Math.piPrecise"},"sin":{"Name":"Sine","Address":"fable.Math.sin"},"cos":{"Name":"Cosine","Address":"fable.Math.cos"},"tan":{"Name":"Tangent","Address":"fable.Math.tan"},"count":{"Name":"Count Set Elements","Address":"fable.Math.countSetElements"},"sortset":{"Name":"Sort Set","Address":"fable.Math.sortSetPrecise"},"bucketset":{"Name":"Bucket Set","Address":"fable.Math.bucketSetPrecise"},"sorthistogram":{"Name":"Sort Histogram","Address":"fable.Math.sortHistogramPrecise"},"max":{"Name":"Maximum","Address":"fable.Math.maxPrecise"},"min":{"Name":"Minimum","Address":"fable.Math.minPrecise"},"sum":{"Name":"Sum","Address":"fable.Math.sumPrecise"},"avg":{"Name":"Average","Address":"fable.Math.averagePrecise"},"mean":{"Name":"Mean","Address":"fable.Math.meanPrecise"},"median":{"Name":"Median","Address":"fable.Math.medianPrecise"},"mode":{"Name":"Mode","Address":"fable.Math.modePrecise"},"round":{"Name":"Round","Address":"fable.Math.roundPrecise"},"countSetElements":{"Name":"Count Set Elements in a Histogram or Value Map","Address":"fable.Math.countSetElements"},"getvalue":{"Name":"Get Value from Application State or Services (AppData, etc.)","Address":"fable.Utility.getValue"},"randominteger":{"Name":"Random Integer","Address":"fable.DataGeneration.randomInteger"},"randomintegerbetween":{"Name":"Random Integer Between Two Numbers","Address":"fable.DataGeneration.randomIntegerBetween"},"randomintegerupto":{"Name":"Random Integer","Address":"fable.DataGeneration.randomIntegerUpTo"},"randomfloat":{"Name":"Random Float","Address":"fable.DataGeneration.randomFloat"},"randomfloatbetween":{"Name":"Random Float","Address":"fable.DataGeneration.randomFloatBetween"},"randomfloatupto":{"Name":"Random Float","Address":"fable.DataGeneration.randomFloatUpTo"}};},{}],80:[function(require,module,exports){var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');var ExpressionParserLinter=/*#__PURE__*/function(_libExpressionParserO2){function ExpressionParserLinter(pFable,pOptions,pServiceHash){var _this23;_classCallCheck2(this,ExpressionParserLinter);_this23=_callSuper(this,ExpressionParserLinter,[pFable,pOptions,pServiceHash]);_this23.serviceType='ExpressionParser-Linter';return _this23;}_inherits(ExpressionParserLinter,_libExpressionParserO2);return _createClass2(ExpressionParserLinter,[{key:"lintTokenizedExpression",value:function lintTokenizedExpression(pTokenizedExpression,pResultObject){var tmpResults=_typeof(pResultObject)==='object'?pResultObject:{ExpressionParserLog:[]};tmpResults.LinterResults=[];// Guard against bad data being passed in
if(!Array.isArray(pTokenizedExpression)){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression was passed a non-array tokenized expression.");tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return pTokenizedExpression;}if(pTokenizedExpression.length<1){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression was passed an empty tokenized expression.");tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return pTokenizedExpression;}// 1. Check for balanced parenthesis
var tmpParenthesisDepth=0;// If it is in a state address, we don't care about the parenthesis
// State addresses are between squiggly brackets
var tmpInStateAddress=false;for(var i=0;i<pTokenizedExpression.length;i++){if(pTokenizedExpression[i]==='('&&!tmpInStateAddress){tmpParenthesisDepth++;}if(pTokenizedExpression[i]===')'&&!tmpInStateAddress){tmpParenthesisDepth--;}if(pTokenizedExpression[i]==='{'){tmpInStateAddress=true;}if(pTokenizedExpression[i]==='}'){tmpInStateAddress=false;}if(tmpParenthesisDepth<0){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression at token index ".concat(i));tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}}if(tmpParenthesisDepth>0){// TODO: Should we add the closing parenthesis?
tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.lintTokenizedExpression found an unbalanced parenthesis in the tokenized expression (ended without closing last set of parenthesis) -- appropriate closing parenthesis will be added.");tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}// 2. Check for balanced squiggly braces
tmpInStateAddress=false;for(var _i4=0;_i4<pTokenizedExpression.length;_i4++){if(pTokenizedExpression[_i4]==='{'){tmpInStateAddress=true;}if(pTokenizedExpression[_i4]==='}'&&tmpInStateAddress){tmpInStateAddress=false;}if(pTokenizedExpression[_i4]==='}'&&!tmpInStateAddress){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression found an unbalanced closing squiggly brace \"}\" in the tokenized expression at token index ".concat(_i4));tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}if(tmpInStateAddress){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.lintTokenizedExpression found an open squiggly brace in the tokenized expression at index ".concat(_i4));tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}}// 3. Check for an equality assignment
var tmpEqualityAssignmentCount=0;var tmpEqualityAssignmentIndex=false;for(var _i5=0;_i5<pTokenizedExpression.length;_i5++){if(this.ExpressionParser.tokenMap[pTokenizedExpression[_i5]]&&this.ExpressionParser.tokenMap[pTokenizedExpression[_i5]].Type==='Assignment'){tmpEqualityAssignmentCount++;tmpEqualityAssignmentIndex=_i5;if(tmpEqualityAssignmentCount>1){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression found multiple equality assignments in the tokenized expression; equality assignment #".concat(tmpEqualityAssignmentCount," operator '").concat(pTokenizedExpression[_i5],"' at token index ").concat(_i5,"."));tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}}}if(tmpEqualityAssignmentCount<1){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.lintTokenizedExpression found no equality assignment in the tokenized expression.  One called Result will be added automatically.");tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}// 4. Make sure the equality assignment only has a single value on the other side of it
//    (no, this is not a magical algebraic solver, do your own simplification)
//    IF there is only one equality assignment (otherwise we don't even lint this because it's syntax errors all the way down)
if(tmpEqualityAssignmentCount===1){// If there are exactly three tokens, make sure at least one is an assignable-ish address
// This can still fail, but we aren't linting all the way into the manifest here; just the expression
if(pTokenizedExpression.length===3){if(// The first token in our expression is a potentially assignable symbol
this.getTokenType(pTokenizedExpression[0])==='Token.StateAddress'||this.getTokenType(pTokenizedExpression[2])==='Token.Symbol'// NOTE: For now we are only going to support assignment to the first symbol in the expression, which seems okay.
// OR the last token in our expression is a potentially assignable symbol
//|| (this.getTokenType(pTokenizedExpression[2]) === 'Token.StateAddress') || (this.getTokenType(pTokenizedExpression[0]) === 'Token.Symbol')
){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.lintTokenizedExpression found a single equality assignment in the tokenized expression with no assignable address on the left side of the assignment.");tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}}}// 5. Check that there are no operators adjacent to each other
//    This is a simple lint check, not a full-blown syntax check
var tmpTokenPrevious=false;for(var _i6=0;_i6<pTokenizedExpression.length-1;_i6++){if(pTokenizedExpression[_i6]in this.ExpressionParser.tokenMap&&this.ExpressionParser.tokenMap[pTokenizedExpression[_i6]].Type!='Parenthesis'&&!tmpTokenPrevious){tmpTokenPrevious=true;}else if(pTokenizedExpression[_i6]in this.ExpressionParser.tokenMap&&this.ExpressionParser.tokenMap[pTokenizedExpression[_i6]].Type!='Parenthesis'){// If this isn't a + or - positivity/negativity multiplier, it's an error.
if(pTokenizedExpression[_i6]!=='+'&&pTokenizedExpression[_i6]!=='-'){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.lintTokenizedExpression found an ".concat(pTokenizedExpression[_i6]," operator adjacent to another operator in the tokenized expression at token index ").concat(_i6));tmpResults.LinterResults.push(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}}else{tmpTokenPrevious=false;}}return tmpResults.LinterResults;}}]);}(libExpressionParserOperationBase);module.exports=ExpressionParserLinter;},{"./Fable-Service-ExpressionParser-Base.js":77}],81:[function(require,module,exports){var _require4=require('big.js'),PE=_require4.PE;var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');/**
 * Represents a user-friendly messaging service for the ExpressionParser compiler output.
 * @class ExpressionParserMessaging
 * @extends libExpressionParserOperationBase
 */var ExpressionParserMessaging=/*#__PURE__*/function(_libExpressionParserO3){function ExpressionParserMessaging(pFable,pOptions,pServiceHash){var _this24;_classCallCheck2(this,ExpressionParserMessaging);_this24=_callSuper(this,ExpressionParserMessaging,[pFable,pOptions,pServiceHash]);_this24.serviceType='ExpressionParser-Messaging';return _this24;}_inherits(ExpressionParserMessaging,_libExpressionParserO3);return _createClass2(ExpressionParserMessaging,[{key:"getOperationVirtualSymbolName",value:function getOperationVirtualSymbolName(pOperationToken){return pOperationToken&&'VirtualSymbolName'in pOperationToken?pOperationToken.VirtualSymbolName:pOperationToken.Type==='Token.VirtualSymbol'?pOperationToken.Token:'NO_VIRTUAL_SYMBOL_NAME_FOUND';}},{key:"getVirtualTokenValue",value:function getVirtualTokenValue(pToken,pOperationResults){var tmpVirtualSymbol=this.getOperationVirtualSymbolName(pToken);if(pToken.Type=='Token.Constant'&&pToken.Value){return pToken.Value.toString();}var tmpVirtualSymbolData='VirtualSymbols'in pOperationResults?pOperationResults.VirtualSymbols:{};if(this.ExpressionParser.GenericManifest.checkAddressExists(tmpVirtualSymbolData,tmpVirtualSymbol)){var tmpValue=this.ExpressionParser.GenericManifest.getValueAtAddress(tmpVirtualSymbolData,tmpVirtualSymbol);if(_typeof(tmpValue)==='object'){return"{".concat(Object.keys(tmpValue).length," values}");}if(Array.isArray(tmpValue)){return"[".concat(Object.keys(tmpValue).length," values]");}return tmpValue;}return'NO_VALUE_FOUND';}},{key:"getTokenAddressString",value:function getTokenAddressString(pToken){return pExpression.Token;}},{key:"getTokenSymbolString",value:function getTokenSymbolString(pExpressionToken){return pExpressionToken.Token;}},{key:"getOperationSymbolMessage",value:function getOperationSymbolMessage(pOperation){if(!pOperation){return'INVALID_OPERATION';}var tmpOperationVirtualSymbol=this.getOperationVirtualSymbolName(pOperation);var tmpOperationLeftValue=this.getTokenSymbolString(pOperation.LeftValue);var tmpOperationSymbol=this.getTokenSymbolString(pOperation.Operation);var tmpOperationRightValue=this.getTokenSymbolString(pOperation.RightValue);var tmpVirtualSymbolPrefix=tmpOperationVirtualSymbol.substring(0,3);if(tmpOperationSymbol==='='){// Assignment operators are special
return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationLeftValue);}if(tmpVirtualSymbolPrefix==='VFE'){// Virtual Function Expression
return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationSymbol,"(").concat(tmpOperationLeftValue,")");}return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationLeftValue," ").concat(tmpOperationSymbol," ").concat(tmpOperationRightValue);}},{key:"getOperationValueMessage",value:function getOperationValueMessage(pOperation,pResultObject){if(!pOperation){return'INVALID_OPERATION';}var tmpOperationVirtualSymbol=this.getOperationVirtualSymbolName(pOperation);var tmpOperationLeftValue=this.getVirtualTokenValue(pOperation.LeftValue,pResultObject);var tmpOperationSymbol=this.getTokenSymbolString(pOperation.Operation);var tmpOperationRightValue=this.getVirtualTokenValue(pOperation.RightValue,pResultObject);var tmpVirtualSymbolPrefix=tmpOperationVirtualSymbol.substring(0,3);if(tmpOperationSymbol==='='){// Assignment operators are special
return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationLeftValue);}if(tmpVirtualSymbolPrefix==='VFE'){// Virtual Function Expression
return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationSymbol,"(").concat(tmpOperationLeftValue,")");}return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationLeftValue," ").concat(tmpOperationSymbol," ").concat(tmpOperationRightValue);}},{key:"getOperationOutcomeMessage",value:function getOperationOutcomeMessage(pToken,pOperationResults){if(!pToken){return'INVALID_TOKEN';}var tmpOperationVirtualSymbol=this.getOperationVirtualSymbolName(pToken);var tmpOperationOutcomeValue=this.getVirtualTokenValue(pToken,pOperationResults);return"".concat(tmpOperationVirtualSymbol," = ").concat(tmpOperationOutcomeValue);}},{key:"logFunctionOutcome",value:function logFunctionOutcome(pResultObject){if(_typeof(pResultObject)!=='object'){this.log.error("Solver results object was not an object.  Cannot log outcome.");return;}var tmpAssignmentAddress='PostfixedAssignmentAddress'in pResultObject?pResultObject.PostfixedAssignmentAddress:'NO_ASSIGNMENT_ADDRESS_FOUND';var tmpRawExpression='RawExpression'in pResultObject?pResultObject.RawExpression:'NO_EXPRESSION_FOUND';var tmpRawResult='RawResult'in pResultObject?pResultObject.RawResult:'NO_RESULT_FOUND';this.log.info("Solved f(".concat(tmpAssignmentAddress,") = {").concat(tmpRawExpression,"}"));for(var i=0;i<pResultObject.PostfixSolveList.length;i++){var tmpToken=pResultObject.PostfixSolveList[i];var tmpTokenSymbolMessage=this.getOperationSymbolMessage(tmpToken);this.log.info("".concat(i," Symbols: ").concat(tmpTokenSymbolMessage));var tmpTokenValueMessage=this.getOperationValueMessage(tmpToken,pResultObject);this.log.info("".concat(i,"  Values: ").concat(tmpTokenValueMessage));var tmpTokenOutcome=this.getOperationOutcomeMessage(tmpToken,pResultObject);this.log.info("".concat(i," Outcome: ").concat(tmpTokenOutcome));}this.log.info("{".concat(tmpRawExpression,"} = ").concat(tmpRawResult));}},{key:"logFunctionSolve",value:function logFunctionSolve(pResultObject){if(_typeof(pResultObject)!=='object'){this.log.error("Solver results object was not an object.  Cannot log the solve.");return;}if(!('PostfixSolveList'in pResultObject)||!Array.isArray(pResultObject.PostfixSolveList)){this.log.error("Solver results object did not contain a PostfixSolveList array.  Cannot log the solve.");return;}for(var i=0;i<tmpExpressionParseOutcome.PostfixSolveList.length;i++){var tmpToken=tmpExpressionParseOutcome.PostfixSolveList[i];console.log("".concat(i,": ").concat(tmpToken.VirtualSymbolName," = (").concat(tmpToken.LeftValue.Token,"::").concat(tmpToken.LeftValue.Value,")  ").concat(tmpToken.Operation.Token,"  (").concat(tmpToken.RightValue.Token,"::").concat(tmpToken.RightValue.Value,") "));}this.logFunctionOutcome(pResultObject);}}]);}(libExpressionParserOperationBase);module.exports=ExpressionParserMessaging;},{"./Fable-Service-ExpressionParser-Base.js":77,"big.js":17}],82:[function(require,module,exports){var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');var ExpressionParserPostfix=/*#__PURE__*/function(_libExpressionParserO4){function ExpressionParserPostfix(pFable,pOptions,pServiceHash){var _this25;_classCallCheck2(this,ExpressionParserPostfix);_this25=_callSuper(this,ExpressionParserPostfix,[pFable,pOptions,pServiceHash]);_this25.serviceType='ExpressionParser-Postfix';return _this25;}_inherits(ExpressionParserPostfix,_libExpressionParserO4);return _createClass2(ExpressionParserPostfix,[{key:"getPosfixSolveListOperation",value:function getPosfixSolveListOperation(pOperation,pLeftValue,pRightValue,pDepthSolveList,pDepthSolveIndex){var tmpOperation={VirtualSymbolName:pOperation.VirtualSymbolName,Operation:pOperation,LeftValue:pLeftValue,RightValue:pRightValue};var tmpDepthSolveList=Array.isArray(pDepthSolveList)?pDepthSolveList:false;/* These two if blocks are very complex -- they basically provide a
		 * way to deal with recursion that can be expressed to the user in
		 * a meaningful way.
		 * 
		 * The reason we are doing it as such is to show exactly how the
		 * solver resolves the passed-in tokens into a solvable expression.
		 */if(!tmpOperation.LeftValue.VirtualSymbolName){tmpOperation.LeftValue.VirtualSymbolName=tmpOperation.VirtualSymbolName;}else{// We need to set the left value to a virtual symbol instead of the looked up value if it's already used in another operation
if('LeftVirtualSymbolName'in tmpOperation.Operation){tmpOperation.LeftValue=this.getTokenContainerObject(tmpOperation.Operation.LeftVirtualSymbolName,'Token.VirtualSymbol');}else{tmpOperation.LeftValue=this.getTokenContainerObject(tmpOperation.LeftValue.VirtualSymbolName,'Token.VirtualSymbol');}}if(!tmpOperation.RightValue.VirtualSymbolName){tmpOperation.RightValue.VirtualSymbolName=tmpOperation.VirtualSymbolName;}else{// We need to set the right value to a virtual symbol instead of the looked up value if it's already used in another operation
//if ('LeftVirtualSymbolName' in tmpOperation.RightValue)
if('RightVirtualSymbolName'in tmpOperation.Operation){tmpOperation.RightValue=this.getTokenContainerObject(tmpOperation.Operation.RightVirtualSymbolName,'Token.VirtualSymbol');}else{tmpOperation.RightValue=this.getTokenContainerObject(tmpOperation.RightValue.VirtualSymbolName,'Token.VirtualSymbol');}}tmpOperation.Operation.Parsed=true;return tmpOperation;}},{key:"buildPostfixedSolveList",value:function buildPostfixedSolveList(pTokenizedExpression,pResultObject){var tmpResults=_typeof(pResultObject)==='object'?pResultObject:{ExpressionParserLog:[]};tmpResults.PostfixedAssignmentAddress='Result';tmpResults.PostfixedAssignmentOperator=this.ExpressionParser.tokenMap['='];// This is the default assignment operator
tmpResults.PostfixTokenObjects=[];tmpResults.PostfixSolveList=[];if(pTokenizedExpression.length<3){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList was passed a tokenized expression with less than three tokens.");this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixTokenObjects;}// 1. Figure out the Equality Assignment
var tmpEqualsIndex=-1;for(var i=0;i<pTokenizedExpression.length;i++){if(this.ExpressionParser.tokenMap[pTokenizedExpression[i]]&&this.ExpressionParser.tokenMap[pTokenizedExpression[i]].Type==='Assignment'){if(tmpEqualsIndex<0){tmpEqualsIndex=i;tmpResults.PostfixedAssignmentOperator=this.ExpressionParser.tokenMap[pTokenizedExpression[i]];}else{tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found multiple assignment operators in the tokenized expression; assignment operator '".concat(pTokenizedExpression[i],"' #").concat(tmpEqualsIndex," at token index ").concat(i,"."));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixTokenObjects;}}}if(tmpEqualsIndex==-1){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.buildPostfixedSolveList found no equality assignment in the tokenized expression; defaulting to Result");this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}else if(tmpEqualsIndex>1){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.buildPostfixedSolveList found an equality assignment in the tokenized expression at an unexpected location (token index ".concat(tmpEqualsIndex,"); the expression cannot be parsed."));this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}else if(tmpEqualsIndex===0){// This is an implicit function -- just go to result and return the value.
// That is... the user entered something like "= 5 + 3" so we should just return 8, and use the default Result quietly.
}else{tmpResults.PostfixedAssignmentAddress=pTokenizedExpression[0];}// 2. Categorize tokens in the expression, put them in the "expression list" as a token object
for(var _i7=tmpEqualsIndex+1;_i7<pTokenizedExpression.length;_i7++){tmpResults.PostfixTokenObjects.push(this.getTokenContainerObject(pTokenizedExpression[_i7]));}// 3. Decorate mathematical parsing depth and detect functions at the same time
//    Having written this a few times now, it's easier to detect functions *while* parsing depth.
//    Especially if we want our system to be able to communicate with the user when there is an issue.
var tmpDepth=0;// The virtual symbol index is used for the abstract interim values that are generated at each step of the solve
var tmpVirtualParenthesisIndex=0;var tmpSolveLayerStack=[];// Kick off the solve layer stack with the first solve set identifier
tmpSolveLayerStack.push("SolveSet_".concat(tmpVirtualParenthesisIndex,"_D_").concat(tmpDepth));for(var _i8=0;_i8<tmpResults.PostfixTokenObjects.length;_i8++){// 1. If it's an open parenthesis, set the parenthesis at the current depth and increment the depth
if(tmpResults.PostfixTokenObjects[_i8].Token==='('){// Set the depth of the open parenthesis to the current solution depth
tmpResults.PostfixTokenObjects[_i8].Depth=tmpDepth;// Generate the virtual symbol name for user output
tmpResults.PostfixTokenObjects[_i8].VirtualSymbolName="Pr_".concat(tmpVirtualParenthesisIndex,"_D_").concat(tmpDepth);// 1a. Detect if this parenthesis is signaling a function
//     If the previous token is a Symbol (e.g. it say sin(x) or sqrt(3+5) or something) then the parser will interpret it as a function
if(_i8>0){if(tmpResults.PostfixTokenObjects[_i8-1].Type==='Token.Symbol'){// Set the type of this to be a function
tmpResults.PostfixTokenObjects[_i8-1].Type='Token.Function';}}// Parenthesis manage the solve layer stack
// For adding a new parenthesis solve layer, we put the parenthesis in the stack we are in and then make all the contained tokens be within the stack of the parenthesis
tmpResults.PostfixTokenObjects[_i8].SolveLayerStack=tmpSolveLayerStack[tmpSolveLayerStack.length-1];tmpSolveLayerStack.push(tmpResults.PostfixTokenObjects[_i8].VirtualSymbolName);tmpVirtualParenthesisIndex++;tmpDepth++;}// 2. If it's a closed parenthesis, decrease the depth
else if(tmpResults.PostfixTokenObjects[_i8].Token===')'){tmpDepth--;tmpResults.PostfixTokenObjects[_i8].Depth=tmpDepth;// Check to see that the depth of the closed parenthesis is greater than 0
if(tmpDepth<0){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found a closing parenthesis at token index ".concat(_i8," with no corresponding opening parenthesis."));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);}// Parenthesis manage the solve layer stack
// For closing parenthesis solve layer with a close paren, we put it in the same stack as the opening parenthesis.
// Give the closing parenthesis the same virtual symbol name as the opening parenthesis
// (do the both above at the same time)
tmpResults.PostfixTokenObjects[_i8].VirtualSymbolName=tmpSolveLayerStack.pop();tmpResults.PostfixTokenObjects[_i8].SolveLayerStack=tmpSolveLayerStack[tmpSolveLayerStack.length-1];}else{tmpResults.PostfixTokenObjects[_i8].Depth=tmpDepth;tmpResults.PostfixTokenObjects[_i8].SolveLayerStack=tmpSolveLayerStack[tmpSolveLayerStack.length-1];}}// 4. Walk through the decorated symbols and generate the postfix solve list
//    We are going to start by creating a map of the solve layers:
var tmpSolveLayerMap={};var tmpSolveLayerMaxDepth=0;for(var _i9=0;_i9<tmpResults.PostfixTokenObjects.length;_i9++){if(!(tmpResults.PostfixTokenObjects[_i9].SolveLayerStack in tmpSolveLayerMap)){tmpSolveLayerMap[tmpResults.PostfixTokenObjects[_i9].SolveLayerStack]=[];}tmpSolveLayerMap[tmpResults.PostfixTokenObjects[_i9].SolveLayerStack].push(tmpResults.PostfixTokenObjects[_i9]);// See what our max depth is.  This is super important to the postfix operation
// The programmer in me thinks it would be funny to not track this and just use the map key length as the max size, which would work (logically impossible to have a depth > key length) but it would be quite a bit more confusing to grok the algorithm.
if(tmpResults.PostfixTokenObjects[_i9].Depth>tmpSolveLayerMaxDepth){tmpSolveLayerMaxDepth=tmpResults.PostfixTokenObjects[_i9].Depth;}}var tmpSolveLayerKeys=Object.keys(tmpSolveLayerMap);// Reset the virtual symbol index -- it was used above for uniquenes when creating abstract symbols for parenthesis and layer stacks.
var tmpVirtualSymbolIndex=0;tmpSolveLayerKeys.sort(// Sort the solve layers by depth.
function(pLeftLayer,pRightLayer){// It is impossible to have a layer with no entries in it.  
// If that ever happens, the bug is actually above and we actively want this to blow up.
if(tmpSolveLayerMap[pLeftLayer][0].Depth<tmpSolveLayerMap[pRightLayer][0].Depth){return 1;}if(tmpSolveLayerMap[pLeftLayer][0].Depth>tmpSolveLayerMap[pRightLayer][0].Depth){return-1;}return 0;});// 5. Generate the postfix solve list
//    The most important thing is going backwards in the depth order (a la reverse polish).
//    Specifically not using shunting yard to provide in-depth "show your work" notes
//    Yes it is possible to do a somewhat similar thing with shunting yard but the code is almost unreadable
// 5.1 Build the Virtual Symbol Names
// This maps layer stack addresses (which match parenthesis virtual symbol names) to the resultant value for that layer stack.
// These values change as it solves but the last assignment is the proper assignment because math only reads forward in a line
tmpResults.PostfixLayerstackMap={};for(var tmpSolveLayerIndex=0;tmpSolveLayerIndex<tmpSolveLayerKeys.length;tmpSolveLayerIndex++){var tmpSolveLayerTokens=tmpSolveLayerMap[tmpSolveLayerKeys[tmpSolveLayerIndex]];// For each precedence (this isn't strictly required here but makes the outcome for the user more readable)
for(var tmpPrecedence=0;tmpPrecedence<=this.ExpressionParser.tokenMaxPrecedence;tmpPrecedence++){// Enumerate all tokens in a layer's expression.
// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.
for(var _i10=0;_i10<tmpSolveLayerTokens.length;_i10++){// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.
if(tmpSolveLayerTokens[_i10].Type==='Token.Operator'&&tmpSolveLayerTokens[_i10].Descriptor.Precedence===tmpPrecedence){var tmpToken=tmpSolveLayerTokens[_i10];// If there is a token and nothing else in this layer, then it's an error.
if(tmpSolveLayerTokens.length===1){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found a single operator in a solve layer expression at token index ".concat(_i10));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixSolveList;}// If the token is at the beginning of the expression and not a number line orientation modifier, it's an error.
else if(_i10==0&&(tmpToken.Token!='+'||tmpToken.Token!='-')){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the beginning of a solve layer expression at token index ".concat(_i10));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixSolveList;}// If the token is at the end of the expression, it is an error.
else if(_i10==tmpSolveLayerTokens.length-1){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found an operator at the end of a solve layer expression at token index ".concat(_i10));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixSolveList;}// The - at the beginning of an expression is a number line orientation modifier
else if(_i10==0&&tmpToken.Token=='-'){tmpToken.VirtualSymbolName="VNLO_".concat(tmpVirtualSymbolIndex);tmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack]=tmpToken.VirtualSymbolName;tmpVirtualSymbolIndex++;}// The - after an operator or an open parenthesis is also a number line orientation modifier
else if(_i10>0&&tmpToken.Token=='-'&&(tmpSolveLayerTokens[_i10-1].Type==='Token.Operator'||tmpSolveLayerTokens[_i10-1].Token==='(')){// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token
tmpToken.VirtualSymbolName="VNLO_".concat(tmpVirtualSymbolIndex);tmpVirtualSymbolIndex++;}// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE
else if(_i10==0&&tmpToken.Token=='+'){continue;}// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE
else if(_i10>0&&tmpToken.Token=='+'&&(tmpSolveLayerTokens[_i10-1].Type==='Token.Operator'||tmpSolveLayerTokens[_i10-1].Token==='(')){continue;}// If the token is next to another operator it's a parsing error
else if(tmpSolveLayerTokens[_i10-1].Type==='Token.Operator'||tmpSolveLayerTokens[_i10+1].Type==='Token.Operator'){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.buildPostfixedSolveList found an operator at token index ".concat(_i10," that is not surrounded by two values."));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return tmpResults.PostfixSolveList;}// Finally add a virtual symbol name to the dang thing.
else{tmpToken.VirtualSymbolName="V_".concat(tmpVirtualSymbolIndex);tmpResults.PostfixLayerstackMap[tmpToken.SolveLayerStack]=tmpToken.VirtualSymbolName;tmpVirtualSymbolIndex++;}}else if(tmpSolveLayerTokens[_i10].Type==='Token.Function'&&tmpPrecedence===0){var _tmpToken=tmpSolveLayerTokens[_i10];_tmpToken.VirtualSymbolName="VFE_".concat(tmpVirtualSymbolIndex);tmpVirtualSymbolIndex++;tmpResults.PostfixLayerstackMap[_tmpToken.SolveLayerStack]=_tmpToken.VirtualSymbolName;}}}}// 5.15 Generate Virtual Symbol Clusters for Functions and Parenthesis
//      ... this gets funny because of precedence of operations surrounding them, parenthesis and functions.
var tmpFunctionCacheLIFOStack=[];for(var _i11=0;_i11<tmpResults.PostfixTokenObjects.length;_i11++){var tmpPostfixTokenObject=tmpResults.PostfixTokenObjects[_i11];if(tmpPostfixTokenObject.Type==='Token.Parenthesis'){// This is just to track the parenthesis stack level for User feedback
tmpPostfixTokenObject.ParenthesisStack=tmpPostfixTokenObject.VirtualSymbolName;// At the beginning of the  expression, this must be an open parenthesis to be legal.
if(_i11==0){tmpPostfixTokenObject.IsFunction=false;var tmpVirtualSymbolName=tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];if(!tmpVirtualSymbolName){// ... this parenthesis group has no operators in it; make a virtual symbol name.
tmpVirtualSymbolName="VP_".concat(tmpVirtualSymbolIndex);tmpVirtualSymbolIndex++;}tmpPostfixTokenObject.VirtualSymbolName=tmpVirtualSymbolName;tmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);}// If it's an open parenthesis
else if(tmpPostfixTokenObject.Token==='('){// ... supporting a function
if(tmpResults.PostfixTokenObjects[_i11-1].Type==='Token.Function'){tmpPostfixTokenObject.IsFunction=true;tmpPostfixTokenObject.Function=tmpResults.PostfixTokenObjects[_i11-1];var _tmpVirtualSymbolName=tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];if(!_tmpVirtualSymbolName){// ... this parenthesis group has no operators in it; make a virtual symbol name.
_tmpVirtualSymbolName="VFP_".concat(tmpVirtualSymbolIndex);tmpVirtualSymbolIndex++;}tmpPostfixTokenObject.VirtualSymbolName=_tmpVirtualSymbolName;}else{tmpPostfixTokenObject.IsFunction=false;var _tmpVirtualSymbolName2=tmpResults.PostfixLayerstackMap[tmpPostfixTokenObject.VirtualSymbolName];if(!_tmpVirtualSymbolName2){// This is a parenthesis group with no operators in it; make a virtual symbol name.
_tmpVirtualSymbolName2="VP_".concat(tmpVirtualSymbolIndex);tmpVirtualSymbolIndex++;}tmpPostfixTokenObject.VirtualSymbolName=_tmpVirtualSymbolName2;}tmpFunctionCacheLIFOStack.push(tmpPostfixTokenObject);}else if(tmpPostfixTokenObject.Token===')'){var tmpOpenParenthesis=tmpFunctionCacheLIFOStack.pop();if(tmpOpenParenthesis.IsFunction){tmpPostfixTokenObject.IsFunction=true;tmpPostfixTokenObject.VirtualSymbolName=tmpOpenParenthesis.Function.VirtualSymbolName;}else{tmpPostfixTokenObject.IsFunction=false;tmpPostfixTokenObject.VirtualSymbolName=tmpOpenParenthesis.VirtualSymbolName;}}}}// X. Postprocess the parenthesis groups to ensure they respect the order of operations for their boundaries
for(var _tmpSolveLayerIndex=0;_tmpSolveLayerIndex<tmpSolveLayerKeys.length;_tmpSolveLayerIndex++){var tmpParenthesisStack=[];var tmpLastOperator=false;var _tmpSolveLayerTokens=tmpSolveLayerMap[tmpSolveLayerKeys[_tmpSolveLayerIndex]];for(var _i12=0;_i12<_tmpSolveLayerTokens.length;_i12++){var _tmpPostfixTokenObject=_tmpSolveLayerTokens[_i12];// Keep track of the last operator
if(_tmpPostfixTokenObject.Type==='Token.Operator'){tmpLastOperator=_tmpPostfixTokenObject;}// This is only important to do at the close parenthesis.
if(_tmpPostfixTokenObject.Type==='Token.Function'){_tmpPostfixTokenObject.PreviousOperator=tmpLastOperator;}else if(_tmpPostfixTokenObject.Type==='Token.Parenthesis'&&_tmpPostfixTokenObject.Token==='('&&_tmpPostfixTokenObject.IsFunction){tmpParenthesisStack.push(_tmpPostfixTokenObject);if(_tmpPostfixTokenObject.Function.PreviousOperator){_tmpPostfixTokenObject.PreviousOperator=_tmpPostfixTokenObject.Function.PreviousOperator;}}else if(_tmpPostfixTokenObject.Type==='Token.Parenthesis'&&_tmpPostfixTokenObject.Token==='('){_tmpPostfixTokenObject.PreviousOperator=tmpLastOperator;tmpParenthesisStack.push(_tmpPostfixTokenObject);}else if(_tmpPostfixTokenObject.Type==='Token.Parenthesis'&&_tmpPostfixTokenObject.Token===')'){// This is ultra complex, and binds the order of operations logic to the open parenthesis for the group
var _tmpOpenParenthesis=tmpParenthesisStack.pop();if(_i12<_tmpSolveLayerTokens.length-1){for(var j=_i12+1;j<_tmpSolveLayerTokens.length;j++){if(_tmpSolveLayerTokens[j].Type==='Token.Operator'){_tmpOpenParenthesis.NextOperator=_tmpSolveLayerTokens[j];break;}}}if(_tmpOpenParenthesis.PreviousOperator&&_tmpOpenParenthesis.NextOperator){if(_tmpOpenParenthesis.PreviousOperator.Descriptor.Precedence<=_tmpOpenParenthesis.NextOperator.Descriptor.Precedence){_tmpOpenParenthesis.NextOperator.LeftVirtualSymbolName=_tmpOpenParenthesis.PreviousOperator.VirtualSymbolName;}else{_tmpOpenParenthesis.PreviousOperator.RightVirtualSymbolName=_tmpOpenParenthesis.NextOperator.VirtualSymbolName;}}}else{if(!('SolveLayerStack'in _tmpPostfixTokenObject)){// Decorate the solve layer stack for the token
if(tmpParenthesisStack.length>0){_tmpPostfixTokenObject.SolveLayerStack=tmpParenthesisStack[tmpParenthesisStack.length-1].SolveLayerStack;}else{_tmpPostfixTokenObject.SolveLayerStack='Expression_Root';}}}}}// 5.2.9: Make sure the affinity of operators is respecting order of operations.
//        Walk backwards and forwards, hoisting same value precedence backwards/forwards
//        across each layer... the precedence change needs to be decreasing to matter
for(var _tmpSolveLayerIndex2=0;_tmpSolveLayerIndex2<tmpSolveLayerKeys.length;_tmpSolveLayerIndex2++){var tmpLastPrecedence=false;var tmpFinalChainToken=false;var _tmpSolveLayerTokens2=tmpSolveLayerMap[tmpSolveLayerKeys[_tmpSolveLayerIndex2]];for(var _i13=_tmpSolveLayerTokens2.length-1;_i13>=0;_i13--){var _tmpToken2=_tmpSolveLayerTokens2[_i13];if(_tmpToken2.Type==='Token.Operator'){if(!tmpFinalChainToken){tmpFinalChainToken=_tmpToken2;}else if(_tmpToken2.Descriptor.Precedence>tmpLastPrecedence){// This is less imporant than the last precedence, so hoist back the virtual value
_tmpToken2.RightVirtualSymbolName=tmpFinalChainToken.VirtualSymbolName;//console.log(`Hoisting ${tmpToken.Token} back to ${tmpFinalChainToken.Token}`);
tmpFinalChainToken=_tmpToken2;}else if(_tmpToken2.Descriptor.Precedence<tmpLastPrecedence){tmpFinalChainToken=_tmpToken2;}tmpLastPrecedence=_tmpToken2.Descriptor.Precedence;}}var tmpDecreasingPrecedenceStack=[];var tmpLastToken=false;for(var _i14=_tmpSolveLayerTokens2.length-1;_i14>=0;_i14--){var _tmpToken3=_tmpSolveLayerTokens2[_i14];if(_tmpToken3.Type==='Token.Operator'){if(!tmpLastToken){tmpLastToken=_tmpToken3;}else if(_tmpToken3.Descriptor.Precedence>tmpLastPrecedence){// Check and see if this needs to be resolved in the stack
if(tmpDecreasingPrecedenceStack.length>0){for(var _j=tmpDecreasingPrecedenceStack.length-1;_j>=0;_j--){if(tmpDecreasingPrecedenceStack[_j].Descriptor.Precedence>=_tmpToken3.Descriptor.Precedence){//console.log(`Hoisting ${tmpDecreasingPrecedenceStack[j].Token} up to ${tmpToken.Token}`);
tmpDecreasingPrecedenceStack[_j].LeftVirtualSymbolName=_tmpToken3.VirtualSymbolName;tmpDecreasingPrecedenceStack.slice(_j,1);break;}}}tmpLastToken=_tmpToken3;}else if(_tmpToken3.Descriptor.Precedence<tmpLastPrecedence){tmpDecreasingPrecedenceStack.push(tmpLastToken);tmpLastToken=_tmpToken3;}tmpLastPrecedence=_tmpToken3.Descriptor.Precedence;}}}// 5.3: Generate the Postfix Solve List
for(var _tmpSolveLayerIndex3=0;_tmpSolveLayerIndex3<tmpSolveLayerKeys.length;_tmpSolveLayerIndex3++){var _tmpSolveLayerTokens3=tmpSolveLayerMap[tmpSolveLayerKeys[_tmpSolveLayerIndex3]];// If this is a layer with one value, presume it's an assignment.
if(_tmpSolveLayerTokens3.length===1){// TODO: I think this is correct but with the addition of multiple assignment operators it's less clear.
var _tmpAbstractAssignToken=this.getTokenContainerObject('=');_tmpAbstractAssignToken.VirtualSymbolName=tmpResults.PostfixLayerstackMap[_tmpSolveLayerTokens3[0].SolveLayerStack];// If this doesn't have a matching solvelayerstack, get the virtual symbol name from the parenthesis group it's in
if(!_tmpAbstractAssignToken.VirtualSymbolName){for(var _i15=0;_i15<tmpResults.PostfixTokenObjects.length;_i15++){if(tmpResults.PostfixTokenObjects[_i15].ParenthesisStack===_tmpSolveLayerTokens3[0].SolveLayerStack){_tmpAbstractAssignToken.VirtualSymbolName=tmpResults.PostfixTokenObjects[_i15].VirtualSymbolName;break;}}}tmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(_tmpAbstractAssignToken,_tmpSolveLayerTokens3[0],this.getTokenContainerObject('0.0')));continue;}// For each precedence level in the layer
for(var _tmpPrecedence=0;_tmpPrecedence<=this.ExpressionParser.tokenMaxPrecedence;_tmpPrecedence++){// Enumerate all tokens in a layer's expression.
// There is a recursive way to do this, but given the short length of even the most complex equations we're favoring readability.
for(var _i16=0;_i16<_tmpSolveLayerTokens3.length;_i16++){// If the token is an operator and at the current precedence, add it to the postfix solve list and mutate the array.
if(_tmpSolveLayerTokens3[_i16].Type==='Token.Operator'&&_tmpSolveLayerTokens3[_i16].Descriptor.Precedence===_tmpPrecedence){var _tmpToken4=_tmpSolveLayerTokens3[_i16];// The - at the beginning of an expression is a number line orientation modifier
if(_i16==0&&_tmpToken4.Token=='-'){// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token
// This is an abstract operation that isn't in the expression.
var tmpAbstractMultiplyToken=this.getTokenContainerObject('*');tmpAbstractMultiplyToken.VirtualSymbolName=_tmpToken4.VirtualSymbolName;tmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(tmpAbstractMultiplyToken,this.getTokenContainerObject('-1.0'),_tmpSolveLayerTokens3[_i16+1]));}// The - after an operator or an open parenthesis is also a number line orientation modifier
else if(_i16>0&&_tmpToken4.Token=='-'&&(_tmpSolveLayerTokens3[_i16-1].Type==='Token.Operator'||_tmpSolveLayerTokens3[_i16-1].Token==='(')){// The number line negation operator is a special case that generates a virtual constant (-1.0) and multiplies it by the next token
var _tmpAbstractMultiplyToken=this.getTokenContainerObject('*');_tmpAbstractMultiplyToken.VirtualSymbolName=_tmpToken4.VirtualSymbolName;tmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(_tmpAbstractMultiplyToken,this.getTokenContainerObject('-1.0'),_tmpSolveLayerTokens3[_i16+1]));}// The + at the beginning is also a number line orientation modifier ... THAT WE IGNORE
else if(_i16==0&&_tmpToken4.Token=='+'){continue;}// The + after an operator or a parenthesis is also a number line orientation modifier ... THAT WE IGNORE
else if(_i16>0&&_tmpToken4.Token=='+'&&(_tmpSolveLayerTokens3[_i16-1].Type==='Token.Operator'||_tmpSolveLayerTokens3[_i16-1].Token==='(')){continue;}// Finally add the dang thing.
else{tmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(_tmpToken4,_tmpSolveLayerTokens3[_i16-1],_tmpSolveLayerTokens3[_i16+1],_tmpSolveLayerTokens3,_i16));}}else if(_tmpSolveLayerTokens3[_i16].Type==='Token.Function'&&_tmpPrecedence===0){var _tmpToken5=_tmpSolveLayerTokens3[_i16];tmpResults.PostfixSolveList.push(this.getPosfixSolveListOperation(_tmpToken5,_tmpSolveLayerTokens3[_i16+1],this.getTokenContainerObject('0.0')));}}}}// 7. Lastly set the assignment address.
var tmpAbstractAssignToken='PostfixedAssignmentOperator'in tmpResults?this.getTokenContainerObject(tmpResults.PostfixedAssignmentOperator.Token):this.getTokenContainerObject('=');// The address we are assigning to
tmpAbstractAssignToken.VirtualSymbolName=tmpResults.PostfixedAssignmentAddress;// The address it's coming from
var tmpSolveResultToken=this.getTokenContainerObject('Result','Token.LastResult');var tmpFinalAssignmentInstruction=this.getPosfixSolveListOperation(tmpAbstractAssignToken,tmpSolveResultToken,this.getTokenContainerObject('SolverMarshal','Token.SolverMarshal'));tmpResults.PostfixSolveList.push(tmpFinalAssignmentInstruction);return tmpResults.PostfixSolveList;}}]);}(libExpressionParserOperationBase);module.exports=ExpressionParserPostfix;},{"./Fable-Service-ExpressionParser-Base.js":77}],83:[function(require,module,exports){var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');var ExpressionParserSolver=/*#__PURE__*/function(_libExpressionParserO5){function ExpressionParserSolver(pFable,pOptions,pServiceHash){var _this26;_classCallCheck2(this,ExpressionParserSolver);_this26=_callSuper(this,ExpressionParserSolver,[pFable,pOptions,pServiceHash]);_this26.serviceType='ExpressionParser-Solver';return _this26;}_inherits(ExpressionParserSolver,_libExpressionParserO5);return _createClass2(ExpressionParserSolver,[{key:"solvePostfixedExpression",value:function solvePostfixedExpression(pPostfixedExpression,pDataDestinationObject,pResultObject,pManifest){var tmpResults=_typeof(pResultObject)==='object'?pResultObject:{ExpressionParserLog:[]};var tmpManifest=_typeof(pManifest)==='object'?pManifest:this.fable.newManyfest();var tmpDataDestinationObject=_typeof(pDataDestinationObject)==='object'?pDataDestinationObject:{};// If there was a fable passed in (e.g. the results object was a service or such), we won't decorate
var tmpPassedInFable='fable'in tmpResults;if(!tmpPassedInFable){tmpResults.fable=this.fable;}if(!Array.isArray(pPostfixedExpression)){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.solvePostfixedExpression was passed a non-array postfixed expression.");this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return false;}if(pPostfixedExpression.length<1){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.solvePostfixedExpression was passed an empty postfixed expression.");this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return false;}// This is how the user communication magic happens.
tmpResults.VirtualSymbols={};for(var i=0;i<pPostfixedExpression.length;i++){if(pPostfixedExpression[i].Operation.Type==='Token.SolverInstruction'){continue;}var tmpStepResultObject={ExpressionStep:pPostfixedExpression[i],ExpressionStepIndex:i,ResultsObject:tmpResults,Manifest:tmpManifest};if(tmpStepResultObject.ExpressionStep.LeftValue.Type==='Token.LastResult'){tmpStepResultObject.ExpressionStep.LeftValue.Value=tmpResults.LastResult;}if(tmpStepResultObject.ExpressionStep.RightValue.Type==='Token.LastResult'){tmpStepResultObject.ExpressionStep.RightValue.Value=tmpResults.LastResult;}if(tmpStepResultObject.ExpressionStep.LeftValue.Type==='Token.VirtualSymbol'){tmpStepResultObject.ExpressionStep.LeftValue.Value=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.LeftValue.Token);}if(tmpStepResultObject.ExpressionStep.RightValue.Type==='Token.VirtualSymbol'){tmpStepResultObject.ExpressionStep.RightValue.Value=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.RightValue.Token);}// Resolve the parenthesis to their actual values
if(tmpStepResultObject.ExpressionStep.LeftValue.Type==='Token.Parenthesis'){tmpStepResultObject.ExpressionStep.LeftValue.Value=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.LeftValue.VirtualSymbolName);}if(tmpStepResultObject.ExpressionStep.RightValue.Type==='Token.Parenthesis'){tmpStepResultObject.ExpressionStep.RightValue.Value=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.RightValue.VirtualSymbolName);}// Virtual Constants
if(tmpStepResultObject.ExpressionStep.LeftValue.Type==='Token.Constant'&&!('Value'in tmpStepResultObject.ExpressionStep.LeftValue)){tmpStepResultObject.ExpressionStep.LeftValue.Value=tmpStepResultObject.ExpressionStep.LeftValue.Token;}if(tmpStepResultObject.ExpressionStep.RightValue.Type==='Token.Constant'&&!('Value'in tmpStepResultObject.ExpressionStep.RightValue)){tmpStepResultObject.ExpressionStep.RightValue.Value=tmpStepResultObject.ExpressionStep.RightValue.Token;}if(tmpStepResultObject.ExpressionStep.Operation.Type='Operator'){// TODO: This can be optimized.   A lot.  If necessary.  Seems pretty fast honestly for even thousands of operations.  Slowest part is arbitrary precision.
// An operator always has a left and right value.
var tmpFunctionAddress=false;// Note: There are easier, passive ways of managing this state.  But this is complex.
var tmpIsFunction=false;if(tmpStepResultObject.ExpressionStep.Operation.Token in this.ExpressionParser.tokenMap){tmpFunctionAddress="ResultsObject.".concat(tmpStepResultObject.ExpressionStep.Operation.Descriptor.Function);}else if(tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase()in this.ExpressionParser.functionMap){tmpIsFunction=true;tmpFunctionAddress="ResultsObject.".concat(this.ExpressionParser.functionMap[tmpStepResultObject.ExpressionStep.Operation.Token.toLowerCase()].Address);}if(tmpIsFunction){try{//this.log.trace(`Solving Function Step ${i} [${tmpStepResultObject.ExpressionStep.VirtualSymbolName}] --> [${tmpStepResultObject.ExpressionStep.Operation.Token}]: ( ${tmpStepResultObject.ExpressionStep.LeftValue.Value} , ${tmpStepResultObject.ExpressionStep.RightValue.Value} )`);
// Build the set of arguments to send to the functions.
tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString='';if(typeof tmpStepResultObject.ExpressionStep.LeftValue.Value==='undefined'){tmpStepResultObject.ExpressionStep.LeftValue.Arguments=[];}else if(Array.isArray(tmpStepResultObject.ExpressionStep.LeftValue.Value)){// Allow for array-based math sets to just be pased through
tmpStepResultObject.ExpressionStep.LeftValue.Arguments=tmpStepResultObject.ExpressionStep.LeftValue.Value;tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString='ExpressionStep.LeftValue.Arguments';}else if(_typeof(tmpStepResultObject.ExpressionStep.LeftValue.Value)==='object'){// Allow for array-based math sets to just be pased through
tmpStepResultObject.ExpressionStep.LeftValue.Arguments=tmpStepResultObject.ExpressionStep.LeftValue.Value;tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString='ExpressionStep.LeftValue.Arguments';}else{// Allow for string-based math sets.
tmpStepResultObject.ExpressionStep.LeftValue.Arguments=tmpStepResultObject.ExpressionStep.LeftValue.Value.toString().split(',');for(var j=0;j<tmpStepResultObject.ExpressionStep.LeftValue.Arguments.length;j++){if(tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString!==''){tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString+=',';}tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString+="ExpressionStep.LeftValue.Arguments[".concat(j,"]");}}tmpManifest.setValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.VirtualSymbolName,tmpManifest.getValueAtAddress(tmpStepResultObject,"".concat(tmpFunctionAddress,"(").concat(tmpStepResultObject.ExpressionStep.LeftValue.ArgumentString,")")));tmpResults.LastResult=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.VirtualSymbolName);//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)
}catch(pError){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ".concat(i," with function ").concat(tmpStepResultObject.ExpressionStep.Operation.Token,": ").concat(pError));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return false;}}else{try{//this.log.trace(`Solving Step ${i} [${tmpStepResultObject.ExpressionStep.VirtualSymbolName}] --> [${tmpStepResultObject.ExpressionStep.Operation.Token}]: ( ${tmpStepResultObject.ExpressionStep.LeftValue.Value} , ${tmpStepResultObject.ExpressionStep.RightValue.Value} )`);
tmpManifest.setValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.VirtualSymbolName,tmpManifest.getValueAtAddress(tmpStepResultObject,"".concat(tmpFunctionAddress,"(ExpressionStep.LeftValue.Value,ExpressionStep.RightValue.Value)")));tmpResults.LastResult=tmpManifest.getValueAtAddress(tmpResults.VirtualSymbols,tmpStepResultObject.ExpressionStep.VirtualSymbolName);//this.log.trace(`   ---> Step ${i}: ${tmpResults.VirtualSymbols[tmpStepResultObject.ExpressionStep.VirtualSymbolName]}`)
}catch(pError){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.solvePostfixedExpression failed to solve step ".concat(i," with function ").concat(tmpStepResultObject.ExpressionStep.Operation.Token,": ").concat(pError));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return false;}}// Equations don't always solve in virtual symbol order.
tmpResults.SolverFinalVirtualSymbol=tmpStepResultObject.ExpressionStep.VirtualSymbolName;}}var tmpSolverResultValue=tmpManifest.getValueAtAddress(tmpResults,"VirtualSymbols.".concat(tmpResults.SolverFinalVirtualSymbol));// Now deal with final assignment(s)
for(var _i17=0;_i17<pPostfixedExpression.length;_i17++){if(pPostfixedExpression[_i17].RightValue.Type==='Token.SolverMarshal'){// Set the result in the virtual symbols
tmpManifest.setValueAtAddress(tmpResults.VirtualSymbols,pPostfixedExpression[_i17].VirtualSymbolName,tmpSolverResultValue);// Set the value in the destination object
if(pPostfixedExpression[_i17].Operation.Descriptor.OnlyEmpty){// If it is only on "empty" values, check if the value is empty before assigning
if(this.fable.Utility.addressIsNullOrEmpty(tmpDataDestinationObject,pPostfixedExpression[_i17].VirtualSymbolName)){tmpManifest.setValueByHash(tmpDataDestinationObject,pPostfixedExpression[_i17].VirtualSymbolName,tmpSolverResultValue);}}else{// Otherwise, just assign it.
tmpManifest.setValueByHash(tmpDataDestinationObject,pPostfixedExpression[_i17].VirtualSymbolName,tmpSolverResultValue);}}}tmpResults.RawResult=tmpSolverResultValue;// Clean up the fable reference if we added it to the object.
if(!tmpPassedInFable){delete tmpResults.fable;}if(typeof tmpSolverResultValue!=='undefined'){return tmpSolverResultValue.toString();}else{return tmpSolverResultValue;}}}]);}(libExpressionParserOperationBase);module.exports=ExpressionParserSolver;},{"./Fable-Service-ExpressionParser-Base.js":77}],84:[function(require,module,exports){module.exports={"=":{"Name":"Assign Value","Token":"=","Function":"fable.Math.assignValue","Precedence":0,"Type":"Assignment"},"?=":{"Name":"Null or Empty Coalescing Assign Value","Token":"?=","Function":"fable.Math.assignValue","OnlyEmpty":true,"Precedence":0,"Type":"Assignment"},"(":{"Name":"Left Parenthesis","Token":"(","Precedence":0,"Type":"Parenthesis"},")":{"Name":"Right Parenthesis","Token":")","Precedence":0,"Type":"Parenthesis"},",":{"Name":"Set Concatenate","Token":",","Function":"fable.Math.setConcatenate","Precedence":4,"Type":"Operator"},"*":{"Name":"Multiply","Token":"*","Function":"fable.Math.multiplyPrecise","Precedence":3,"Type":"Operator"},"/":{"Name":"Divide","Token":"/","Function":"fable.Math.dividePrecise","Precedence":3,"Type":"Operator"},"^":{"Name":"Exponent","Token":"^","Function":"fable.Math.powerPrecise","Precedence":1,"Type":"Operator"},"%":{"Name":"Modulus","Token":"%","Function":"fable.Math.modPrecise","Precedence":3,"Type":"Operator"},"+":{"Name":"Add","Token":"+","Function":"fable.Math.addPrecise","Precedence":4,"Type":"Operator"},"-":{"Name":"Subtract","Token":"-","Function":"fable.Math.subtractPrecise","Precedence":4,"Type":"Operator"}};},{}],85:[function(require,module,exports){var libExpressionParserOperationBase=require('./Fable-Service-ExpressionParser-Base.js');var ExpressionParserValueMarshal=/*#__PURE__*/function(_libExpressionParserO6){function ExpressionParserValueMarshal(pFable,pOptions,pServiceHash){var _this27;_classCallCheck2(this,ExpressionParserValueMarshal);_this27=_callSuper(this,ExpressionParserValueMarshal,[pFable,pOptions,pServiceHash]);_this27.serviceType='ExpressionParser-ValueMarshal';return _this27;}/**
	 * Substitutes values in tokenized objects based on the provided data source and manifest.
	 * 
	 * TODO: Move this to its own file in the "Fable-Service-ExpressionParser" directory.
	 *
	 * @param {Array} pTokenizedObjects - The array of tokenized objects.
	 * @param {Object} pDataSource - The data source object where we pull values from.
	 * @param {Object} pResultObject - The result object where the algorithm shows its work.
	 * @param {Object} pManifest - The manifest object to use for hash resolution.
	 * @returns {Array} - The modified tokenized objects array.
	 */_inherits(ExpressionParserValueMarshal,_libExpressionParserO6);return _createClass2(ExpressionParserValueMarshal,[{key:"substituteValuesInTokenizedObjects",value:function substituteValuesInTokenizedObjects(pTokenizedObjects,pDataSource,pResultObject,pManifest){var tmpResults=_typeof(pResultObject)==='object'?pResultObject:{ExpressionParserLog:[]};if(!Array.isArray(pTokenizedObjects)){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.substituteValuesInTokenizedObjects was passed a non-array tokenized object list.");this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return pTokenizedObjects;}if(_typeof(pDataSource)!=='object'){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.substituteValuesInTokenizedObjects either was passed no data source, or was passed a non-object data source.");this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);return pTokenizedObjects;}var tmpDataSource=pDataSource;var tmpManifest=_typeof(pManifest)=='object'?pManifest:this.fable.newManyfest(pManifest);for(var i=0;i<pTokenizedObjects.length;i++){if(_typeof(pTokenizedObjects[i])!=='object'){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.substituteValuesInTokenizedObjects found a non-object tokenized object at index ".concat(i));this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);continue;}var tmpToken=pTokenizedObjects[i];if(pTokenizedObjects[i].Type==='Token.Symbol'&&!tmpToken.Resolved){// Symbols always look up values by hash first
var tmpValue=tmpManifest.getValueByHash(tmpDataSource,tmpToken.Token);// if (!tmpValue)
// {
// 	// If no hash resolves, try by address.
// 	tmpValue = tmpManifest.getValueAtAddress(tmpToken.Token, tmpDataSource);
// }
if(!tmpValue){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the symbol hash or address ".concat(tmpToken.Token," at index ").concat(i));this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);continue;}else{tmpResults.ExpressionParserLog.push("INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [".concat(tmpValue,"] for the state address ").concat(tmpToken.Token," at index ").concat(i));if(this.LogNoisiness>1)this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);try{var tmpValueParsed=new this.fable.Utility.bigNumber(tmpValue);tmpToken.Resolved=true;tmpToken.Value=tmpValueParsed.toString();}catch(pError){// TODO: Should we allow this to be a function?  Good god the complexity and beauty of that...
if(Array.isArray(tmpValue)||_typeof(tmpValue)==='object'){tmpToken.Resolved=true;tmpToken.Value=tmpValue;}else{tmpResults.ExpressionParserLog.push("INFO: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric, non-set value for the state address ".concat(tmpToken.Token," at index ").concat(i));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);tmpToken.Resolved=false;}}}}if(pTokenizedObjects[i].Type==='Token.StateAddress'&&!tmpToken.Resolved){// Symbols are always hashes.  This gracefully works for simple shallow objects because hashes default to the address in Manyfest.
var _tmpValue=tmpManifest.getValueAtAddress(tmpDataSource,tmpToken.Token);if(!_tmpValue){tmpResults.ExpressionParserLog.push("WARNING: ExpressionParser.substituteValuesInTokenizedObjects found no value for the state address ".concat(tmpToken.Token," at index ").concat(i));this.log.warn(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);continue;}else{//tmpResults.ExpressionParserLog.push(`INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [${tmpValue}] for the state address ${tmpToken.Token} at index ${i}`);
this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);try{var _tmpValueParsed=new this.fable.Utility.bigNumber(_tmpValue);tmpToken.Resolved=true;tmpToken.Value=_tmpValueParsed.toString();}catch(pError){tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ".concat(tmpToken.Token," at index ").concat(i));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);tmpToken.Resolved=false;}}}if(pTokenizedObjects[i].Type==='Token.String'&&!tmpToken.Resolved){tmpResults.ExpressionParserLog.push("INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [".concat(tmpToken.Token,"] for the string ").concat(tmpToken.Token," at index ").concat(i));if(this.LogNoisiness>1)this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);tmpToken.Resolved=true;// Take the quotes off the string
tmpToken.Value=tmpToken.Token.substring(1,tmpToken.Token.length-1);}if(pTokenizedObjects[i].Type==='Token.Constant'&&!tmpToken.Resolved){tmpResults.ExpressionParserLog.push("INFO: ExpressionParser.substituteValuesInTokenizedObjects found a value [".concat(tmpToken.Token,"] for the constant ").concat(tmpToken.Token," at index ").concat(i));if(this.LogNoisiness>1)this.log.info(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);try{var _tmpValueParsed2=new this.fable.Utility.bigNumber(tmpToken.Token);tmpToken.Resolved=true;tmpToken.Value=_tmpValueParsed2.toString();}catch(pError){// This constant has the right symbols but apparently isn't a parsable number.
tmpResults.ExpressionParserLog.push("ERROR: ExpressionParser.substituteValuesInTokenizedObjects found a non-numeric value for the state address ".concat(tmpToken.Token," at index ").concat(i));this.log.error(tmpResults.ExpressionParserLog[tmpResults.ExpressionParserLog.length-1]);tmpToken.Resolved=false;}}}return pTokenizedObjects;}}]);}(libExpressionParserOperationBase);module.exports=ExpressionParserValueMarshal;},{"./Fable-Service-ExpressionParser-Base.js":77}],86:[function(require,module,exports){(function(process){(function(){var libFableServiceBase=require('fable-serviceproviderbase');var libFS=require('fs');var libPath=require('path');var libReadline=require('readline');var FableServiceFilePersistence=/*#__PURE__*/function(_libFableServiceBase5){function FableServiceFilePersistence(pFable,pOptions,pServiceHash){var _this28;_classCallCheck2(this,FableServiceFilePersistence);_this28=_callSuper(this,FableServiceFilePersistence,[pFable,pOptions,pServiceHash]);_this28.serviceType='FilePersistence';if(!('Mode'in _this28.options)){_this28.options.Mode=parseInt('0777',8)&~process.umask();}_this28.libFS=libFS;_this28.libPath=libPath;_this28.libReadline=libReadline;return _this28;}_inherits(FableServiceFilePersistence,_libFableServiceBase5);return _createClass2(FableServiceFilePersistence,[{key:"joinPath",value:function joinPath(){return libPath.resolve.apply(libPath,arguments);}},{key:"existsSync",value:function existsSync(pPath){return libFS.existsSync(pPath);}},{key:"exists",value:function exists(pPath,fCallback){var tmpFileExists=this.existsSync(pPath);;return fCallback(null,tmpFileExists);}},{key:"appendFileSync",value:function appendFileSync(pFileName,pAppendContent,pOptions){var tmpOptions=typeof pOptions==='undefined'?'utf8':pOptions;return libFS.appendFileSync(pFileName,pAppendContent,tmpOptions);}},{key:"deleteFileSync",value:function deleteFileSync(pFileName){return libFS.unlinkSync(pFileName);}},{key:"deleteFolderSync",value:function deleteFolderSync(pFileName){return libFS.rmdirSync(pFileName);}},{key:"readFileSync",value:function readFileSync(pFilePath,pOptions){var tmpOptions=typeof pOptions==='undefined'?'utf8':pOptions;return libFS.readFileSync(pFilePath,tmpOptions);}},{key:"readFile",value:function readFile(pFilePath,pOptions,fCallback){var tmpOptions=typeof pOptions==='undefined'?'utf8':pOptions;return libFS.readFile(pFilePath,tmpOptions,fCallback);}},{key:"writeFileSync",value:function writeFileSync(pFileName,pFileContent,pOptions){var tmpOptions=typeof pOptions==='undefined'?'utf8':pOptions;return libFS.writeFileSync(pFileName,pFileContent,tmpOptions);}},{key:"writeFileSyncFromObject",value:function writeFileSyncFromObject(pFileName,pObject){return this.writeFileSync(pFileName,JSON.stringify(pObject,null,4));}},{key:"writeFileSyncFromArray",value:function writeFileSyncFromArray(pFileName,pFileArray){if(!Array.isArray(pFileArray)){this.log.error("File Persistence Service attempted to write ".concat(pFileName," from array but the expected array was not an array (it was a ").concat(_typeof(pFileArray),")."));return Error('Attempted to write ${pFileName} from array but the expected array was not an array (it was a ${typeof(pFileArray)}).');}else{for(var i=0;i<pFileArray.length;i++){return this.appendFileSync(pFileName,"".concat(pFileArray[i],"\n"));}}}},{key:"writeFile",value:function writeFile(pFileName,pFileContent,pOptions,fCallback){var tmpOptions=typeof pOptions==='undefined'?'utf8':pOptions;return libFS.writeFile(pFileName,pFileContent,tmpOptions,fCallback);}},{key:"lineReaderFactory",value:function lineReaderFactory(pFilePath,fOnLine,fOnComplete,fOnError){var tmpLineReader={};if(typeof pFilePath!='string'){return false;}tmpLineReader.filePath=pFilePath;tmpLineReader.fileStream=libFS.createReadStream(tmpLineReader.filePath);tmpLineReader.reader=libReadline.createInterface({input:tmpLineReader.fileStream,crlfDelay:Infinity});if(typeof fOnError==='function'){tmpLineReader.reader.on('error',fOnError);}tmpLineReader.reader.on('line',typeof fOnLine==='function'?fOnLine:function(){});if(typeof fOnComplete==='function'){tmpLineReader.reader.on('close',fOnComplete);}return tmpLineReader;}// Folder management
},{key:"makeFolderRecursive",value:function makeFolderRecursive(pParameters,fCallback){var _this29=this;var tmpParameters=pParameters;if(typeof pParameters=='string'){tmpParameters={Path:pParameters};}else if(_typeof(pParameters)!=='object'){fCallback(new Error('Parameters object or string not properly passed to recursive folder create.'));return false;}if(typeof tmpParameters.Path!=='string'){fCallback(new Error('Parameters object needs a path to run the folder create operation.'));return false;}if(!('Mode'in tmpParameters)){tmpParameters.Mode=this.options.Mode;}// Check if we are just starting .. if so, build the initial state for our recursive function
if(typeof tmpParameters.CurrentPathIndex==='undefined'){// Build the tools to start recursing
tmpParameters.ActualPath=libPath.normalize(tmpParameters.Path);tmpParameters.ActualPathParts=tmpParameters.ActualPath.split(libPath.sep);tmpParameters.CurrentPathIndex=0;tmpParameters.CurrentPath='';}else{// This is not our first run, so we will continue the recursion.
// Build the new base path
if(tmpParameters.CurrentPath==libPath.sep){tmpParameters.CurrentPath=tmpParameters.CurrentPath+tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];}else{tmpParameters.CurrentPath=tmpParameters.CurrentPath+libPath.sep+tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex];}// Increment the path index
tmpParameters.CurrentPathIndex++;}// Check if the path is fully complete
if(tmpParameters.CurrentPathIndex>=tmpParameters.ActualPathParts.length){return fCallback(null);}// Check if the path exists (and is a folder)
libFS.open(tmpParameters.CurrentPath+libPath.sep+tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex],'r',function(pError,pFileDescriptor){if(pFileDescriptor){libFS.closeSync(pFileDescriptor);}if(pError&&pError.code=='ENOENT'){/* Path doesn't exist, create it */libFS.mkdir(tmpParameters.CurrentPath+libPath.sep+tmpParameters.ActualPathParts[tmpParameters.CurrentPathIndex],tmpParameters.Mode,function(pCreateError){if(!pCreateError){// We have now created our folder and there was no error -- continue.
return _this29.makeFolderRecursive(tmpParameters,fCallback);}else if(pCreateError.code=='EEXIST'){// The folder exists -- our dev might be running this in parallel/async/whatnot.
return _this29.makeFolderRecursive(tmpParameters,fCallback);}else{console.log(pCreateError.code);return fCallback(pCreateError);}});}else{return _this29.makeFolderRecursive(tmpParameters,fCallback);}});}}]);}(libFableServiceBase);module.exports=FableServiceFilePersistence;}).call(this);}).call(this,require('_process'));},{"_process":147,"fable-serviceproviderbase":59,"fs":19,"path":135,"readline":19}],87:[function(require,module,exports){/**
 * @file Fable-Service-Math.js
 * @description This file contains the implementation of the FableServiceMath class, which provides simple functions for performing arbitrary precision math operations.
 * @module FableServiceMath
 * @extends libFableServiceBase
 */var libFableServiceBase=require('fable-serviceproviderbase');/**
 * Arbitrary Precision Math Operations
 * @author      Steven Velozo <steven@velozo.com>
 * @description Simple functions that perform arbitrary precision math operations and return string resultant values.  Wraps big.js
 * @class FableServiceMath
 * @extends libFableServiceBase
 */var FableServiceMath=/*#__PURE__*/function(_libFableServiceBase6){function FableServiceMath(pFable,pOptions,pServiceHash){var _this30;_classCallCheck2(this,FableServiceMath);_this30=_callSuper(this,FableServiceMath,[pFable,pOptions,pServiceHash]);_this30.serviceType='Math';_this30.pi='3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679';//		this.manifest = this.fable.newManyfest();
return _this30;}/*
		Pass-through Rounding Method Constants
	
		Property	   Value   BigDecimal Equiv   Description
		----------     -----   ----------------   -----------
		roundDown      0       ROUND_DOWN         Rounds towards zero. (_I.e. truncate, no rounding._)
		roundHalfUp    1       ROUND_HALF_UP      Rounds towards nearest neighbour. (_If equidistant, rounds away from zero._)
		roundHalfEven  2       ROUND_HALF_EVEN    Rounds towards nearest neighbour. (_If equidistant, rounds towards even neighbour._)
		roundUp        3       ROUND_UP           Rounds positively away from zero. (_Always round up._)
	*/_inherits(FableServiceMath,_libFableServiceBase6);return _createClass2(FableServiceMath,[{key:"roundDown",get:function get(){return this.fable.Utility.bigNumber.roundDown;}},{key:"roundHalfUp",get:function get(){return this.fable.Utility.bigNumber.roundHalfUp;}},{key:"roundHalfEven",get:function get(){return this.fable.Utility.bigNumber.roundHalfEven;}},{key:"roundUp",get:function get(){return this.fable.Utility.bigNumber.roundUp;}/**
	 * Parses a precise number value.
	 *
	 * @param {number} pValue - The value to parse.
	 * @param {any} pNonNumberValue - The value to use if parsing fails.
	 * @returns {string} - The parsed number as a string.
	 */},{key:"parsePrecise",value:function parsePrecise(pValue,pNonNumberValue){var tmpNumber;try{tmpNumber=new this.fable.Utility.bigNumber(pValue);}catch(pError){this.log.warn("Error parsing number (type ".concat(_typeof(pValue),"): ").concat(pError));tmpNumber=typeof pNonNumberValue==='undefined'?"0.0":pNonNumberValue;}return tmpNumber.toString();}/**
	 * Assigns the given value.  For equals operations in the solver.
	 * @param {*} pValue - The value to be assigned.
	 * @returns {*} The assigned value.
	 */},{key:"assignValue",value:function assignValue(pValue){return pValue;}/**
	 * Calculates the precise percentage of a given value compared to another value.
	 *
	 * @param {number} pIs - The value to calculate the percentage of.
	 * @param {number} pOf - The value to calculate the percentage against.
	 * @returns {string} The precise percentage as a string.
	 */},{key:"percentagePrecise",value:function percentagePrecise(pIs,pOf){var tmpLeftValue=isNaN(pIs)?0:pIs;var tmpRightValue=isNaN(pOf)?0:pOf;if(tmpRightValue==0){return'0';}var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.div(tmpRightValue);tmpResult=tmpResult.times(100);return tmpResult.toString();}/**
	 * Concatenates two value sets and returns the result as a string.
	 * 
	 * Value sets are comma separated.
	 * 
	 * Used for arbitrary precision set generation.
	 *
	 * @param {any} pLeftValue - The left value to append.
	 * @param {any} pRightValue - The right value to append.
	 * @returns {string} The concatenated string of the left and right values.
	 */},{key:"setConcatenate",value:function setConcatenate(pLeftValue,pRightValue){return"".concat(pLeftValue,",").concat(pRightValue);}/**
	 * Rounds a value to a specified number of decimal places using a specified rounding method.
	 *
	 * @param {number} pValue - The value to be rounded.
	 * @param {number} pDecimals - The number of decimal places to round to.
	 * @param {function} [pRoundingMethod] - The rounding method to use. Defaults to `this.roundHalfUp`.
	 * @returns {string} - The rounded value as a string.
	 */},{key:"roundPrecise",value:function roundPrecise(pValue,pDecimals,pRoundingMethod){var tmpValue=isNaN(pValue)?0:pValue;var tmpDecimals=isNaN(pDecimals)?0:parseInt(pDecimals,10);var tmpRoundingMethod=typeof pRoundingMethod==='undefined'?this.roundHalfUp:parseInt(pRoundingMethod,10);var tmpArbitraryValue=new this.fable.Utility.bigNumber(tmpValue);var tmpResult=tmpArbitraryValue.round(tmpDecimals,tmpRoundingMethod);return tmpResult.toString();}/**
	 * Returns a string representation of a number with a specified number of decimals.
	 * 
	 * @param {number} pValue - The number to be formatted.
	 * @param {number} pDecimals - The number of decimals to include in the formatted string.
	 * @param {string} [pRoundingMethod] - The rounding method to use. Defaults to 'roundHalfUp'.
	 * @returns {string} - The formatted number as a string.
	 */},{key:"toFixedPrecise",value:function toFixedPrecise(pValue,pDecimals,pRoundingMethod){var tmpValue=isNaN(pValue)?0:pValue;var tmpDecimals=isNaN(pDecimals)?0:pDecimals;var tmpRoundingMethod=typeof pRoundingMethod==='undefined'?this.roundHalfUp:pRoundingMethod;var tmpArbitraryValue=new this.fable.Utility.bigNumber(tmpValue);var tmpResult=tmpArbitraryValue.toFixed(tmpDecimals,tmpRoundingMethod);return tmpResult.toString();}/**
	 * Adds two values precisely.
	 * @param {number} pLeftValue - The left value to be added.
	 * @param {number} pRightValue - The right value to be added.
	 * @returns {string} - The result of adding the two values as a string.
	 */},{key:"addPrecise",value:function addPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.plus(tmpRightValue);return tmpResult.toString();}/**
	 * Subtracts two values precisely.
	 *
	 * @param {number} pLeftValue - The left value to subtract.
	 * @param {number} pRightValue - The right value to subtract.
	 * @returns {string} The result of the subtraction as a string.
	 */},{key:"subtractPrecise",value:function subtractPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.minus(tmpRightValue);return tmpResult.toString();}/**
	 * Calculates the precise power of two numbers.
	 * 
	 * @param {number} pLeftValue - The base value.
	 * @param {number} pRightValue - The exponent value.
	 * @returns {string} The result of raising the base value to the exponent value.
	 */},{key:"powerPrecise",value:function powerPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:parseInt(pRightValue);var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.pow(tmpRightValue);return tmpResult.toString();}/**
	 * Multiplies two values precisely.
	 *
	 * @param {number} pLeftValue - The left value to multiply.
	 * @param {number} pRightValue - The right value to multiply.
	 * @returns {string} The result of the multiplication as a string.
	 */},{key:"multiplyPrecise",value:function multiplyPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.times(tmpRightValue);return tmpResult.toString();}/**
	 * Divides two values precisely.
	 *
	 * @param {number} pLeftValue - The left value to be divided.
	 * @param {number} pRightValue - The right value to divide by.
	 * @returns {string} The result of the division as a string.
	 */},{key:"dividePrecise",value:function dividePrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.div(tmpRightValue);return tmpResult.toString();}/**
	 * Calculates the modulus of two values with precision.
	 *
	 * @param {number} pLeftValue - The left value.
	 * @param {number} pRightValue - The right value.
	 * @returns {string} The result of the modulus operation as a string.
	 */},{key:"modPrecise",value:function modPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);var tmpResult=tmpLeftArbitraryValue.mod(tmpRightValue);return tmpResult.toString();}/**
	 * Calculates the square root of a number with precise decimal places.
	 *
	 * @param {number} pValue - The number to calculate the square root of.
	 * @returns {string} The square root of the input number as a string.
	 */},{key:"sqrtPrecise",value:function sqrtPrecise(pValue){var tmpValue=isNaN(pValue)?0:pValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpValue);var tmpResult=tmpLeftArbitraryValue.sqrt();return tmpResult.toString();}/**
	 * Calculates the absolute value of a number precisely.
	 *
	 * @param {number} pValue - The number to calculate the absolute value of.
	 * @returns {string} The absolute value of the input number as a string.
	 */},{key:"absPrecise",value:function absPrecise(pValue){var tmpValue=isNaN(pValue)?0:pValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpValue);var tmpResult=tmpLeftArbitraryValue.abs();return tmpResult.toString();}/**
	 * Compares two values precisely.
	 *
	 * @param {number} pLeftValue - The left value to compare.
	 * @param {number} pRightValue - The right value to compare.
	 * @returns {number} - Returns the result of the comparison.
	 */},{key:"comparePrecise",value:function comparePrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);return tmpLeftArbitraryValue.cmp(tmpRightValue);}/**
	 * Determines if the left value is greater than the right value precisely.
	 *
	 * @param {number} pLeftValue - The left value to compare.
	 * @param {number} pRightValue - The right value to compare.
	 * @returns {boolean} - Returns true if the left value is greater than the right value, otherwise returns false.
	 */},{key:"gtPrecise",value:function gtPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);return tmpLeftArbitraryValue.gt(tmpRightValue);}/**
	 * Checks if the left value is greater than or equal to the right value.
	 * If either value is not a number, it is treated as 0.
	 *
	 * @param {number} pLeftValue - The left value to compare.
	 * @param {number} pRightValue - The right value to compare.
	 * @returns {boolean} - True if the left value is greater than or equal to the right value, false otherwise.
	 */},{key:"gtePrecise",value:function gtePrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);return tmpLeftArbitraryValue.gte(tmpRightValue);}/**
	 * Determines if the left value is less than the right value precisely.
	 *
	 * @param {number} pLeftValue - The left value to compare.
	 * @param {number} pRightValue - The right value to compare.
	 * @returns {boolean} - Returns true if the left value is less than the right value, otherwise returns false.
	 */},{key:"ltPrecise",value:function ltPrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);return tmpLeftArbitraryValue.lt(tmpRightValue);}/**
	 * Determines if the left value is less than or equal to the right value.
	 *
	 * @param {number} pLeftValue - The left value to compare.
	 * @param {number} pRightValue - The right value to compare.
	 * @returns {boolean} - Returns true if the left value is less than or equal to the right value, otherwise returns false.
	 */},{key:"ltePrecise",value:function ltePrecise(pLeftValue,pRightValue){var tmpLeftValue=isNaN(pLeftValue)?0:pLeftValue;var tmpRightValue=isNaN(pRightValue)?0:pRightValue;var tmpLeftArbitraryValue=new this.fable.Utility.bigNumber(tmpLeftValue);return tmpLeftArbitraryValue.lte(tmpRightValue);}/**
	 * Converts degrees to radians with arbitrary precision.
	 * 
	 * @param {number} pDegrees - The degrees to convert to radians.
	 * @returns {string} - The converted radians as a string.
	 */},{key:"radPrecise",value:function radPrecise(pDegrees){var tmpDegrees=isNaN(pDegrees)?0:pDegrees;var tmpDegreesArbitraryValue=new this.fable.Utility.bigNumber(tmpDegrees);// TODO: Const for pi in arbitrary precision?
var tmpResult=tmpDegreesArbitraryValue.times(Math.PI).div(180);return tmpResult.toString();}/**
	 * Calculates the value of pi with the specified precision.
	 * If no precision is provided, returns 100 digits after the decimal.
	 *
	 * @param {number} [pPrecision] - The precision to use for calculating pi.
	 * @returns {number} - The calculated value of pi.
	 */},{key:"piPrecise",value:function piPrecise(pPrecision){if(typeof pPrecision==='undefined'){return this.pi;}else{return this.roundPrecise(this.pi,pPrecision);}}/**
	 * Calculates the sine of the given angle in radians.
	 *
	 * @param {number} pRadians - The angle in radians.
	 * @returns {number} The sine of the angle.
	 */},{key:"sin",value:function sin(pRadians){var tmpRadians=isNaN(pRadians)?0:pRadians;return Math.sin(tmpRadians);}/**
	 * Calculates the cosine of the given angle in radians.
	 * 
	 * @param {number} pRadians - The angle in radians.
	 * @returns {number} The cosine of the angle.
	 */},{key:"cos",value:function cos(pRadians){var tmpRadians=isNaN(pRadians)?0:pRadians;return Math.cos(tmpRadians);}/**
	 * Calculates the tangent of an angle in radians.
	 *
	 * @param {number} pRadians - The angle in radians.
	 * @returns {number} The tangent of the angle.
	 */},{key:"tan",value:function tan(pRadians){var tmpRadians=isNaN(pRadians)?0:pRadians;return Math.tan(tmpRadians);}/* * * * * * * * * * * * * * * *
	 * Set functions
	 * These are meant to work fine with arrays and more complex set descriptions returned by Manyfest.
	 * Manyfest sometimes returns values as arrays and sometimes as a map of addresses with values depending
	 * on what was requested.
	 * 
	 * The following functions will likely be broken into their own service.
	 *//**
	 * Counts the number of elements in a set.
	 *
	 * @param {Array|Object|any} pValueSet - The set to count the elements of.
	 * @returns {number} The number of elements in the set.
	 */},{key:"countSetElements",value:function countSetElements(pValueSet){if(Array.isArray(pValueSet)){return pValueSet.length;}else if(_typeof(pValueSet)==='object'){return Object.keys(pValueSet).length;}else if(pValueSet){// This is controversial.  Discuss with colleagues!
return 1;}return 0;}/**
	 * Sorts the elements in the given value set in ascending order using the precise parsing and comparison.
	 * 
	 * @param {Array|Object} pValueSet - The value set to be sorted.
	 * @returns {Array} - The sorted value set.
	 */},{key:"sortSetPrecise",value:function sortSetPrecise(pValueSet){var _this31=this;var tmpSortedSet=[];if(Array.isArray(pValueSet)){for(var i=0;i<pValueSet.length;i++){tmpSortedSet.push(this.parsePrecise(pValueSet[i],NaN));}}else if(_typeof(pValueSet)==='object'){var tmpKeys=Object.keys(pValueSet);for(var _i18=0;_i18<tmpKeys.length;_i18++){tmpSortedSet.push(this.parsePrecise(pValueSet[tmpKeys[_i18]],NaN));}}tmpSortedSet.sort(function(pLeft,pRight){return _this31.comparePrecise(pLeft,pRight);});return tmpSortedSet;}/**
	 * Bucketizes a set of values based on a specified bucket size.
	 *
	 * @param {Array|Object} pValueSet - The set of values to be bucketized.
	 * @param {number} pBucketSize - The size of each bucket. Optional - If NaN, the values will be bucketized by their value.
	 * @returns {Object} - The bucketized set of values.
	 */},{key:"bucketSetPrecise",value:function bucketSetPrecise(pValueSet,pBucketSize){var tmpBucketedSet={};var tmpBucketSize=this.parsePrecise(pBucketSize,NaN);if(Array.isArray(pValueSet)){for(var i=0;i<pValueSet.length;i++){var tmpValue=this.parsePrecise(pValueSet[i],NaN);var tmpBucket=tmpValue.toString();if(!isNaN(tmpBucketSize)){tmpBucket=this.dividePrecise(pValueSet[i],tmpBucketSize);}if(!(tmpBucket in tmpBucketedSet)){tmpBucketedSet[tmpBucket]=0;}tmpBucketedSet[tmpBucket]=tmpBucketedSet[tmpBucket]+1;}}else if(_typeof(pValueSet)==='object'){var tmpKeys=Object.keys(pValueSet);for(var _i19=0;_i19<tmpKeys.length;_i19++){var _tmpValue2=this.parsePrecise(pValueSet[tmpKeys[_i19]],NaN);var _tmpBucket=_tmpValue2.toString();if(!isNaN(tmpBucketSize)){_tmpBucket=this.dividePrecise(pValueSet[_i19],tmpBucketSize);}if(!(_tmpBucket in tmpBucketedSet)){tmpBucketedSet[_tmpBucket]=0;}tmpBucketedSet[_tmpBucket]=tmpBucketedSet[_tmpBucket]+1;}}return tmpBucketedSet;}/**
	 * Calculates the histogram using precise bucket set for the given pValueSet.
	 * 
	 * @param {Array<number>} pValueSet - The array of p-values.
	 * @returns {Array<number>} The histogram of the p-values.
	 */},{key:"histogramPrecise",value:function histogramPrecise(pValueSet){return this.bucketSetPrecise(pValueSet);}/**
	 * Sorts the histogram object in ascending order based on the frequencies of the buckets.
	 * 
	 * @param {Object} pHistogram - The histogram object to be sorted.
	 * @returns {Object} - The sorted histogram object.
	 */},{key:"sortHistogramPrecise",value:function sortHistogramPrecise(pHistogram){var tmpSortedHistogram={};var tmpKeys=Object.keys(pHistogram);tmpKeys.sort(function(pLeft,pRight){return pHistogram[pLeft]-pHistogram[pRight];});for(var i=0;i<tmpKeys.length;i++){tmpSortedHistogram[tmpKeys[i]]=pHistogram[tmpKeys[i]];}return tmpSortedHistogram;}/**
	 * Finds the maximum value from a set of precise values.
	 * 
	 * @param {Array|Object} pValueSet - The set of values to find the maximum from.
	 * @returns {number} - The maximum value from the set.
	 */},{key:"maxPrecise",value:function maxPrecise(pValueSet){var tmpMaxValue=NaN;if(Array.isArray(pValueSet)){for(var i=0;i<pValueSet.length;i++){if(!tmpMaxValue){tmpMaxValue=this.parsePrecise(pValueSet[i],NaN);}else{var tmpComparisonValue=this.parsePrecise(pValueSet[i],NaN);if(this.gtPrecise(tmpComparisonValue,tmpMaxValue)){tmpMaxValue=tmpComparisonValue;}}}}else if(_typeof(pValueSet)==='object'){var tmpKeys=Object.keys(pValueSet);for(var _i20=0;_i20<tmpKeys.length;_i20++){if(!tmpMaxValue){tmpMaxValue=this.parsePrecise(pValueSet[tmpKeys[_i20]],NaN);}else{var _tmpComparisonValue=this.parsePrecise(pValueSet[tmpKeys[_i20]],NaN);if(this.gtPrecise(_tmpComparisonValue,tmpMaxValue)){tmpMaxValue=_tmpComparisonValue;}}}}return tmpMaxValue;}/**
	 * Finds the minimum value from a set of values.
	 *
	 * @param {Array|Object} pValueSet - The set of values to find the minimum from.
	 * @returns {number} The minimum value from the set.
	 */},{key:"minPrecise",value:function minPrecise(pValueSet){var tmpMinValue=NaN;if(Array.isArray(pValueSet)){for(var i=0;i<pValueSet.length;i++){if(!tmpMinValue){tmpMinValue=this.parsePrecise(pValueSet[i],NaN);}else{var tmpComparisonValue=this.parsePrecise(pValueSet[i],NaN);if(!isNaN(tmpComparisonValue)&&this.ltPrecise(tmpComparisonValue,tmpMinValue)){tmpMinValue=tmpComparisonValue;}}}}else if(_typeof(pValueSet)==='object'){var tmpKeys=Object.keys(pValueSet);for(var _i21=0;_i21<tmpKeys.length;_i21++){if(!tmpMinValue){tmpMinValue=this.parsePrecise(pValueSet[tmpKeys[_i21]],NaN);}else{var _tmpComparisonValue2=this.parsePrecise(pValueSet[tmpKeys[_i21]],NaN);if(!isNaN(_tmpComparisonValue2)&&this.ltPrecise(_tmpComparisonValue2,tmpMinValue)){tmpMinValue=_tmpComparisonValue2;}}}}return tmpMinValue;}/**
	 * Calculates the precise sum of values in the given value set.
	 * 
	 * @param {Array|Object} pValueSet - The value set to calculate the sum from.
	 * @returns {string} The precise sum value as a string.
	 */},{key:"sumPrecise",value:function sumPrecise(pValueSet){var tmpSumValue="0.0";if(Array.isArray(pValueSet)){for(var i=0;i<pValueSet.length;i++){var tmpComparisonValue=this.parsePrecise(pValueSet[i],NaN);if(!isNaN(tmpComparisonValue)){tmpSumValue=this.addPrecise(tmpSumValue,tmpComparisonValue);}}}else if(_typeof(pValueSet)==='object'){var tmpKeys=Object.keys(pValueSet);for(var _i22=0;_i22<tmpKeys.length;_i22++){var _tmpComparisonValue3=this.parsePrecise(pValueSet[tmpKeys[_i22]],NaN);if(!isNaN(_tmpComparisonValue3)){tmpSumValue=this.addPrecise(tmpSumValue,_tmpComparisonValue3);}}}return tmpSumValue;}/**
	 * Calculates the precise mean of a given value set.
	 *
	 * @param {Array<number>} pValueSet - The array of values to calculate the mean.
	 * @returns {string} The precise mean value as a string.
	 */},{key:"meanPrecise",value:function meanPrecise(pValueSet){var tmpSumValue=this.sumPrecise(pValueSet);var tmpCount=this.countSetElements(pValueSet);if(tmpCount==0){return'0.0';}return this.dividePrecise(tmpSumValue,tmpCount);}/**
	 * Calculates the average of an array of values precisely.
	 *
	 * @param {Array<number>} pValueSet - The array of values to calculate the average of.
	 * @returns {number} The precise average of the values.
	 */},{key:"averagePrecise",value:function averagePrecise(pValueSet){return this.meanPrecise(pValueSet);}/**
	 * Calculates the precise median value of a given value set.
	 *
	 * @param {Array<number>} pValueSet - The array of values to calculate the median from.
	 * @returns {number|string} - The median value of the given value set. If the value set is empty, returns '0.0'.
	 */},{key:"medianPrecise",value:function medianPrecise(pValueSet){var tmpCount=this.countSetElements(pValueSet);// If there are no elements, return 0 ... should this be NaN?
if(tmpCount==0){return'0.0';}var tmpSortedValueSet=this.sortSetPrecise(pValueSet);var tmpMiddleElement=Math.floor(tmpCount/2);// If the count is odd, return the middle element
if(tmpCount%2==1){return tmpSortedValueSet[tmpMiddleElement];}// If the count is even, return the average of the two middle elements
else{var tmpLeftMiddleValue=tmpSortedValueSet[tmpMiddleElement-1];var tmpRightMiddleValue=tmpSortedValueSet[tmpMiddleElement];return this.dividePrecise(this.addPrecise(tmpLeftMiddleValue,tmpRightMiddleValue),2);}}/**
	 * Calculates the mode (most frequently occurring value) of a given value set using precise mode calculation.
	 * 
	 * @param {Array} pValueSet - The array of values to calculate the mode from.
	 * @returns {Array} - An array containing the mode value(s) from the given value set.
	 */},{key:"modePrecise",value:function modePrecise(pValueSet){var tmpHistogram=this.bucketSetPrecise(pValueSet);var tmpMaxCount=0;// Philosophical question about whether the values should be returned sorted.
var tmpHistogramValueSet=Object.keys(tmpHistogram);var tmpModeValueSet=[];for(var i=0;i<tmpHistogramValueSet.length;i++){if(tmpHistogram[tmpHistogramValueSet[i]]>tmpMaxCount){tmpMaxCount=tmpHistogram[tmpHistogramValueSet[i]];tmpModeValueSet=[tmpHistogramValueSet[i]];}else if(tmpHistogram[tmpHistogramValueSet[i]]==tmpMaxCount){tmpModeValueSet.push(tmpHistogramValueSet[i]);}}return tmpModeValueSet;}}]);}(libFableServiceBase);module.exports=FableServiceMath;},{"fable-serviceproviderbase":59}],88:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');/**
* Precedent Meta-Templating
* @author      Steven Velozo <steven@velozo.com>
* @description Process text stream trie and postfix tree, parsing out meta-template expression functions.
*/var libWordTree=require("./Fable-Service-MetaTemplate/MetaTemplate-WordTree.js");var libStringParser=require("./Fable-Service-MetaTemplate/MetaTemplate-StringParser.js");var FableServiceMetaTemplate=/*#__PURE__*/function(_libFableServiceBase7){function FableServiceMetaTemplate(pFable,pOptions,pServiceHash){var _this32;_classCallCheck2(this,FableServiceMetaTemplate);_this32=_callSuper(this,FableServiceMetaTemplate,[pFable,pOptions,pServiceHash]);_this32.serviceType='MetaTemplate';_this32.WordTree=new libWordTree();_this32.StringParser=new libStringParser(_this32.fable);_this32.ParseTree=_this32.WordTree.ParseTree;return _this32;}_inherits(FableServiceMetaTemplate,_libFableServiceBase7);return _createClass2(FableServiceMetaTemplate,[{key:"addPattern",value:function addPattern(pPatternStart,pPatternEnd,pParser,pParserContext){return this.WordTree.addPattern(pPatternStart,pPatternEnd,pParser,pParserContext);}},{key:"addPatternBoth",value:function addPatternBoth(pPatternStart,pPatternEnd,pParser,pParserPromise,pParserContext){return this.WordTree.addPatternBoth(pPatternStart,pPatternEnd,pParser,pParserPromise,pParserContext);}/**
	 * Parse a string with the existing parse tree
	 * @method parseString
	 * @param {string} pString - The string to parse
	 * @param {object} pData - Data to pass in as the second argument
	 * @param {function} fCallback - The callback function to call when a pattern is matched
	 * @param {array} pDataContext - The history of data objects already passed in
	 * @return {string} The result from the parser
	 */},{key:"parseString",value:function parseString(pString,pData,fCallback,pDataContext){if(this.LogNoisiness>4){this.fable.log.trace("Metatemplate parsing template string [".concat(pString,"] where the callback is a ").concat(_typeof(fCallback)),{TemplateData:pData});}return this.StringParser.parseString(pString,this.ParseTree,pData,fCallback,pDataContext);}}]);}(libFableServiceBase);module.exports=FableServiceMetaTemplate;},{"./Fable-Service-MetaTemplate/MetaTemplate-StringParser.js":89,"./Fable-Service-MetaTemplate/MetaTemplate-WordTree.js":90,"fable-serviceproviderbase":59}],89:[function(require,module,exports){/**
* String Parser
* @author      Steven Velozo <steven@velozo.com>
* @description Parse a string, properly processing each matched token in the word tree.
*/var StringParser=/*#__PURE__*/function(){/**
	 * StringParser Constructor
	 */function StringParser(pFable){_classCallCheck2(this,StringParser);this.fable=pFable;}/**
	 * Create a fresh parsing state object to work with.
	 * @method newParserState
	 * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)
	 * @return {Object} A new parser state object for running a character parser on
	 * @private
	 */return _createClass2(StringParser,[{key:"newParserState",value:function newParserState(pParseTree){return{ParseTree:pParseTree,Asynchronous:false,Output:'',OutputBuffer:'',Pattern:{},PatternMatch:false,PatternMatchEnd:false};}/**
	 * Append a character to the output buffer in the parser state.
	 * This output buffer is used when a potential match is being explored, or a match is being explored.
	 * @method appendOutputBuffer
	 * @param {string} pCharacter - The character to append
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"appendOutputBuffer",value:function appendOutputBuffer(pCharacter,pParserState){pParserState.OutputBuffer+=pCharacter;}/**
	 * Flush the output buffer to the output and clear it.
	 * @method flushOutputBuffer
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"flushOutputBuffer",value:function flushOutputBuffer(pParserState){pParserState.Output+=pParserState.OutputBuffer;pParserState.OutputBuffer='';}},{key:"resetOutputBuffer",value:function resetOutputBuffer(pParserState){// Flush the output buffer.
this.flushOutputBuffer(pParserState);// End pattern mode
pParserState.Pattern=false;pParserState.PatternStartNode=false;pParserState.StartPatternMatchComplete=false;pParserState.EndPatternMatchBegan=false;pParserState.PatternMatch=false;return true;}/**
	 * Parse a character in the buffer.
	 * @method parseCharacter
	 * @param {string} pCharacter - The character to append
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"parseCharacter",value:function parseCharacter(pCharacter,pParserState,pData,pDataContext){// If we are already in a pattern match traversal
if(pParserState.PatternMatch){// If the pattern is still matching the start and we haven't passed the buffer
if(!pParserState.StartPatternMatchComplete&&pCharacter in pParserState.Pattern){pParserState.Pattern=pParserState.Pattern[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else if(pParserState.EndPatternMatchBegan){if(pCharacter in pParserState.Pattern.PatternEnd){// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// Flush the output buffer.
this.appendOutputBuffer(pCharacter,pParserState);// If this last character is the end of the pattern, parse it.
// Run the function
var tmpFunctionContext='ParserContext'in pParserState.Pattern?pParserState.Pattern.ParserContext:false;if(tmpFunctionContext){pParserState.OutputBuffer=pParserState.Pattern.Parse.call(tmpFunctionContext,pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}else{pParserState.OutputBuffer=pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}return this.resetOutputBuffer(pParserState);}else if(pCharacter in pParserState.PatternStartNode.PatternEnd){// We broke out of the end -- see if this is a new start of the end.
pParserState.Pattern=pParserState.PatternStartNode.PatternEnd[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else{pParserState.EndPatternMatchBegan=false;this.appendOutputBuffer(pCharacter,pParserState);}}else if('PatternEnd'in pParserState.Pattern){if(!pParserState.StartPatternMatchComplete){pParserState.StartPatternMatchComplete=true;pParserState.PatternStartNode=pParserState.Pattern;}this.appendOutputBuffer(pCharacter,pParserState);if(pCharacter in pParserState.Pattern.PatternEnd){// This is the first character of the end pattern.
pParserState.EndPatternMatchBegan=true;// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// If this last character is the end of the pattern, parse it.
if('Parse'in pParserState.Pattern){// Run the t*mplate function
var _tmpFunctionContext='ParserContext'in pParserState.Pattern?pParserState.Pattern.ParserContext:false;if(_tmpFunctionContext){pParserState.OutputBuffer=pParserState.Pattern.Parse.call(_tmpFunctionContext,pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}else{pParserState.OutputBuffer=pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}return this.resetOutputBuffer(pParserState);}}}else{// We are in a pattern start but didn't match one; reset and start trying again from this character.
this.resetOutputBuffer(pParserState);}}// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....
if(!pParserState.PatternMatch){// This may be the start of a new pattern....
if(pCharacter in pParserState.ParseTree){// ... assign the root node as the matched node.
this.resetOutputBuffer(pParserState);this.appendOutputBuffer(pCharacter,pParserState);pParserState.Pattern=pParserState.ParseTree[pCharacter];pParserState.PatternMatch=true;return true;}else{this.appendOutputBuffer(pCharacter,pParserState);}}return false;}},{key:"executePatternAsync",value:function executePatternAsync(pParserState,pData,fCallback,pDataContext){var _this33=this;// ... this is the end of a pattern, cut off the end tag and parse it.
// Trim the start and end tags off the output buffer now
if(pParserState.Pattern.isAsync){// Run the function
var tmpFunctionContext='ParserContext'in pParserState.Pattern?pParserState.Pattern.ParserContext:false;if(tmpFunctionContext){return pParserState.Pattern.ParseAsync.call(tmpFunctionContext,pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,function(pError,pAsyncOutput){if(pError){_this33.fable.log.info("Precedent ERROR: Async template error happened parsing ".concat(pParserState.Pattern.PatternStart," ... ").concat(pParserState.Pattern.PatternEnd,": ").concat(pError));}pParserState.OutputBuffer=pAsyncOutput;_this33.resetOutputBuffer(pParserState);return fCallback();},pDataContext);}else{return pParserState.Pattern.ParseAsync(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,function(pError,pAsyncOutput){if(pError){_this33.fable.log.info("Precedent ERROR: Async template error happened parsing ".concat(pParserState.Pattern.PatternStart," ... ").concat(pParserState.Pattern.PatternEnd,": ").concat(pError));}pParserState.OutputBuffer=pAsyncOutput;_this33.resetOutputBuffer(pParserState);return fCallback();},pDataContext);}}else{// Run the t*mplate function
var _tmpFunctionContext2='ParserContext'in pParserState.Pattern?pParserState.Pattern.ParserContext:false;if(_tmpFunctionContext2){pParserState.OutputBuffer=pParserState.Pattern.Parse.call(_tmpFunctionContext2,pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}else{pParserState.OutputBuffer=pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData,pDataContext);}this.resetOutputBuffer(pParserState);return fCallback();}}/**
	 * Parse a character in the buffer.
	 * @method parseCharacterAsync
	 * @param {string} pCharacter - The character to append
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @param {Object} pData - The data to pass to the function as a second parameter
	 * @param {function} fCallback - The callback function to call when the parse is complete
	 * @param {array} pDataContext - The history of data objects/context already passed in
	 * @private
	 */},{key:"parseCharacterAsync",value:function parseCharacterAsync(pCharacter,pParserState,pData,fCallback,pDataContext){// If we are already in a pattern match traversal
if(pParserState.PatternMatch){// If the pattern is still matching the start and we haven't passed the buffer
if(!pParserState.StartPatternMatchComplete&&pCharacter in pParserState.Pattern){pParserState.Pattern=pParserState.Pattern[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else if(pParserState.EndPatternMatchBegan){if(pCharacter in pParserState.Pattern.PatternEnd){// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// Flush the output buffer.
this.appendOutputBuffer(pCharacter,pParserState);// If this last character is the end of the pattern, parse it.
if('Parse'in pParserState.Pattern){return this.executePatternAsync(pParserState,pData,fCallback,pDataContext);}}else if(pCharacter in pParserState.PatternStartNode.PatternEnd){// We broke out of the end -- see if this is a new start of the end.
pParserState.Pattern=pParserState.PatternStartNode.PatternEnd[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else{pParserState.EndPatternMatchBegan=false;this.appendOutputBuffer(pCharacter,pParserState);}}else if('PatternEnd'in pParserState.Pattern){if(!pParserState.StartPatternMatchComplete){pParserState.StartPatternMatchComplete=true;pParserState.PatternStartNode=pParserState.Pattern;}this.appendOutputBuffer(pCharacter,pParserState);if(pCharacter in pParserState.Pattern.PatternEnd){// This is the first character of the end pattern.
pParserState.EndPatternMatchBegan=true;// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// If this last character is the end of the pattern, parse it.
if('Parse'in pParserState.Pattern){return this.executePatternAsync(pParserState,pData,fCallback,pDataContext);}}}else{// We are in a pattern start but didn't match one; reset and start trying again from this character.
this.resetOutputBuffer(pParserState);}}// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....
else{// This may be the start of a new pattern....
if(pCharacter in pParserState.ParseTree){// ... assign the root node as the matched node.
this.resetOutputBuffer(pParserState);this.appendOutputBuffer(pCharacter,pParserState);pParserState.Pattern=pParserState.ParseTree[pCharacter];pParserState.PatternMatch=true;}else{this.appendOutputBuffer(pCharacter,pParserState);}}// Without this, templates of all sizes work fine in node.  They do not in the browser.
// Trying this out without the timout on non asynchronous template flips.
return fCallback();}/**
	 * Parse a string for matches, and process any template segments that occur.
	 * @method parseString
	 * @param {string} pString - The string to parse.
	 * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)
	 * @param {Object} pData - The data to pass to the function as a second parameter
	 * @param {function} fCallback - The callback function to call when the parse is complete
	 * @param {array} pDataContext - The history of data objects/context already passed in
	 */},{key:"parseString",value:function parseString(pString,pParseTree,pData,fCallback,pDataContext){var _this34=this;// TODO: There is danger here if a template function attempts to functionally recurse and doesn't pass this in.
var tmpPreviousDataContext=Array.isArray(pDataContext)?pDataContext:[];var tmpDataContext=Array.from(tmpPreviousDataContext);tmpDataContext.push(pData);if(typeof fCallback!=='function'){var tmpParserState=this.newParserState(pParseTree);for(var i=0;i<pString.length;i++){// TODO: This is not fast.
this.parseCharacter(pString[i],tmpParserState,pData,tmpDataContext);}this.flushOutputBuffer(tmpParserState);return tmpParserState.Output;}else{// This is the async mode
var _tmpParserState=this.newParserState(pParseTree);_tmpParserState.Asynchronous=true;var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');var _loop=function _loop(_i23){tmpAnticipate.anticipate(function(fCallback){_this34.parseCharacterAsync(pString[_i23],_tmpParserState,pData,fCallback,tmpDataContext);});};for(var _i23=0;_i23<pString.length;_i23++){_loop(_i23);}tmpAnticipate.wait(function(pError){// Flush the remaining data
_this34.flushOutputBuffer(_tmpParserState);return fCallback(pError,_tmpParserState.Output);});}}}]);}();module.exports=StringParser;},{}],90:[function(require,module,exports){/**
* Word Tree
* @author      Steven Velozo <steven@velozo.com>
* @description Create a tree (directed graph) of Javascript objects, one character per object.
*/var WordTree=/*#__PURE__*/function(){/**
	 * WordTree Constructor
	 */function WordTree(){_classCallCheck2(this,WordTree);this.ParseTree={};}/**
	 * Add a child character to a Parse Tree node
	 * @method addChild
	 * @param {Object} pTree - A parse tree to push the characters into
	 * @param {string} pPattern - The string to add to the tree
	 * @returns {Object} The resulting leaf node that was added (or found)
	 * @private
	 */return _createClass2(WordTree,[{key:"addChild",value:function addChild(pTree,pPattern){if(!(pPattern in pTree)){pTree[pPattern]={};}return pTree[pPattern];}/**
	 * Add a child character to a Parse Tree PatternEnd subtree
	 * @method addChild
	 * @param {Object} pTree - A parse tree to push the characters into
	 * @param {string} pPattern - The string to add to the tree
	 * @returns {Object} The resulting leaf node that was added (or found)
	 * @private
	 */},{key:"addEndChild",value:function addEndChild(pTree,pPattern){if(!('PatternEnd'in pTree)){pTree.PatternEnd={};}pTree.PatternEnd[pPattern]={};return pTree.PatternEnd[pPattern];}/** Add a Pattern to the Parse Tree with both function parameter types
	 * @method addPatternAll
	 * @param {Object} pPatternStart - The starting string for the pattern (e.g. "${")
	 * @param {string} pPatternEnd - The ending string for the pattern (e.g. "}")
	 * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.
	 * @param {function} fParserAsync - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.
	 * @param {Object} pParserContext - The context to pass to the parser function
	 * @return {Object} The leaf parser from the tree
	 */},{key:"addPatternBoth",value:function addPatternBoth(pPatternStart,pPatternEnd,fParser,fParserAsync,pParserContext){if(pPatternStart.length<1){return false;}if(typeof pPatternEnd==='string'&&pPatternEnd.length<1){return false;}var tmpLeaf=this.ParseTree;// Add the tree of leaves iteratively
for(var i=0;i<pPatternStart.length;i++){tmpLeaf=this.addChild(tmpLeaf,pPatternStart[i],i);}if(!('PatternEnd'in tmpLeaf)){tmpLeaf.PatternEnd={};}var tmpPatternEnd=typeof pPatternEnd==='string'?pPatternEnd:pPatternStart;for(var _i24=0;_i24<tmpPatternEnd.length;_i24++){tmpLeaf=this.addEndChild(tmpLeaf,tmpPatternEnd[_i24],_i24);}tmpLeaf.PatternStartString=pPatternStart;tmpLeaf.PatternEndString=tmpPatternEnd;tmpLeaf.Parse=typeof fParser==='function'?fParser:typeof fParser==='string'?function(pHash,pData){return fParser;}:function(pHash,pData){return pHash;};tmpLeaf.ParseAsync=typeof fParserAsync==='function'?fParserAsync:typeof fParserAsync==='string'?function(pHash,pData,fCallback){return fCallback(null,fParserAsync);}:function(pHash,pData,fCallback){return fCallback(null,tmpLeaf.Parse(pHash,pData));};// A "this" for every object
if(pParserContext){tmpLeaf.ParserContext=pParserContext;}tmpLeaf.isAsync=true;return tmpLeaf;}/** Add a Pattern to the Parse Tree with both function parameter types
	 * @method addPatternAll
	 * @param {Object} pPatternStart - The starting string for the pattern (e.g. "${")
	 * @param {string} pPatternEnd - The ending string for the pattern (e.g. "}")
	 * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.
	 * @param {Object} pParserContext - The context to pass to the parser function
	 */},{key:"addPattern",value:function addPattern(pPatternStart,pPatternEnd,fParser,pParserContext){return this.addPatternBoth(pPatternStart,pPatternEnd,fParser,null,pParserContext);}}]);}();module.exports=WordTree;},{}],91:[function(require,module,exports){module.exports={"Metadata":{"UUID":false,"Hash":false,"Name":"","Summary":"","Version":0},"Status":{"Completed":false,"StepCount":0},"Steps":[],"Errors":[],"Log":[]};},{}],92:[function(require,module,exports){var _require5=require('big.js'),PE=_require5.PE;var libFableServiceBase=require('fable-serviceproviderbase');var _OperationStatePrototypeString=JSON.stringify(require('./Fable-Service-Operation-DefaultSettings.js'));var FableOperation=/*#__PURE__*/function(_libFableServiceBase8){function FableOperation(pFable,pOptions,pServiceHash){var _this35;_classCallCheck2(this,FableOperation);_this35=_callSuper(this,FableOperation,[pFable,pOptions,pServiceHash]);// Timestamps will just be the long ints
_this35.timeStamps={};_this35.serviceType='PhasedOperation';_this35.state=JSON.parse(_OperationStatePrototypeString);_this35.stepMap={};_this35.stepFunctions={};// Match the service instantiation to the operation.
_this35.state.Metadata.Hash=_this35.Hash;_this35.state.Metadata.UUID=_this35.UUID;_this35.state.Metadata.Name=typeof _this35.options.Name=='string'?_this35.options.Name:"Unnamed Operation ".concat(_this35.state.Metadata.UUID);_this35.name=_this35.state.Metadata.Name;_this35.progressTrackerSet=_this35.fable.instantiateServiceProviderWithoutRegistration('ProgressTrackerSet');_this35.state.OverallProgressTracker=_this35.progressTrackerSet.createProgressTracker("Overall-".concat(_this35.state.Metadata.UUID));// This is here to use the pass-through logging functions in the operation itself.
_this35.log=_this35;return _this35;}_inherits(FableOperation,_libFableServiceBase8);return _createClass2(FableOperation,[{key:"execute",value:function execute(fExecutionCompleteCallback){var _this36=this;// TODO: Should the same operation be allowed to execute more than one time?
if(this.state.OverallProgressTracker.StartTimeStamp>0){return fExecutionCompleteCallback(new Error("Operation [".concat(this.state.Metadata.UUID,"] ").concat(this.state.Metadata.Name," has already been executed!")));}var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');this.progressTrackerSet.setProgressTrackerTotalOperations(this.state.OverallProgressTracker.Hash,this.state.Status.StepCount);this.progressTrackerSet.startProgressTracker(this.state.OverallProgressTracker.Hash);this.info("Operation [".concat(this.state.Metadata.UUID,"] ").concat(this.state.Metadata.Name," starting..."));var _loop2=function _loop2(i){tmpAnticipate.anticipate(function(fNext){this.fable.log.info("Step #".concat(i," [").concat(this.state.Steps[i].GUIDStep,"] ").concat(this.state.Steps[i].Name," starting..."));this.progressTrackerSet.startProgressTracker(this.state.Steps[i].ProgressTracker.Hash);return fNext();}.bind(_this36));// Steps are executed in a custom context with 
tmpAnticipate.anticipate(_this36.stepFunctions[_this36.state.Steps[i].GUIDStep].bind({log:_this36,fable:_this36.fable,options:_this36.state.Steps[i].Metadata,metadata:_this36.state.Steps[i].Metadata,ProgressTracker:_this36.progressTrackerSet.getProgressTracker(_this36.state.Steps[i].ProgressTracker.Hash),logProgressTrackerStatus:function(){return this.log.info("Step #".concat(i," [").concat(this.state.Steps[i].GUIDStep,"]: ").concat(this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash)));}.bind(_this36),OperationState:_this36.state,StepState:_this36.state.Steps[i]}));tmpAnticipate.anticipate(function(fNext){this.progressTrackerSet.endProgressTracker(this.state.Steps[i].ProgressTracker.Hash);var tmpStepTimingMessage=this.progressTrackerSet.getProgressTrackerStatusString(this.state.Steps[i].ProgressTracker.Hash);this.fable.log.info("Step #".concat(i," [").concat(this.state.Steps[i].GUIDStep,"] ").concat(this.state.Steps[i].Name," complete."));this.fable.log.info("Step #".concat(i," [").concat(this.state.Steps[i].GUIDStep,"] ").concat(this.state.Steps[i].Name," ").concat(tmpStepTimingMessage,"."));this.progressTrackerSet.incrementProgressTracker(this.state.OverallProgressTracker.Hash,1);var tmpOperationTimingMessage=this.progressTrackerSet.getProgressTrackerStatusString(this.state.OverallProgressTracker.Hash);this.fable.log.info("Operation [".concat(this.state.Metadata.UUID,"] ").concat(tmpOperationTimingMessage,"."));return fNext();}.bind(_this36));};for(var i=0;i<this.state.Steps.length;i++){_loop2(i);}// Wait for the anticipation to complete
tmpAnticipate.wait(function(pError){if(pError){_this36.fable.log.error("Operation [".concat(_this36.state.Metadata.UUID,"] ").concat(_this36.state.Metadata.Name," had an error: ").concat(pError),pError);return fExecutionCompleteCallback(pError);}_this36.info("Operation [".concat(_this36.state.Metadata.UUID,"] ").concat(_this36.state.Metadata.Name," complete."));var tmpOperationTimingMessage=_this36.progressTrackerSet.getProgressTrackerStatusString(_this36.state.OverallProgressTracker.Hash);_this36.progressTrackerSet.endProgressTracker(_this36.state.OverallProgressTracker.Hash);_this36.fable.log.info("Operation [".concat(_this36.state.Metadata.UUID,"] ").concat(tmpOperationTimingMessage,"."));return fExecutionCompleteCallback();});}// There are three ways to add steps:
// 1. As a basic javascript function
//    --
//    This is the most basic, java"script" way to add a step.  It will
//    setup a "this" context that has the following properties:
//    - log: A reference to the operation's log object
},{key:"addStep",value:function addStep(fStepFunction,pStepMetadata,pStepName,pStepDescription,pGUIDStep){var tmpStep={};// GUID is optional
tmpStep.GUIDStep=typeof pGUIDStep!=='undefined'?pGUIDStep:"STEP-".concat(this.state.Steps.length,"-").concat(this.fable.DataGeneration.randomNumericString());// Name is optional
tmpStep.Name=typeof pStepName!=='undefined'?pStepName:"Step [".concat(tmpStep.GUIDStep,"]");tmpStep.Description=typeof pStepDescription!=='undefined'?pStepDescription:"Step execution of ".concat(tmpStep.Name,".");tmpStep.ProgressTracker=this.progressTrackerSet.createProgressTracker(tmpStep.GUIDStep);tmpStep.Metadata=_typeof(pStepMetadata)==='object'?pStepMetadata:{};// There is an array of steps, in the Operation State itself ... push a step there
this.state.Steps.push(tmpStep);this.stepMap[tmpStep.GUIDStep]=tmpStep;this.stepFunctions[tmpStep.GUIDStep]=typeof fStepFunction=='function'?fStepFunction:function(fDone){return fDone();};this.state.Status.StepCount++;return tmpStep;}},{key:"setStepTotalOperations",value:function setStepTotalOperations(pGUIDStep,pTotalOperationCount){if(!(pGUIDStep in this.stepMap)){return new Error("Step [".concat(pGUIDStep,"] does not exist in operation [").concat(this.state.Metadata.UUID,"] ").concat(this.state.Metadata.Name," when attempting to set total operations to ").concat(pTotalOperationCount,"."));}this.progressTrackerSet.setProgressTrackerTotalOperations(this.stepMap[pGUIDStep].ProgressTracker.Hash,pTotalOperationCount);}},{key:"writeOperationLog",value:function writeOperationLog(pLogLevel,pLogText,pLogObject){this.state.Log.push("[".concat(new Date().toUTCString(),"]-[").concat(pLogLevel,"]: ").concat(pLogText));if(_typeof(pLogObject)=='object'){this.state.Log.push(JSON.stringify(pLogObject));}}},{key:"writeOperationErrors",value:function writeOperationErrors(pLogText,pLogObject){this.state.Errors.push("".concat(pLogText));if(_typeof(pLogObject)=='object'){this.state.Errors.push(JSON.stringify(pLogObject));}}},{key:"trace",value:function trace(pLogText,pLogObject){this.writeOperationLog('TRACE',pLogText,pLogObject);this.fable.log.trace(pLogText,pLogObject);}},{key:"debug",value:function debug(pLogText,pLogObject){this.writeOperationLog('DEBUG',pLogText,pLogObject);this.fable.log.debug(pLogText,pLogObject);}},{key:"info",value:function info(pLogText,pLogObject){this.writeOperationLog('INFO',pLogText,pLogObject);this.fable.log.info(pLogText,pLogObject);}},{key:"warn",value:function warn(pLogText,pLogObject){this.writeOperationLog('WARN',pLogText,pLogObject);this.fable.log.warn(pLogText,pLogObject);}},{key:"error",value:function error(pLogText,pLogObject){this.writeOperationLog('ERROR',pLogText,pLogObject);this.writeOperationErrors(pLogText,pLogObject);this.fable.log.error(pLogText,pLogObject);}},{key:"fatal",value:function fatal(pLogText,pLogObject){this.writeOperationLog('FATAL',pLogText,pLogObject);this.writeOperationErrors(pLogText,pLogObject);this.fable.log.fatal(pLogText,pLogObject);}}]);}(libFableServiceBase);module.exports=FableOperation;},{"./Fable-Service-Operation-DefaultSettings.js":91,"big.js":17,"fable-serviceproviderbase":59}],93:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var FableServiceProgressTime=/*#__PURE__*/function(_libFableServiceBase9){function FableServiceProgressTime(pFable,pOptions,pServiceHash){var _this37;_classCallCheck2(this,FableServiceProgressTime);_this37=_callSuper(this,FableServiceProgressTime,[pFable,pOptions,pServiceHash]);_this37.serviceType='ProgressTime';_this37.timeStamps={};return _this37;}_inherits(FableServiceProgressTime,_libFableServiceBase9);return _createClass2(FableServiceProgressTime,[{key:"formatTimeDuration",value:function formatTimeDuration(pTimeDurationInMilliseconds){var tmpTimeDuration=typeof pTimeDurationInMilliseconds=='number'?pTimeDurationInMilliseconds:0;if(pTimeDurationInMilliseconds<0){return'unknown';}var tmpTimeDurationString='';if(tmpTimeDuration>3600000){tmpTimeDurationString+=Math.floor(tmpTimeDuration/3600000)+'h ';tmpTimeDuration=tmpTimeDuration%3600000;}if(tmpTimeDuration>60000){tmpTimeDurationString+=Math.floor(tmpTimeDuration/60000)+'m ';tmpTimeDuration=tmpTimeDuration%60000;}if(tmpTimeDuration>1000){tmpTimeDurationString+=Math.floor(tmpTimeDuration/1000)+'s ';tmpTimeDuration=tmpTimeDuration%1000;}tmpTimeDurationString+=Math.round(tmpTimeDuration)+'ms';return tmpTimeDurationString;}},{key:"createTimeStamp",value:function createTimeStamp(pTimeStampHash){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';this.timeStamps[tmpTimeStampHash]=+new Date();return this.timeStamps[tmpTimeStampHash];}},{key:"getTimeStampValue",value:function getTimeStampValue(pTimeStampHash){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';return tmpTimeStampHash in this.timeStamps?this.timeStamps[tmpTimeStampHash]:-1;}},{key:"updateTimeStampValue",value:function updateTimeStampValue(pTimeStampHash,pReferenceTime){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';var tmpReferenceTime=false;// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.
if(typeof pReferenceTime=='string'){tmpReferenceTime=tmpReference in this.timeStamps?this.timeStamps[tmpReference]:false;}else if(typeof pReferenceTime=='number'){tmpReferenceTime=pReferenceTime;}else{tmpReferenceTime=+new Date();}if(tmpTimeStampHash in this.timeStamps&&tmpReferenceTime){this.timeStamps[tmpTimeStampHash]=tmpReferenceTime;return this.timeStamps[tmpTimeStampHash];}else{return-1;}}},{key:"removeTimeStamp",value:function removeTimeStamp(pTimeStampHash){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';if(tmpTimeStampHash in this.timeStamps){delete this.timeStamps[tmpTimeStampHash];return true;}else{return false;}}},{key:"getTimeStampDelta",value:function getTimeStampDelta(pTimeStampHash,pReferenceTime){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';var tmpReferenceTime=false;// This function allows the user to pass in either a reference time in ms, or, a hash of a timestamp.
if(typeof pReferenceTime=='string'){tmpReferenceTime=tmpReference in this.timeStamps?this.timeStamps[tmpReference]:false;}else if(typeof pReferenceTime=='number'){tmpReferenceTime=pReferenceTime;}else{tmpReferenceTime=+new Date();}if(tmpTimeStampHash in this.timeStamps&&tmpReferenceTime){return tmpReferenceTime-this.timeStamps[tmpTimeStampHash];}else{return-1;}}},{key:"getDurationBetweenTimestamps",value:function getDurationBetweenTimestamps(pTimeStampHashStart,pTimeStampHashEnd){var tmpTimeStampHashStart=typeof pTimeStampHashStart=='string'?pTimeStampHashStart:'Default';var tmpTimeStampHashEnd=typeof pTimeStampHashEnd=='string'?pTimeStampHashEnd:'Default';if(tmpTimeStampHashStart in this.timeStamps&&tmpTimeStampHashEnd in this.timeStamps){return this.timeStamps[tmpTimeStampHashEnd]-this.timeStamps[tmpTimeStampHashStart];}else{return-1;}}},{key:"getTimeStampDeltaMessage",value:function getTimeStampDeltaMessage(pTimeStampHash,pMessage,pReferenceTime){var tmpTimeStampHash=typeof pTimeStampHash=='string'?pTimeStampHash:'Default';var tmpMessage=typeof pMessage!=='undefined'?pMessage:"Elapsed for ".concat(tmpTimeStampHash,": ");var tmpOperationTime=this.getTimeStampDelta(tmpTimeStampHash,pReferenceTime);return"".concat(tmpMessage," ").concat(this.formatTimeDuration(tmpOperationTime));}},{key:"logTimeStampDelta",value:function logTimeStampDelta(pTimeStampHash,pMessage,pReferenceTime){this.fable.log.info(this.getTimeStampDeltaMessage(pTimeStampHash,pMessage,pReferenceTime));}}]);}(libFableServiceBase);module.exports=FableServiceProgressTime;},{"fable-serviceproviderbase":59}],94:[function(require,module,exports){var ProgressTracker=/*#__PURE__*/function(){function ProgressTracker(pProgressTrackerSet,pProgressTrackerHash){_classCallCheck2(this,ProgressTracker);this.progressTrackerSet=pProgressTrackerSet;this.progressTrackerHash=pProgressTrackerHash;this.data=this.progressTrackerSet.getProgressTrackerData(this.progressTrackerHash);}return _createClass2(ProgressTracker,[{key:"updateProgressTracker",value:function updateProgressTracker(pProgressAmount){return this.progressTrackerSet.updateProgressTracker(this.progressTrackerHash,pProgressAmount);}},{key:"incrementProgressTracker",value:function incrementProgressTracker(pProgressIncrementAmount){return this.progressTrackerSet.incrementProgressTracker(this.progressTrackerHash,pProgressIncrementAmount);}},{key:"setProgressTrackerTotalOperations",value:function setProgressTrackerTotalOperations(pTotalOperationCount){return this.progressTrackerSet.setProgressTrackerTotalOperations(this.progressTrackerHash,pTotalOperationCount);}},{key:"getProgressTrackerStatusString",value:function getProgressTrackerStatusString(){return this.progressTrackerSet.getProgressTrackerStatusString(this.progressTrackerHash);}}]);}();module.exports=ProgressTracker;},{}],95:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var libProgressTrackerClass=require('./Fable-Service-ProgressTracker/ProgressTracker.js');var FableServiceProgressTrackerSet=/*#__PURE__*/function(_libFableServiceBase10){function FableServiceProgressTrackerSet(pFable,pOptions,pServiceHash){var _this38;_classCallCheck2(this,FableServiceProgressTrackerSet);_this38=_callSuper(this,FableServiceProgressTrackerSet,[pFable,pOptions,pServiceHash]);_this38.serviceType='ProgressTrackerSet';_this38.progressTrackers={};// Create an internal PorgressTime service to track timestamps
_this38.progressTimes=_this38.fable.instantiateServiceProviderWithoutRegistration('ProgressTime');// This timestamp is used and updated by *all* progress trackers.
_this38.progressTimes.createTimeStamp('CurrentTime');return _this38;}_inherits(FableServiceProgressTrackerSet,_libFableServiceBase10);return _createClass2(FableServiceProgressTrackerSet,[{key:"getProgressTracker",value:function getProgressTracker(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.warn("ProgressTracker ".concat(tmpProgressTrackerHash," does not exist!  Creating a new tracker..."));this.createProgressTracker(tmpProgressTrackerHash,100);}return new libProgressTrackerClass(this,pProgressTrackerHash);}},{key:"getProgressTrackerData",value:function getProgressTrackerData(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.warn("ProgressTracker ".concat(tmpProgressTrackerHash," does not exist!  Creating a new tracker..."));this.createProgressTracker(tmpProgressTrackerHash,100);}return this.progressTrackers[tmpProgressTrackerHash];}},{key:"createProgressTracker",value:function createProgressTracker(pProgressTrackerHash,pTotalOperations){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';var tmpTotalOperations=typeof pTotalOperations=='number'?pTotalOperations:100;var tmpProgressTracker={Hash:tmpProgressTrackerHash,StartTimeHash:"".concat(tmpProgressTrackerHash,"-Start"),StartTimeStamp:-1,CurrentTimeStamp:-1,EndTimeHash:"".concat(tmpProgressTrackerHash,"-End"),EndTimeStamp:-1,PercentComplete:-1,// If this is set to true, PercentComplete will be calculated as CurrentCount / TotalCount even if it goes over 100%
AllowTruePercentComplete:false,ElapsedTime:-1,AverageOperationTime:-1,EstimatedCompletionTime:-1,TotalCount:tmpTotalOperations,CurrentCount:-1};if(tmpProgressTrackerHash in this.progressTrackers){this.fable.log.warn("ProgressTracker ".concat(tmpProgressTrackerHash," already exists!  Overwriting with a new tracker..."));this.progressTimes.removeTimeStamp(tmpProgressTracker.StartTimeHash);this.progressTimes.removeTimeStamp(tmpProgressTracker.EndTimeHash);}this.progressTrackers[tmpProgressTrackerHash]=tmpProgressTracker;return tmpProgressTracker;}},{key:"setProgressTrackerTotalOperations",value:function setProgressTrackerTotalOperations(pProgressTrackerHash,pTotalOperations){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';var tmpTotalOperations=typeof pTotalOperations=='number'?pTotalOperations:100;if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.warn("Attempted to set the total operations of ProgressTracker ".concat(tmpProgressTrackerHash," but it does not exist!  Creating a new tracker..."));this.createProgressTracker(tmpProgressTrackerHash,tmpTotalOperations);}this.progressTrackers[tmpProgressTrackerHash].TotalCount=tmpTotalOperations;return this.progressTrackers[tmpProgressTrackerHash];}},{key:"startProgressTracker",value:function startProgressTracker(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';// This is the only method to lazily create ProgressTrackers now
if(!(tmpProgressTrackerHash in this.progressTrackers)){this.createProgressTracker(tmpProgressTrackerHash,100);}var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];this.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);tmpProgressTracker.StartTimeStamp=this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].StartTimeHash);if(tmpProgressTracker.CurrentCount<0){tmpProgressTracker.CurrentCount=0;}return this.solveProgressTrackerStatus(tmpProgressTrackerHash);}},{key:"endProgressTracker",value:function endProgressTracker(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.error("Attempted to end ProgressTracker ".concat(tmpProgressTrackerHash," that does not exist!"));return false;}var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];this.progressTimes.createTimeStamp(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);tmpProgressTracker.EndTimeStamp=this.progressTimes.getTimeStampValue(this.progressTrackers[tmpProgressTrackerHash].EndTimeHash);return this.solveProgressTrackerStatus(tmpProgressTrackerHash);}},{key:"solveProgressTrackerStatus",value:function solveProgressTrackerStatus(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.error("Attempted to solve ProgressTracker ".concat(tmpProgressTrackerHash," that does not exist!"));return false;}var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];if(tmpProgressTracker.TotalCount<1||isNaN(tmpProgressTracker.TotalCount)){this.fable.log.error("ProgressTracker ".concat(tmpProgressTracker.Hash," has an invalid total count of operations (").concat(tmpProgressTracker.TotalCount,"!  Setting it to the default of 100..."));tmpProgressTracker.TotalCount=100;}// Compute the percentage of progress that is complete.
if(tmpProgressTracker.CurrentCount<1){tmpProgressTracker.PercentComplete=0;}else{tmpProgressTracker.PercentComplete=tmpProgressTracker.CurrentCount/tmpProgressTracker.TotalCount*100.0;}if(!tmpProgressTracker.AllowTruePercentComplete&&tmpProgressTracker.PercentComplete>100){tmpProgressTracker.PercentComplete=100;}// Compute the average time per operation
this.progressTimes.updateTimeStampValue('CurrentTime');tmpProgressTracker.CurrentTimeStamp=this.progressTimes.getTimeStampValue('CurrentTime');tmpProgressTracker.ElapsedTime=tmpProgressTracker.CurrentTimeStamp-tmpProgressTracker.StartTimeStamp;if(tmpProgressTracker.EndTimeStamp>0){tmpProgressTracker.ElapsedTime=tmpProgressTracker.EndTimeStamp-tmpProgressTracker.StartTimeStamp;}if(tmpProgressTracker.CurrentCount>0){tmpProgressTracker.AverageOperationTime=(tmpProgressTracker.CurrentTimeStamp-tmpProgressTracker.StartTimeStamp)/tmpProgressTracker.CurrentCount;}else{tmpProgressTracker.AverageOperationTime=-1;}// Compute the estimated completion
if(tmpProgressTracker.AverageOperationTime>0){tmpProgressTracker.EstimatedCompletionTime=Math.max(tmpProgressTracker.TotalCount-tmpProgressTracker.CurrentCount,0)*tmpProgressTracker.AverageOperationTime;}else{tmpProgressTracker.EstimatedCompletionTime=-1;}return tmpProgressTracker;}},{key:"updateProgressTracker",value:function updateProgressTracker(pProgressTrackerHash,pCurrentOperations){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';var tmpCurrentOperations=parseInt(pCurrentOperations);if(isNaN(tmpCurrentOperations)){this.fable.log.warn("Attempted to update ProgressTracker ".concat(tmpProgressTrackerHash," with an invalid number of operations!"));return false;}if(!(tmpProgressTrackerHash in this.progressTrackers)){this.createProgressTracker(100,tmpProgressTrackerHash);}this.progressTrackers[tmpProgressTrackerHash].CurrentCount=tmpCurrentOperations;return this.solveProgressTrackerStatus(tmpProgressTrackerHash);}},{key:"incrementProgressTracker",value:function incrementProgressTracker(pProgressTrackerHash,pOperationIncrementAmount){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';var tmpOperationIncrementAmount=parseInt(pOperationIncrementAmount);if(isNaN(tmpOperationIncrementAmount)){tmpOperationIncrementAmount=1;}if(!(tmpProgressTrackerHash in this.progressTrackers)){this.fable.log.warn("Attempted to increment ProgressTracker ".concat(tmpProgressTrackerHash," but it did not exist."));return false;}if(this.progressTrackers[tmpProgressTrackerHash].StartTimeStamp<1){this.fable.log.warn("Attempted to increment ProgressTracker ".concat(tmpProgressTrackerHash," but it was not started.. starting now."));this.startProgressTracker(tmpProgressTrackerHash);}this.progressTrackers[tmpProgressTrackerHash].CurrentCount=this.progressTrackers[tmpProgressTrackerHash].CurrentCount+tmpOperationIncrementAmount;return this.solveProgressTrackerStatus(tmpProgressTrackerHash);}},{key:"getProgressTrackerCompletedOperationCountString",value:function getProgressTrackerCompletedOperationCountString(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';// This call here can mean if we add operations and then immediately get the string, this function runs twice.
var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];// The states of a progress tracker:
if(tmpProgressTracker.CurrentCount<0){return"none";}else if(tmpProgressTracker.CurrentCount<1){return"0";}else{return"".concat(tmpProgressTracker.CurrentCount);}}},{key:"getProgressTrackerPercentCompleteString",value:function getProgressTrackerPercentCompleteString(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';// This call here can mean if we add operations and then immediately get the string, this function runs twice.
// TODO: Is there a pattern to avoid this double call that's worth putting in?
this.solveProgressTrackerStatus(tmpProgressTrackerHash);if(!(tmpProgressTrackerHash in this.progressTrackers)){return"ProgressTracker ".concat(tmpProgressTrackerHash," does not exist!  No stats to display.");}else{var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];// The states of a progress tracker:
// 1. Not started
if(tmpProgressTracker.StartTimeStamp<1){return"0%";}// 2. Started, but no operations completed
if(tmpProgressTracker.CurrentCount<1){return"0%";}// 3. Started, some operations completed
else if(tmpProgressTracker.EndTimeStamp<1){return"".concat(tmpProgressTracker.PercentComplete.toFixed(3),"%");}// 4. Done
else{return"".concat(tmpProgressTracker.PercentComplete.toFixed(3),"%");}}}},{key:"getProgressTrackerStatusString",value:function getProgressTrackerStatusString(pProgressTrackerHash){var tmpProgressTrackerHash=typeof pProgressTrackerHash=='string'?pProgressTrackerHash:'Default';// This call here can mean if we add operations and then immediately get the string, this function runs twice.
// TODO: Is there a pattern to avoid this double call that's worth putting in?
this.solveProgressTrackerStatus(tmpProgressTrackerHash);if(!(tmpProgressTrackerHash in this.progressTrackers)){return"ProgressTracker ".concat(tmpProgressTrackerHash," does not exist!  No stats to display.");}else{var tmpProgressTracker=this.progressTrackers[tmpProgressTrackerHash];// The states of a progress tracker:
// 1. Not started
if(tmpProgressTracker.StartTimeStamp<1){return"ProgressTracker ".concat(tmpProgressTracker.Hash," has not been started yet.");}// 2. Started, but no operations completed
if(tmpProgressTracker.CurrentCount<1&&tmpProgressTracker.EndTimeStamp<1){return"ProgressTracker ".concat(tmpProgressTracker.Hash," has no completed operations.  ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)," have elapsed since it was started.");}// 3. Started, some operations completed
else if(tmpProgressTracker.EndTimeStamp<1){return"ProgressTracker ".concat(tmpProgressTracker.Hash," is ").concat(tmpProgressTracker.PercentComplete.toFixed(3),"% completed - ").concat(tmpProgressTracker.CurrentCount," / ").concat(tmpProgressTracker.TotalCount," operations over ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)," (median ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)," per).  Estimated completion: ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.EstimatedCompletionTime));}// 4. Done
else{return"ProgressTracker ".concat(tmpProgressTracker.Hash," is done.  ").concat(tmpProgressTracker.CurrentCount," / ").concat(tmpProgressTracker.TotalCount," operations were completed in ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.ElapsedTime)," (median ").concat(this.progressTimes.formatTimeDuration(tmpProgressTracker.AverageOperationTime)," per).");}}}},{key:"logProgressTrackerStatus",value:function logProgressTrackerStatus(pProgressTrackerHash){this.fable.log.info(this.getProgressTrackerStatusString(pProgressTrackerHash));}}]);}(libFableServiceBase);module.exports=FableServiceProgressTrackerSet;},{"./Fable-Service-ProgressTracker/ProgressTracker.js":94,"fable-serviceproviderbase":59}],96:[function(require,module,exports){(function(Buffer){(function(){var libFableServiceBase=require('fable-serviceproviderbase');var libSimpleGet=require('simple-get');var libCookie=require('cookie');var FableServiceRestClient=/*#__PURE__*/function(_libFableServiceBase11){function FableServiceRestClient(pFable,pOptions,pServiceHash){var _this39;_classCallCheck2(this,FableServiceRestClient);_this39=_callSuper(this,FableServiceRestClient,[pFable,pOptions,pServiceHash]);_this39.TraceLog=false;if(_this39.options.TraceLog||_this39.fable.TraceLog){_this39.TraceLog=true;}_this39.dataFormat=_this39.fable.services.DataFormat;_this39.serviceType='RestClient';_this39.cookie=false;// This is a function that can be overridden, to allow the management
// of the request options before they are passed to the request library.
_this39.prepareRequestOptions=function(pOptions){return pOptions;};return _this39;}_inherits(FableServiceRestClient,_libFableServiceBase11);return _createClass2(FableServiceRestClient,[{key:"simpleGet",get:function get(){return libSimpleGet;}},{key:"prepareCookies",value:function prepareCookies(pRequestOptions){if(this.cookie){var tmpCookieObject=this.cookie;if(!('headers'in pRequestOptions)){pRequestOptions.headers={};}var tmpCookieKeys=Object.keys(tmpCookieObject);if(tmpCookieKeys.length>0){// Only grab the first for now.
pRequestOptions.headers.cookie=libCookie.serialize(tmpCookieKeys[0],tmpCookieObject[tmpCookieKeys[0]]);}}return pRequestOptions;}},{key:"preRequest",value:function preRequest(pOptions){// Validate the options object
var tmpOptions=this.prepareCookies(pOptions);// Prepend a string to the URL if it exists in the Fable Config
if('RestClientURLPrefix'in this.fable.settings){tmpOptions.url=this.fable.settings.RestClientURLPrefix+tmpOptions.url;}return this.prepareRequestOptions(tmpOptions);}},{key:"executeChunkedRequest",value:function executeChunkedRequest(pOptions,fCallback){var _this40=this;var tmpOptions=this.preRequest(pOptions);tmpOptions.RequestStartTime=this.fable.log.getTimeStamp();if(this.TraceLog){this.fable.log.debug("Beginning ".concat(tmpOptions.method," request to ").concat(tmpOptions.url," at ").concat(tmpOptions.RequestStartTime));}return libSimpleGet(tmpOptions,function(pError,pResponse){if(pError){return fCallback(pError,pResponse);}if(_this40.TraceLog){var tmpConnectTime=_this40.fable.log.getTimeStamp();_this40.fable.log.debug("--> ".concat(tmpOptions.method," connected in ").concat(_this40.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpConnectTime),"ms code ").concat(pResponse.statusCode));}var tmpData='';pResponse.on('data',function(pChunk){// For JSON, the chunk is the serialized object.
if(_this40.TraceLog){var tmpChunkTime=_this40.fable.log.getTimeStamp();_this40.fable.log.debug("--> ".concat(tmpOptions.method," data chunk size ").concat(pChunk.length,"b received in ").concat(_this40.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpChunkTime),"ms"));}tmpData+=pChunk;});pResponse.on('end',function(){if(_this40.TraceLog){var tmpCompletionTime=_this40.fable.log.getTimeStamp();_this40.fable.log.debug("==> ".concat(tmpOptions.method," completed data size ").concat(tmpData.length,"b received in ").concat(_this40.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpCompletionTime),"ms"));}return fCallback(pError,pResponse,tmpData);});});}},{key:"executeChunkedRequestBinary",value:function executeChunkedRequestBinary(pOptions,fCallback){var _this41=this;var tmpOptions=this.preRequest(pOptions);tmpOptions.RequestStartTime=this.fable.log.getTimeStamp();if(this.TraceLog){this.fable.log.debug("Beginning ".concat(tmpOptions.method," request to ").concat(tmpOptions.url," at ").concat(tmpOptions.RequestStartTime));}tmpOptions.json=false;tmpOptions.encoding=null;return libSimpleGet(tmpOptions,function(pError,pResponse){if(pError){return fCallback(pError,pResponse);}if(_this41.TraceLog){var tmpConnectTime=_this41.fable.log.getTimeStamp();_this41.fable.log.debug("--> ".concat(tmpOptions.method," connected in ").concat(_this41.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpConnectTime),"ms code ").concat(pResponse.statusCode));}var tmpDataBuffer=false;pResponse.on('data',function(pChunk){// For JSON, the chunk is the serialized object.
if(_this41.TraceLog){var tmpChunkTime=_this41.fable.log.getTimeStamp();_this41.fable.log.debug("--> ".concat(tmpOptions.method," data chunk size ").concat(pChunk.length,"b received in ").concat(_this41.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpChunkTime),"ms"));}// TODO: Potentially create a third option that streams this to a file?  So it doesn't have to hold it all in memory.
if(!tmpDataBuffer){tmpDataBuffer=Buffer.from(pChunk);}else{tmpDataBuffer=Buffer.concat([tmpDataBuffer,pChunk]);}});pResponse.on('end',function(){if(_this41.TraceLog){var tmpCompletionTime=_this41.fable.log.getTimeStamp();_this41.fable.log.debug("==> ".concat(tmpOptions.method," completed data size ").concat(tmpDataBuffer.length,"b received in ").concat(_this41.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpCompletionTime),"ms"));}return fCallback(pError,pResponse,tmpDataBuffer);});});}},{key:"executeJSONRequest",value:function executeJSONRequest(pOptions,fCallback){var _this42=this;pOptions.json=true;var tmpOptions=this.preRequest(pOptions);if(!('headers'in tmpOptions)){tmpOptions.headers={};}/* Automated headers break some APIs
		if (!('Content-Type' in tmpOptions.headers))
		{
			tmpOptions.headers['Content-Type'] = 'application/json';
		}
		*/tmpOptions.RequestStartTime=this.fable.log.getTimeStamp();if(this.TraceLog){this.fable.log.debug("Beginning ".concat(tmpOptions.method," JSON request to ").concat(tmpOptions.url," at ").concat(tmpOptions.RequestStartTime));}return libSimpleGet(tmpOptions,function(pError,pResponse){if(pError){return fCallback(pError,pResponse);}if(_this42.TraceLog){var tmpConnectTime=_this42.fable.log.getTimeStamp();_this42.fable.log.debug("--> JSON ".concat(tmpOptions.method," connected in ").concat(_this42.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpConnectTime),"ms code ").concat(pResponse.statusCode));}var tmpJSONData='';pResponse.on('data',function(pChunk){if(_this42.TraceLog){var tmpChunkTime=_this42.fable.log.getTimeStamp();_this42.fable.log.debug("--> JSON ".concat(tmpOptions.method," data chunk size ").concat(pChunk.length,"b received in ").concat(_this42.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpChunkTime),"ms"));}tmpJSONData+=pChunk;});pResponse.on('end',function(){if(_this42.TraceLog){var tmpCompletionTime=_this42.fable.log.getTimeStamp();_this42.fable.log.debug("==> JSON ".concat(tmpOptions.method," completed - received in ").concat(_this42.dataFormat.formatTimeDelta(tmpOptions.RequestStartTime,tmpCompletionTime),"ms"));}return fCallback(pError,pResponse,JSON.parse(tmpJSONData));});});}},{key:"getJSON",value:function getJSON(pOptionsOrURL,fCallback){var tmpRequestOptions=_typeof(pOptionsOrURL)=='object'?pOptionsOrURL:{};if(typeof pOptionsOrURL=='string'){tmpRequestOptions.url=pOptionsOrURL;}tmpRequestOptions.method='GET';return this.executeJSONRequest(tmpRequestOptions,fCallback);}},{key:"putJSON",value:function putJSON(pOptions,fCallback){if(_typeof(pOptions.body)!='object'){return fCallback(new Error("PUT JSON Error Invalid options object"));}pOptions.method='PUT';return this.executeJSONRequest(pOptions,fCallback);}},{key:"postJSON",value:function postJSON(pOptions,fCallback){if(_typeof(pOptions.body)!='object'){return fCallback(new Error("POST JSON Error Invalid options object"));}pOptions.method='POST';return this.executeJSONRequest(pOptions,fCallback);}},{key:"patchJSON",value:function patchJSON(pOptions,fCallback){if(_typeof(pOptions.body)!='object'){return fCallback(new Error("PATCH JSON Error Invalid options object"));}pOptions.method='PATCH';return this.executeJSONRequest(pOptions,fCallback);}},{key:"headJSON",value:function headJSON(pOptions,fCallback){if(_typeof(pOptions.body)!='object'){return fCallback(new Error("HEAD JSON Error Invalid options object"));}pOptions.method='HEAD';return this.executeJSONRequest(pOptions,fCallback);}},{key:"delJSON",value:function delJSON(pOptions,fCallback){pOptions.method='DELETE';return this.executeJSONRequest(pOptions,fCallback);}},{key:"getRawText",value:function getRawText(pOptionsOrURL,fCallback){var tmpRequestOptions=_typeof(pOptionsOrURL)=='object'?pOptionsOrURL:{};if(typeof pOptionsOrURL=='string'){tmpRequestOptions.url=pOptionsOrURL;}tmpRequestOptions.method='GET';return this.executeChunkedRequest(tmpRequestOptions,fCallback);}}]);}(libFableServiceBase);module.exports=FableServiceRestClient;}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":20,"cookie":31,"fable-serviceproviderbase":59,"simple-get":163}],97:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var FableServiceTemplate=/*#__PURE__*/function(_libFableServiceBase12){// Underscore and lodash have a behavior, _.template, which compiles a
// string-based template with code snippets into simple executable pieces,
// with the added twist of returning a precompiled function ready to go.
//
// NOTE: This does not implement underscore escape expressions
// NOTE: This does not implement underscore magic browser variable assignment
//
// This is an implementation of that.
// TODO: Make this use precedent, add configuration, add debugging.
function FableServiceTemplate(pFable,pOptions,pServiceHash){var _this43;_classCallCheck2(this,FableServiceTemplate);_this43=_callSuper(this,FableServiceTemplate,[pFable,pOptions,pServiceHash]);_this43.serviceType='Template';// These are the exact regex's used in lodash/underscore
// TODO: Switch this to precedent
_this43.Matchers={Evaluate:/<%([\s\S]+?)%>/g,Interpolate:/<%=([\s\S]+?)%>/g,Escaper:/\\|'|\r|\n|\t|\u2028|\u2029/g,Unescaper:/\\(\\|'|r|n|t|u2028|u2029)/g,// This is how underscore does it, so we are keeping it for now.
GuaranteedNonMatch:/.^/};// This is a helper for the escaper and unescaper functions.
// Right now we are going to keep what underscore is doing, but, not forever.
_this43.templateEscapes={'\\':'\\',"'":"'",'r':'\r','\r':'r','n':'\n','\n':'n','t':'\t','\t':'t','u2028':"\u2028","\u2028":'u2028','u2029':"\u2029","\u2029":'u2029'};// This is defined as such to underscore that it is a dynamic programming
// function on this class.
_this43.renderFunction=false;_this43.templateString=false;return _this43;}_inherits(FableServiceTemplate,_libFableServiceBase12);return _createClass2(FableServiceTemplate,[{key:"renderTemplate",value:function renderTemplate(pData){return this.renderFunction(pData);}},{key:"templateFunction",value:function templateFunction(){var fRenderTemplateBound=this.renderTemplate.bind(this);return fRenderTemplateBound;}},{key:"buildTemplateFunction",value:function buildTemplateFunction(pTemplateText,pData){var _this44=this;// For now this is being kept in a weird form ... this is to mimic the old
// underscore code until this is rewritten using precedent.
this.TemplateSource="__p+='"+pTemplateText.replace(this.Matchers.Escaper,function(pMatch){return"\\".concat(_this44.templateEscapes[pMatch]);}).replace(this.Matchers.Interpolate||this.Matchers.GuaranteedNonMatch,function(pMatch,pCode){return"'+\n(".concat(decodeURIComponent(pCode),")+\n'");}).replace(this.Matchers.Evaluate||this.Matchers.GuaranteedNonMatch,function(pMatch,pCode){return"';\n".concat(decodeURIComponent(pCode),"\n;__p+='");})+"';\n";this.TemplateSource="with(pTemplateDataObject||{}){\n".concat(this.TemplateSource,"}\n");this.TemplateSource="var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n".concat(this.TemplateSource,"return __p;\n");this.renderFunction=new Function('pTemplateDataObject',this.TemplateSource);if(typeof pData!='undefined'){return this.renderFunction(pData);}// Provide the compiled function source as a convenience for build time
// precompilation.
this.TemplateSourceCompiled='function(obj){\n'+this.TemplateSource+'}';return this.templateFunction();}}]);}(libFableServiceBase);module.exports=FableServiceTemplate;},{"fable-serviceproviderbase":59}],98:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');// TODO: These are still pretty big -- consider the smaller polyfills
var libAsyncWaterfall=require('async.waterfall');var libAsyncEachLimit=require('async.eachlimit');var libBigNumber=require('big.js');var FableServiceUtility=/*#__PURE__*/function(_libFableServiceBase13){// Underscore and lodash have a behavior, _.template, which compiles a
// string-based template with code snippets into simple executable pieces,
// with the added twist of returning a precompiled function ready to go.
//
// NOTE: This does not implement underscore escape expressions
// NOTE: This does not implement underscore magic browser variable assignment
//
// This is an implementation of that.
// TODO: Make this use precedent, add configuration, add debugging.
function FableServiceUtility(pFable,pOptions,pServiceHash){var _this45;_classCallCheck2(this,FableServiceUtility);_this45=_callSuper(this,FableServiceUtility,[pFable,pOptions,pServiceHash]);_this45.templates={};// These two functions are used extensively throughout
_this45.waterfall=libAsyncWaterfall;_this45.eachLimit=libAsyncEachLimit;_this45.bigNumber=libBigNumber;return _this45;}// Underscore and lodash have a behavior, _.extend, which merges objects.
// Now that es6 gives us this, use the native thingy.
// Nevermind, the native thing is not stable enough across environments
// Basic shallow copy
_inherits(FableServiceUtility,_libFableServiceBase13);return _createClass2(FableServiceUtility,[{key:"extend",value:function extend(pDestinationObject){for(var i=0;i<(arguments.length<=1?0:arguments.length-1);i++){var tmpSourceObject=i+1<1||arguments.length<=i+1?undefined:arguments[i+1];if(_typeof(tmpSourceObject)==='object'){var tmpObjectProperties=Object.keys(tmpSourceObject);for(var k=0;k<tmpObjectProperties.length;k++){pDestinationObject[tmpObjectProperties[k]]=tmpSourceObject[tmpObjectProperties[k]];}}}return pDestinationObject;}// Underscore and lodash have a behavior, _.template, which compiles a
// string-based template with code snippets into simple executable pieces,
// with the added twist of returning a precompiled function ready to go.
},{key:"template",value:function template(pTemplateText,pData){var tmpTemplate=this.fable.instantiateServiceProviderWithoutRegistration('Template');return tmpTemplate.buildTemplateFunction(pTemplateText,pData);}// Build a template function from a template hash, and, register it with the service provider
},{key:"buildHashedTemplate",value:function buildHashedTemplate(pTemplateHash,pTemplateText,pData){var tmpTemplate=this.fable.instantiateServiceProvider('Template',{},pTemplateHash);this.templates[pTemplateHash]=tmpTemplate.buildTemplateFunction(pTemplateText,pData);return this.templates[pTemplateHash];}// This is a safe, modern version of chunk from underscore
// Algorithm pulled from a mix of these two polyfills:
// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk
// https://youmightnotneed.com/lodash
// This implementation was most tolerant in browsers.  Uglify can fix the rest.
},{key:"chunk",value:function chunk(pInput,pChunkSize,pChunkCache){var tmpInputArray=_toConsumableArray(pInput);// Note lodash defaults to 1, underscore defaults to 0
var tmpChunkSize=typeof pChunkSize=='number'?pChunkSize:0;var tmpChunkCache=typeof pChunkCache!='undefined'?pChunkCache:[];if(tmpChunkSize<=0){return tmpChunkCache;}while(tmpInputArray.length){tmpChunkCache.push(tmpInputArray.splice(0,tmpChunkSize));}return tmpChunkCache;}/**
	 * Get a value from fable/pict by hash/address
	 * @param {string} pValueAddress - The manyfest hash/address of the value to get
	 */},{key:"getValue",value:function getValue(pValueAddress){// Lazily create a manifest if it doesn't exist
if(!this.manifest){this.manifest=this.fable.newManyfest();}// Get the value from the internal manifest and return it
return this.manifest.getValueByHash(this.fable,pValueAddress);}/**
	 * Check if a value is null or empty
	 * @param {object} pObject - The object to check
	 * @param {string} pValueAddress - The manyfest hash/address to check
	 */},{key:"addressIsNullOrEmpty",value:function addressIsNullOrEmpty(pObject,pValueAddress){// Lazily create a manifest if it doesn't exist
if(!this.manifest){this.manifest=this.fable.newManyfest();}// If it doesn't exist, it is null or empty.
if(!this.manifest.checkAddressExists(pObject,pValueAddress)){return true;}// Get the value from the internal manifest and return it
var tmpValue=this.manifest.getValueByHash(pObject,pValueAddress);if(tmpValue===null||tmpValue===''){return true;}return false;}// Convert an ISO string to a javascript date object
// Adapted from https://stackoverflow.com/a/54751179
//
// Takes strings like: 2022-11-04T11:34:45.000Z
//                and: 1986-06-11T09:34:46.012Z+0200
// ... and converts them into javascript timestamps, following the directions of the timezone stuff.
//
// This is not meant to replace the more complex libraries such as moment or luxon.
// This *is* meant to be a simple, small, and fast way to convert ISO strings to dates in engines
// with ultra limited JS capabilities where those don't work.
},{key:"isoStringToDate",value:function isoStringToDate(pISOString){if(!('Dates'in this.fable)){this.fable.instantiateServiceProvider('Dates');}var tmpDate=false;try{tmpDate=this.fable.Dates.dayJS.utc(pISOString);}catch(pError){// TODO: Should this throw?  Doubtful.
this.fable.log.error("Could not parse date string ".concat(pISOString," with dayJS."));return false;}if(tmpDate){return tmpDate.toDate();}else{return false;}}}]);}(libFableServiceBase);module.exports=FableServiceUtility;},{"async.eachlimit":1,"async.waterfall":15,"big.js":17,"fable-serviceproviderbase":59}],99:[function(require,module,exports){'use strict';/* eslint no-invalid-this: 1 */var ERROR_MESSAGE='Function.prototype.bind called on incompatible ';var toStr=Object.prototype.toString;var max=Math.max;var funcType='[object Function]';var concatty=function concatty(a,b){var arr=[];for(var i=0;i<a.length;i+=1){arr[i]=a[i];}for(var j=0;j<b.length;j+=1){arr[j+a.length]=b[j];}return arr;};var slicy=function slicy(arrLike,offset){var arr=[];for(var i=offset||0,j=0;i<arrLike.length;i+=1,j+=1){arr[j]=arrLike[i];}return arr;};var joiny=function joiny(arr,joiner){var str='';for(var i=0;i<arr.length;i+=1){str+=arr[i];if(i+1<arr.length){str+=joiner;}}return str;};module.exports=function bind(that){var target=this;if(typeof target!=='function'||toStr.apply(target)!==funcType){throw new TypeError(ERROR_MESSAGE+target);}var args=slicy(arguments,1);var bound;var binder=function binder(){if(this instanceof bound){var result=target.apply(this,concatty(args,arguments));if(Object(result)===result){return result;}return this;}return target.apply(that,concatty(args,arguments));};var boundLength=max(0,target.length-args.length);var boundArgs=[];for(var i=0;i<boundLength;i++){boundArgs[i]='$'+i;}bound=Function('binder','return function ('+joiny(boundArgs,',')+'){ return binder.apply(this,arguments); }')(binder);if(target.prototype){var Empty=function Empty(){};Empty.prototype=target.prototype;bound.prototype=new Empty();Empty.prototype=null;}return bound;};},{}],100:[function(require,module,exports){'use strict';var implementation=require('./implementation');module.exports=Function.prototype.bind||implementation;},{"./implementation":99}],101:[function(require,module,exports){'use strict';var undefined;var $Object=require('es-object-atoms');var $Error=require('es-errors');var $EvalError=require('es-errors/eval');var $RangeError=require('es-errors/range');var $ReferenceError=require('es-errors/ref');var $SyntaxError=require('es-errors/syntax');var $TypeError=require('es-errors/type');var $URIError=require('es-errors/uri');var abs=require('math-intrinsics/abs');var floor=require('math-intrinsics/floor');var max=require('math-intrinsics/max');var min=require('math-intrinsics/min');var pow=require('math-intrinsics/pow');var round=require('math-intrinsics/round');var sign=require('math-intrinsics/sign');var $Function=Function;// eslint-disable-next-line consistent-return
var getEvalledConstructor=function getEvalledConstructor(expressionSyntax){try{return $Function('"use strict"; return ('+expressionSyntax+').constructor;')();}catch(e){}};var $gOPD=require('gopd');var $defineProperty=require('es-define-property');var throwTypeError=function throwTypeError(){throw new $TypeError();};var ThrowTypeError=$gOPD?function(){try{// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
arguments.callee;// IE 8 does not throw here
return throwTypeError;}catch(calleeThrows){try{// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
return $gOPD(arguments,'callee').get;}catch(gOPDthrows){return throwTypeError;}}}():throwTypeError;var hasSymbols=require('has-symbols')();var getProto=require('get-proto');var $ObjectGPO=require('get-proto/Object.getPrototypeOf');var $ReflectGPO=require('get-proto/Reflect.getPrototypeOf');var $apply=require('call-bind-apply-helpers/functionApply');var $call=require('call-bind-apply-helpers/functionCall');var needsEval={};var TypedArray=typeof Uint8Array==='undefined'||!getProto?undefined:getProto(Uint8Array);var INTRINSICS={__proto__:null,'%AggregateError%':typeof AggregateError==='undefined'?undefined:AggregateError,'%Array%':Array,'%ArrayBuffer%':typeof ArrayBuffer==='undefined'?undefined:ArrayBuffer,'%ArrayIteratorPrototype%':hasSymbols&&getProto?getProto([][Symbol.iterator]()):undefined,'%AsyncFromSyncIteratorPrototype%':undefined,'%AsyncFunction%':needsEval,'%AsyncGenerator%':needsEval,'%AsyncGeneratorFunction%':needsEval,'%AsyncIteratorPrototype%':needsEval,'%Atomics%':typeof Atomics==='undefined'?undefined:Atomics,'%BigInt%':typeof BigInt==='undefined'?undefined:BigInt,'%BigInt64Array%':typeof BigInt64Array==='undefined'?undefined:BigInt64Array,'%BigUint64Array%':typeof BigUint64Array==='undefined'?undefined:BigUint64Array,'%Boolean%':Boolean,'%DataView%':typeof DataView==='undefined'?undefined:DataView,'%Date%':Date,'%decodeURI%':decodeURI,'%decodeURIComponent%':decodeURIComponent,'%encodeURI%':encodeURI,'%encodeURIComponent%':encodeURIComponent,'%Error%':$Error,'%eval%':eval,// eslint-disable-line no-eval
'%EvalError%':$EvalError,'%Float32Array%':typeof Float32Array==='undefined'?undefined:Float32Array,'%Float64Array%':typeof Float64Array==='undefined'?undefined:Float64Array,'%FinalizationRegistry%':typeof FinalizationRegistry==='undefined'?undefined:FinalizationRegistry,'%Function%':$Function,'%GeneratorFunction%':needsEval,'%Int8Array%':typeof Int8Array==='undefined'?undefined:Int8Array,'%Int16Array%':typeof Int16Array==='undefined'?undefined:Int16Array,'%Int32Array%':typeof Int32Array==='undefined'?undefined:Int32Array,'%isFinite%':isFinite,'%isNaN%':isNaN,'%IteratorPrototype%':hasSymbols&&getProto?getProto(getProto([][Symbol.iterator]())):undefined,'%JSON%':(typeof JSON==="undefined"?"undefined":_typeof(JSON))==='object'?JSON:undefined,'%Map%':typeof Map==='undefined'?undefined:Map,'%MapIteratorPrototype%':typeof Map==='undefined'||!hasSymbols||!getProto?undefined:getProto(new Map()[Symbol.iterator]()),'%Math%':Math,'%Number%':Number,'%Object%':$Object,'%Object.getOwnPropertyDescriptor%':$gOPD,'%parseFloat%':parseFloat,'%parseInt%':parseInt,'%Promise%':typeof Promise==='undefined'?undefined:Promise,'%Proxy%':typeof Proxy==='undefined'?undefined:Proxy,'%RangeError%':$RangeError,'%ReferenceError%':$ReferenceError,'%Reflect%':typeof Reflect==='undefined'?undefined:Reflect,'%RegExp%':RegExp,'%Set%':typeof Set==='undefined'?undefined:Set,'%SetIteratorPrototype%':typeof Set==='undefined'||!hasSymbols||!getProto?undefined:getProto(new Set()[Symbol.iterator]()),'%SharedArrayBuffer%':typeof SharedArrayBuffer==='undefined'?undefined:SharedArrayBuffer,'%String%':String,'%StringIteratorPrototype%':hasSymbols&&getProto?getProto(''[Symbol.iterator]()):undefined,'%Symbol%':hasSymbols?Symbol:undefined,'%SyntaxError%':$SyntaxError,'%ThrowTypeError%':ThrowTypeError,'%TypedArray%':TypedArray,'%TypeError%':$TypeError,'%Uint8Array%':typeof Uint8Array==='undefined'?undefined:Uint8Array,'%Uint8ClampedArray%':typeof Uint8ClampedArray==='undefined'?undefined:Uint8ClampedArray,'%Uint16Array%':typeof Uint16Array==='undefined'?undefined:Uint16Array,'%Uint32Array%':typeof Uint32Array==='undefined'?undefined:Uint32Array,'%URIError%':$URIError,'%WeakMap%':typeof WeakMap==='undefined'?undefined:WeakMap,'%WeakRef%':typeof WeakRef==='undefined'?undefined:WeakRef,'%WeakSet%':typeof WeakSet==='undefined'?undefined:WeakSet,'%Function.prototype.call%':$call,'%Function.prototype.apply%':$apply,'%Object.defineProperty%':$defineProperty,'%Object.getPrototypeOf%':$ObjectGPO,'%Math.abs%':abs,'%Math.floor%':floor,'%Math.max%':max,'%Math.min%':min,'%Math.pow%':pow,'%Math.round%':round,'%Math.sign%':sign,'%Reflect.getPrototypeOf%':$ReflectGPO};if(getProto){try{null.error;// eslint-disable-line no-unused-expressions
}catch(e){// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
var errorProto=getProto(getProto(e));INTRINSICS['%Error.prototype%']=errorProto;}}var doEval=function doEval(name){var value;if(name==='%AsyncFunction%'){value=getEvalledConstructor('async function () {}');}else if(name==='%GeneratorFunction%'){value=getEvalledConstructor('function* () {}');}else if(name==='%AsyncGeneratorFunction%'){value=getEvalledConstructor('async function* () {}');}else if(name==='%AsyncGenerator%'){var fn=doEval('%AsyncGeneratorFunction%');if(fn){value=fn.prototype;}}else if(name==='%AsyncIteratorPrototype%'){var gen=doEval('%AsyncGenerator%');if(gen&&getProto){value=getProto(gen.prototype);}}INTRINSICS[name]=value;return value;};var LEGACY_ALIASES={__proto__:null,'%ArrayBufferPrototype%':['ArrayBuffer','prototype'],'%ArrayPrototype%':['Array','prototype'],'%ArrayProto_entries%':['Array','prototype','entries'],'%ArrayProto_forEach%':['Array','prototype','forEach'],'%ArrayProto_keys%':['Array','prototype','keys'],'%ArrayProto_values%':['Array','prototype','values'],'%AsyncFunctionPrototype%':['AsyncFunction','prototype'],'%AsyncGenerator%':['AsyncGeneratorFunction','prototype'],'%AsyncGeneratorPrototype%':['AsyncGeneratorFunction','prototype','prototype'],'%BooleanPrototype%':['Boolean','prototype'],'%DataViewPrototype%':['DataView','prototype'],'%DatePrototype%':['Date','prototype'],'%ErrorPrototype%':['Error','prototype'],'%EvalErrorPrototype%':['EvalError','prototype'],'%Float32ArrayPrototype%':['Float32Array','prototype'],'%Float64ArrayPrototype%':['Float64Array','prototype'],'%FunctionPrototype%':['Function','prototype'],'%Generator%':['GeneratorFunction','prototype'],'%GeneratorPrototype%':['GeneratorFunction','prototype','prototype'],'%Int8ArrayPrototype%':['Int8Array','prototype'],'%Int16ArrayPrototype%':['Int16Array','prototype'],'%Int32ArrayPrototype%':['Int32Array','prototype'],'%JSONParse%':['JSON','parse'],'%JSONStringify%':['JSON','stringify'],'%MapPrototype%':['Map','prototype'],'%NumberPrototype%':['Number','prototype'],'%ObjectPrototype%':['Object','prototype'],'%ObjProto_toString%':['Object','prototype','toString'],'%ObjProto_valueOf%':['Object','prototype','valueOf'],'%PromisePrototype%':['Promise','prototype'],'%PromiseProto_then%':['Promise','prototype','then'],'%Promise_all%':['Promise','all'],'%Promise_reject%':['Promise','reject'],'%Promise_resolve%':['Promise','resolve'],'%RangeErrorPrototype%':['RangeError','prototype'],'%ReferenceErrorPrototype%':['ReferenceError','prototype'],'%RegExpPrototype%':['RegExp','prototype'],'%SetPrototype%':['Set','prototype'],'%SharedArrayBufferPrototype%':['SharedArrayBuffer','prototype'],'%StringPrototype%':['String','prototype'],'%SymbolPrototype%':['Symbol','prototype'],'%SyntaxErrorPrototype%':['SyntaxError','prototype'],'%TypedArrayPrototype%':['TypedArray','prototype'],'%TypeErrorPrototype%':['TypeError','prototype'],'%Uint8ArrayPrototype%':['Uint8Array','prototype'],'%Uint8ClampedArrayPrototype%':['Uint8ClampedArray','prototype'],'%Uint16ArrayPrototype%':['Uint16Array','prototype'],'%Uint32ArrayPrototype%':['Uint32Array','prototype'],'%URIErrorPrototype%':['URIError','prototype'],'%WeakMapPrototype%':['WeakMap','prototype'],'%WeakSetPrototype%':['WeakSet','prototype']};var bind=require('function-bind');var hasOwn=require('hasown');var $concat=bind.call($call,Array.prototype.concat);var $spliceApply=bind.call($apply,Array.prototype.splice);var $replace=bind.call($call,String.prototype.replace);var $strSlice=bind.call($call,String.prototype.slice);var $exec=bind.call($call,RegExp.prototype.exec);/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */var rePropName=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;var reEscapeChar=/\\(\\)?/g;/** Used to match backslashes in property paths. */var stringToPath=function stringToPath(string){var first=$strSlice(string,0,1);var last=$strSlice(string,-1);if(first==='%'&&last!=='%'){throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');}else if(last==='%'&&first!=='%'){throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');}var result=[];$replace(string,rePropName,function(match,number,quote,subString){result[result.length]=quote?$replace(subString,reEscapeChar,'$1'):number||match;});return result;};/* end adaptation */var getBaseIntrinsic=function getBaseIntrinsic(name,allowMissing){var intrinsicName=name;var alias;if(hasOwn(LEGACY_ALIASES,intrinsicName)){alias=LEGACY_ALIASES[intrinsicName];intrinsicName='%'+alias[0]+'%';}if(hasOwn(INTRINSICS,intrinsicName)){var value=INTRINSICS[intrinsicName];if(value===needsEval){value=doEval(intrinsicName);}if(typeof value==='undefined'&&!allowMissing){throw new $TypeError('intrinsic '+name+' exists, but is not available. Please file an issue!');}return{alias:alias,name:intrinsicName,value:value};}throw new $SyntaxError('intrinsic '+name+' does not exist!');};module.exports=function GetIntrinsic(name,allowMissing){if(typeof name!=='string'||name.length===0){throw new $TypeError('intrinsic name must be a non-empty string');}if(arguments.length>1&&typeof allowMissing!=='boolean'){throw new $TypeError('"allowMissing" argument must be a boolean');}if($exec(/^%?[^%]*%?$/,name)===null){throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');}var parts=stringToPath(name);var intrinsicBaseName=parts.length>0?parts[0]:'';var intrinsic=getBaseIntrinsic('%'+intrinsicBaseName+'%',allowMissing);var intrinsicRealName=intrinsic.name;var value=intrinsic.value;var skipFurtherCaching=false;var alias=intrinsic.alias;if(alias){intrinsicBaseName=alias[0];$spliceApply(parts,$concat([0,1],alias));}for(var i=1,isOwn=true;i<parts.length;i+=1){var part=parts[i];var first=$strSlice(part,0,1);var last=$strSlice(part,-1);if((first==='"'||first==="'"||first==='`'||last==='"'||last==="'"||last==='`')&&first!==last){throw new $SyntaxError('property names with quotes must have matching quotes');}if(part==='constructor'||!isOwn){skipFurtherCaching=true;}intrinsicBaseName+='.'+part;intrinsicRealName='%'+intrinsicBaseName+'%';if(hasOwn(INTRINSICS,intrinsicRealName)){value=INTRINSICS[intrinsicRealName];}else if(value!=null){if(!(part in value)){if(!allowMissing){throw new $TypeError('base intrinsic for '+name+' exists, but the property is not available.');}return void undefined;}if($gOPD&&i+1>=parts.length){var desc=$gOPD(value,part);isOwn=!!desc;// By convention, when a data property is converted to an accessor
// property to emulate a data property that does not suffer from
// the override mistake, that accessor's getter is marked with
// an `originalValue` property. Here, when we detect this, we
// uphold the illusion by pretending to see that original data
// property, i.e., returning the value rather than the getter
// itself.
if(isOwn&&'get'in desc&&!('originalValue'in desc.get)){value=desc.get;}else{value=value[part];}}else{isOwn=hasOwn(value,part);value=value[part];}if(isOwn&&!skipFurtherCaching){INTRINSICS[intrinsicRealName]=value;}}}return value;};},{"call-bind-apply-helpers/functionApply":26,"call-bind-apply-helpers/functionCall":27,"es-define-property":41,"es-errors":43,"es-errors/eval":42,"es-errors/range":44,"es-errors/ref":45,"es-errors/syntax":46,"es-errors/type":47,"es-errors/uri":48,"es-object-atoms":49,"function-bind":100,"get-proto":104,"get-proto/Object.getPrototypeOf":102,"get-proto/Reflect.getPrototypeOf":103,"gopd":106,"has-symbols":107,"hasown":109,"math-intrinsics/abs":125,"math-intrinsics/floor":126,"math-intrinsics/max":128,"math-intrinsics/min":129,"math-intrinsics/pow":130,"math-intrinsics/round":131,"math-intrinsics/sign":132}],102:[function(require,module,exports){'use strict';var $Object=require('es-object-atoms');/** @type {import('./Object.getPrototypeOf')} */module.exports=$Object.getPrototypeOf||null;},{"es-object-atoms":49}],103:[function(require,module,exports){'use strict';/** @type {import('./Reflect.getPrototypeOf')} */module.exports=typeof Reflect!=='undefined'&&Reflect.getPrototypeOf||null;},{}],104:[function(require,module,exports){'use strict';var reflectGetProto=require('./Reflect.getPrototypeOf');var originalGetProto=require('./Object.getPrototypeOf');var getDunderProto=require('dunder-proto/get');/** @type {import('.')} */module.exports=reflectGetProto?function getProto(O){// @ts-expect-error TS can't narrow inside a closure, for some reason
return reflectGetProto(O);}:originalGetProto?function getProto(O){if(!O||_typeof(O)!=='object'&&typeof O!=='function'){throw new TypeError('getProto: not an object');}// @ts-expect-error TS can't narrow inside a closure, for some reason
return originalGetProto(O);}:getDunderProto?function getProto(O){// @ts-expect-error TS can't narrow inside a closure, for some reason
return getDunderProto(O);}:null;},{"./Object.getPrototypeOf":102,"./Reflect.getPrototypeOf":103,"dunder-proto/get":40}],105:[function(require,module,exports){'use strict';/** @type {import('./gOPD')} */module.exports=Object.getOwnPropertyDescriptor;},{}],106:[function(require,module,exports){'use strict';/** @type {import('.')} */var $gOPD=require('./gOPD');if($gOPD){try{$gOPD([],'length');}catch(e){// IE 8 has a broken gOPD
$gOPD=null;}}module.exports=$gOPD;},{"./gOPD":105}],107:[function(require,module,exports){'use strict';var origSymbol=typeof Symbol!=='undefined'&&Symbol;var hasSymbolSham=require('./shams');/** @type {import('.')} */module.exports=function hasNativeSymbols(){if(typeof origSymbol!=='function'){return false;}if(typeof Symbol!=='function'){return false;}if(_typeof(origSymbol('foo'))!=='symbol'){return false;}if(_typeof(Symbol('bar'))!=='symbol'){return false;}return hasSymbolSham();};},{"./shams":108}],108:[function(require,module,exports){'use strict';/** @type {import('./shams')} *//* eslint complexity: [2, 18], max-statements: [2, 33] */module.exports=function hasSymbols(){if(typeof Symbol!=='function'||typeof Object.getOwnPropertySymbols!=='function'){return false;}if(_typeof(Symbol.iterator)==='symbol'){return true;}/** @type {{ [k in symbol]?: unknown }} */var obj={};var sym=Symbol('test');var symObj=Object(sym);if(typeof sym==='string'){return false;}if(Object.prototype.toString.call(sym)!=='[object Symbol]'){return false;}if(Object.prototype.toString.call(symObj)!=='[object Symbol]'){return false;}// temp disabled per https://github.com/ljharb/object.assign/issues/17
// if (sym instanceof Symbol) { return false; }
// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
// if (!(symObj instanceof Symbol)) { return false; }
// if (typeof Symbol.prototype.toString !== 'function') { return false; }
// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
var symVal=42;obj[sym]=symVal;for(var _ in obj){return false;}// eslint-disable-line no-restricted-syntax, no-unreachable-loop
if(typeof Object.keys==='function'&&Object.keys(obj).length!==0){return false;}if(typeof Object.getOwnPropertyNames==='function'&&Object.getOwnPropertyNames(obj).length!==0){return false;}var syms=Object.getOwnPropertySymbols(obj);if(syms.length!==1||syms[0]!==sym){return false;}if(!Object.prototype.propertyIsEnumerable.call(obj,sym)){return false;}if(typeof Object.getOwnPropertyDescriptor==='function'){// eslint-disable-next-line no-extra-parens
var descriptor=/** @type {PropertyDescriptor} */Object.getOwnPropertyDescriptor(obj,sym);if(descriptor.value!==symVal||descriptor.enumerable!==true){return false;}}return true;};},{}],109:[function(require,module,exports){'use strict';var call=Function.prototype.call;var $hasOwn=Object.prototype.hasOwnProperty;var bind=require('function-bind');/** @type {import('.')} */module.exports=bind.call(call,$hasOwn);},{"function-bind":100}],110:[function(require,module,exports){var http=require('http');var url=require('url');var https=module.exports;for(var key in http){if(http.hasOwnProperty(key))https[key]=http[key];}https.request=function(params,cb){params=validateParams(params);return http.request.call(this,params,cb);};https.get=function(params,cb){params=validateParams(params);return http.get.call(this,params,cb);};function validateParams(params){if(typeof params==='string'){params=url.parse(params);}if(!params.protocol){params.protocol='https:';}if(params.protocol!=='https:'){throw new Error('Protocol "'+params.protocol+'" not supported. Expected "https:"');}return params;}},{"http":164,"url":185}],111:[function(require,module,exports){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};},{}],112:[function(require,module,exports){if(typeof Object.create==='function'){// implementation from standard node.js 'util' module
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}});}};}else{// old school shim for old browsers
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}};}},{}],113:[function(require,module,exports){// When a boxed property is passed in, it should have quotes of some
// kind around it.
//
// For instance:
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// This function removes the wrapping quotes.
//
// Please note it *DOES NOT PARSE* template literals, so backticks just
// end up doing the same thing as other quote types.
//
// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.
// TODO: Make a simple class include library with these
var cleanWrapCharacters=function cleanWrapCharacters(pCharacter,pString){if(pString.startsWith(pCharacter)&&pString.endsWith(pCharacter)){return pString.substring(1,pString.length-1);}else{return pString;}};module.exports=cleanWrapCharacters;},{}],114:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');/**
* Hash Translation
*
* This is a very simple translation table for hashes, which allows the same schema to resolve
* differently based on a loaded translation table.
*
* This is to prevent the requirement for mutating schemas over and over again when we want to
* reuse the structure but look up data elements by different addresses.
*
* One side-effect of this is that a translation table can "override" the built-in hashes, since
* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform
* their lookups by hash.
*
* @class ManyfestHashTranslation
*/var ManyfestHashTranslation=/*#__PURE__*/function(){function ManyfestHashTranslation(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestHashTranslation);// Wire in logging
this.logInfo=typeof pInfoLog==='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog==='function'?pErrorLog:libSimpleLog;this.translationTable={};}return _createClass2(ManyfestHashTranslation,[{key:"translationCount",value:function translationCount(){return Object.keys(this.translationTable).length;}},{key:"addTranslation",value:function addTranslation(pTranslation){var _this46=this;// This adds a translation in the form of:
// { "SourceHash": "DestinationHash", "SecondSourceHash":"SecondDestinationHash" }
if(_typeof(pTranslation)!='object'){this.logError("Hash translation addTranslation expected a translation be type object but was passed in ".concat(_typeof(pTranslation)));return false;}var tmpTranslationSources=Object.keys(pTranslation);tmpTranslationSources.forEach(function(pTranslationSource){if(typeof pTranslation[pTranslationSource]!='string'){_this46.logError("Hash translation addTranslation expected a translation destination hash for [".concat(pTranslationSource,"] to be a string but the referrant was a ").concat(_typeof(pTranslation[pTranslationSource])));}else{_this46.translationTable[pTranslationSource]=pTranslation[pTranslationSource];}});}},{key:"removeTranslationHash",value:function removeTranslationHash(pTranslationHash){if(pTranslationHash in this.translationTable){delete this.translationTable[pTranslationHash];}}// This removes translations.
// If passed a string, just removes the single one.
// If passed an object, it does all the source keys.
},{key:"removeTranslation",value:function removeTranslation(pTranslation){var _this47=this;if(typeof pTranslation=='string'){this.removeTranslationHash(pTranslation);return true;}else if(_typeof(pTranslation)=='object'){var tmpTranslationSources=Object.keys(pTranslation);tmpTranslationSources.forEach(function(pTranslationSource){_this47.removeTranslation(pTranslationSource);});return true;}else{this.logError("Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ".concat(_typeof(pTranslation)));return false;}}},{key:"clearTranslations",value:function clearTranslations(){this.translationTable={};}},{key:"translate",value:function translate(pTranslation){if(pTranslation in this.translationTable){return this.translationTable[pTranslation];}else{return pTranslation;}}}]);}();module.exports=ManyfestHashTranslation;},{"./Manyfest-LogToConsole.js":115}],115:[function(require,module,exports){/**
* @author <steven@velozo.com>
*//**
* Manyfest simple logging shim (for browser and dependency-free running)
*/var logToConsole=function logToConsole(pLogLine,pLogObject){var tmpLogLine=typeof pLogLine==='string'?pLogLine:'';console.log("[Manyfest] ".concat(tmpLogLine));if(pLogObject)console.log(JSON.stringify(pLogObject));};module.exports=logToConsole;},{}],116:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');// This is for resolving functions mid-address
var libGetObjectValue=require('./Manyfest-ObjectAddress-GetValue.js');// TODO: Just until this is a fable service.
var _MockFable={DataFormat:require('./Manyfest-ObjectAddress-Parser.js')};/**
* Object Address Resolver
*
* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to
*                 be extremely clear what is going on in the recursion for
*                 each of the three address resolution functions.
*
*                 Although there is some opportunity to repeat ourselves a
*                 bit less in this codebase (e.g. with detection of arrays
*                 versus objects versus direct properties), it can make
*                 debugging.. challenging.  The minified version of the code
*                 optimizes out almost anything repeated in here.  So please
*                 be kind and rewind... meaning please keep the codebase less
*                 terse and more verbose so humans can comprehend it.
*
*
* @class ManyfestObjectAddressResolverCheckAddressExists
*/var ManyfestObjectAddressResolverCheckAddressExists=/*#__PURE__*/function(){function ManyfestObjectAddressResolverCheckAddressExists(){_classCallCheck2(this,ManyfestObjectAddressResolverCheckAddressExists);this.getObjectValueClass=new libGetObjectValue(libSimpleLog,libSimpleLog);}// Check if an address exists.
//
// This is necessary because the getValueAtAddress function is ambiguous on
// whether the element/property is actually there or not (it returns
// undefined whether the property exists or not).  This function checks for
// existance and returns true or false dependent.
return _createClass2(ManyfestObjectAddressResolverCheckAddressExists,[{key:"checkAddressExists",value:function checkAddressExists(pObject,pAddress,pRootObject){// TODO: Should these throw an error?
// Make sure pObject is an object
if(_typeof(pObject)!='object')return false;// Make sure pAddress is a string
if(typeof pAddress!='string')return false;// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.
// NOTE: This was added to support functions mid-stream
var tmpRootObject=typeof pRootObject=='undefined'?pObject:pRootObject;// DONE: Make this work for things like SomeRootObject.Metadata["Some.People.Use.Bad.Object.Property.Names"]
var tmpAddressPartBeginning=_MockFable.DataFormat.stringGetFirstSegment(pAddress);// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)
if(tmpAddressPartBeginning.length==pAddress.length){// Check if the address refers to a boxed property
var tmpBracketStartIndex=pAddress.indexOf('[');var tmpBracketStopIndex=pAddress.indexOf(']');// Check if there is a function somewhere in the address... parenthesis start should only be in a function
var tmpFunctionStartIndex=pAddress.indexOf('(');// NOTE THAT FUNCTIONS MUST RESOLVE FIRST
// Functions look like this
// 		MyFunction()
// 		MyFunction(Some.Address)
// 		MyFunction(Some.Address,Some.Other.Address)
// 		MyFunction(Some.Address,Some.Other.Address,Some.Third.Address)
//
// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,
// To heck with that.  This is a simple function call.
//
// The requirements to detect a function are:
//    1) The start bracket is after character 0
if(tmpFunctionStartIndex>0//    2) The end bracket is after the start bracket
&&_MockFable.DataFormat.stringCountEnclosures(pAddress)>0){var tmpFunctionAddress=pAddress.substring(0,tmpFunctionStartIndex).trim();if(tmpFunctionAddress in pObject&&typeof pObject[tmpFunctionAddress]=='function'){return true;}else{// The address suggests it is a function, but it is not.
return false;}}// Boxed elements look like this:
// 		MyValues[10]
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
else if(tmpBracketStartIndex>0//    2) The end bracket has something between them
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is data
&&tmpBracketStopIndex-tmpBracketStartIndex>1){// The "Name" of the Object contained too the left of the bracket
var tmpBoxedPropertyName=pAddress.substring(0,tmpBracketStartIndex).trim();// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.
// This is a rare case where Arrays testing as Objects is useful
if(_typeof(pObject[tmpBoxedPropertyName])!=='object'){return false;}// The "Reference" to the property within it, either an array element or object property
var tmpBoxedPropertyReference=pAddress.substring(tmpBracketStartIndex+1,tmpBracketStopIndex).trim();// Attempt to parse the reference as a number, which will be used as an array element
var tmpBoxedPropertyNumber=parseInt(tmpBoxedPropertyReference,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
if(Array.isArray(pObject[tmpBoxedPropertyName])==isNaN(tmpBoxedPropertyNumber)){return false;}//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to treat it as a dynamic object property.
if(isNaN(tmpBoxedPropertyNumber)){// This isn't a number ... let's treat it as a dynamic object property.
// We would expect the property to be wrapped in some kind of quotes so strip them
tmpBoxedPropertyReference=this.cleanWrapCharacters('"',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters('`',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters("'",tmpBoxedPropertyReference);// Check if the property exists.
return tmpBoxedPropertyReference in pObject[tmpBoxedPropertyName];}else{// Use the new in operator to see if the element is in the array
return tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName];}}else{// Check if the property exists
return pAddress in pObject;}}else{var tmpSubObjectName=tmpAddressPartBeginning;var tmpNewAddress=pAddress.substring(tmpAddressPartBeginning.length+1);// Test if the tmpNewAddress is an array or object
// Check if it's a boxed property
var _tmpBracketStartIndex=tmpSubObjectName.indexOf('[');var _tmpBracketStopIndex=tmpSubObjectName.indexOf(']');// Check if there is a function somewhere in the address... parenthesis start should only be in a function
var _tmpFunctionStartIndex=tmpSubObjectName.indexOf('(');// NOTE THAT FUNCTIONS MUST RESOLVE FIRST
// Functions look like this
// 		MyFunction()
// 		MyFunction(Some.Address)
// 		MyFunction(Some.Address,Some.Other.Address)
// 		MyFunction(Some.Address,Some.Other.Address,Some.Third.Address)
//
// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,
// To heck with that.  This is a simple function call.
//
// The requirements to detect a function are:
//    1) The start bracket is after character 0
if(_tmpFunctionStartIndex>0//    2) The end bracket is after the start bracket
&&_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName)>0){var _tmpFunctionAddress=tmpSubObjectName.substring(0,_tmpFunctionStartIndex).trim();//tmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;
if(!_typeof(pObject[_tmpFunctionAddress])=='function'){// The address suggests it is a function, but it is not.
return false;}// Now see if the function has arguments.
// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *
var tmpFunctionArguments=_MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(_tmpFunctionAddress.length),0),',');if(tmpFunctionArguments.length==0||tmpFunctionArguments[0]==''){// No arguments... just call the function (bound to the scope of the object it is contained withing)
if(_tmpFunctionAddress in pObject){try{return this.checkAddressExists(pObject[_tmpFunctionAddress].apply(pObject),tmpNewAddress,tmpRootObject);}catch(pError){// The function call failed, so the address doesn't exist
libSimpleLog.log("Error calling function ".concat(_tmpFunctionAddress," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
libSimpleLog.log("Function ".concat(_tmpFunctionAddress," does not exist (address [").concat(pAddress,"])"));return false;}}else{var tmpArgumentValues=[];var _tmpRootObject=typeof pRootObject=='undefined'?pObject:pRootObject;// Now get the value for each argument
for(var i=0;i<tmpFunctionArguments.length;i++){// Resolve the values for each subsequent entry
// NOTE: This is where the resolves get really tricky.  Recursion within recursion.  Programming gom jabbar, yo.
tmpArgumentValues.push(this.getObjectValueClass.getValueAtAddress(_tmpRootObject,tmpFunctionArguments[i]));}//return this.checkAddressExists(pObject[tmpFunctionAddress].apply(pObject, tmpArgumentValues), tmpNewAddress, tmpRootObject);
if(_tmpFunctionAddress in pObject){try{return this.checkAddressExists(pObject[_tmpFunctionAddress].apply(pObject,tmpArgumentValues),tmpNewAddress,_tmpRootObject);}catch(pError){// The function call failed, so the address doesn't exist
libSimpleLog.log("Error calling function ".concat(_tmpFunctionAddress," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
libSimpleLog.log("Function ".concat(_tmpFunctionAddress," does not exist (address [").concat(pAddress,"])"));return false;}}}// Boxed elements look like this:
// 		MyValues[42]
// 		MyValues['Color']
// 		MyValues["Weight"]
// 		MyValues[`Diameter`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
else if(_tmpBracketStartIndex>0//    2) The end bracket has something between them
&&_tmpBracketStopIndex>_tmpBracketStartIndex//    3) There is data
&&_tmpBracketStopIndex-_tmpBracketStartIndex>1){var _tmpBoxedPropertyName=tmpSubObjectName.substring(0,_tmpBracketStartIndex).trim();var _tmpBoxedPropertyReference=tmpSubObjectName.substring(_tmpBracketStartIndex+1,_tmpBracketStopIndex).trim();var _tmpBoxedPropertyNumber=parseInt(_tmpBoxedPropertyReference,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students[1].Tardy
//       BUT
//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students["JaneDoe"].Grade
//       BUT
//         StudentData.Sections.Algebra.Students is an array, so the ["JaneDoe"].Grade is not possible to access
// TODO: Should this be an error or something?  Should we keep a log of failures like this?
if(Array.isArray(pObject[_tmpBoxedPropertyName])==isNaN(_tmpBoxedPropertyNumber)){// Because this is an impossible address, the property doesn't exist
// TODO: Should we throw an error in this condition?
return false;}//This is a bracketed value
//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to reat it as a dynamic object property.
if(isNaN(_tmpBoxedPropertyNumber)){// This isn't a number ... let's treat it as a dynanmic object property.
_tmpBoxedPropertyReference=this.cleanWrapCharacters('"',_tmpBoxedPropertyReference);_tmpBoxedPropertyReference=this.cleanWrapCharacters('`',_tmpBoxedPropertyReference);_tmpBoxedPropertyReference=this.cleanWrapCharacters("'",_tmpBoxedPropertyReference);// Recurse directly into the subobject
return this.checkAddressExists(pObject[_tmpBoxedPropertyName][_tmpBoxedPropertyReference],tmpNewAddress,tmpRootObject);}else{// We parsed a valid number out of the boxed property name, so recurse into the array
return this.checkAddressExists(pObject[_tmpBoxedPropertyName][_tmpBoxedPropertyNumber],tmpNewAddress,tmpRootObject);}}// If there is an object property already named for the sub object, but it isn't an object
// then the system can't set the value in there.  Error and abort!
if(tmpSubObjectName in pObject&&_typeof(pObject[tmpSubObjectName])!=='object'){return false;}else if(tmpSubObjectName in pObject){// If there is already a subobject pass that to the recursive thingy
return this.checkAddressExists(pObject[tmpSubObjectName],tmpNewAddress,tmpRootObject);}else{// Create a subobject and then pass that
pObject[tmpSubObjectName]={};return this.checkAddressExists(pObject[tmpSubObjectName],tmpNewAddress,tmpRootObject);}}}}]);}();;module.exports=ManyfestObjectAddressResolverCheckAddressExists;},{"./Manyfest-LogToConsole.js":115,"./Manyfest-ObjectAddress-GetValue.js":118,"./Manyfest-ObjectAddress-Parser.js":119}],117:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');var fCleanWrapCharacters=require('./Manyfest-CleanWrapCharacters.js');var fParseConditionals=require("../source/Manyfest-ParseConditionals.js");/**
* Object Address Resolver - DeleteValue
*
* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to
*                 be extremely clear what is going on in the recursion for
*                 each of the three address resolution functions.
*
*                 Although there is some opportunity to repeat ourselves a
*                 bit less in this codebase (e.g. with detection of arrays
*                 versus objects versus direct properties), it can make
*                 debugging.. challenging.  The minified version of the code
*                 optimizes out almost anything repeated in here.  So please
*                 be kind and rewind... meaning please keep the codebase less
*                 terse and more verbose so humans can comprehend it.
*
* TODO: Once we validate this pattern is good to go, break these out into
*       three separate modules.
*
* @class ManyfestObjectAddressResolverDeleteValue
*/var ManyfestObjectAddressResolverDeleteValue=/*#__PURE__*/function(){function ManyfestObjectAddressResolverDeleteValue(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestObjectAddressResolverDeleteValue);// Wire in logging
this.logInfo=typeof pInfoLog=='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog=='function'?pErrorLog:libSimpleLog;this.cleanWrapCharacters=fCleanWrapCharacters;}// TODO: Dry me
return _createClass2(ManyfestObjectAddressResolverDeleteValue,[{key:"checkRecordFilters",value:function checkRecordFilters(pAddress,pRecord){return fParseConditionals(this,pAddress,pRecord);}// Delete the value of an element at an address
},{key:"deleteValueAtAddress",value:function deleteValueAtAddress(pObject,pAddress,pParentAddress){// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)
if(_typeof(pObject)!='object')return undefined;// Make sure pAddress (the address we are resolving) is a string
if(typeof pAddress!='string')return undefined;// Stash the parent address for later resolution
var tmpParentAddress="";if(typeof pParentAddress=='string'){tmpParentAddress=pParentAddress;}// TODO: Make this work for things like SomeRootObject.Metadata["Some.People.Use.Bad.Object.Property.Names"]
var tmpSeparatorIndex=pAddress.indexOf('.');// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)
if(tmpSeparatorIndex==-1){// Check if the address refers to a boxed property
var tmpBracketStartIndex=pAddress.indexOf('[');var tmpBracketStopIndex=pAddress.indexOf(']');// Check for the Object Set Type marker.
// Note this will not work with a bracket in the same address box set
var tmpObjectTypeMarkerIndex=pAddress.indexOf('{}');// Boxed elements look like this:
// 		MyValues[10]
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
if(tmpBracketStartIndex>0//    2) The end bracket has something between them
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is data
&&tmpBracketStopIndex-tmpBracketStartIndex>1){// The "Name" of the Object contained too the left of the bracket
var tmpBoxedPropertyName=pAddress.substring(0,tmpBracketStartIndex).trim();// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.
// This is a rare case where Arrays testing as Objects is useful
if(_typeof(pObject[tmpBoxedPropertyName])!=='object'){return false;}// The "Reference" to the property within it, either an array element or object property
var tmpBoxedPropertyReference=pAddress.substring(tmpBracketStartIndex+1,tmpBracketStopIndex).trim();// Attempt to parse the reference as a number, which will be used as an array element
var tmpBoxedPropertyNumber=parseInt(tmpBoxedPropertyReference,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
if(Array.isArray(pObject[tmpBoxedPropertyName])==isNaN(tmpBoxedPropertyNumber)){return false;}//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to treat it as a dynamic object property.
if(isNaN(tmpBoxedPropertyNumber)){// This isn't a number ... let's treat it as a dynamic object property.
// We would expect the property to be wrapped in some kind of quotes so strip them
tmpBoxedPropertyReference=this.cleanWrapCharacters('"',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters('`',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters("'",tmpBoxedPropertyReference);// Return the value in the property
delete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];return true;}else{delete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];return true;}}// The requirements to detect a boxed set element are:
//    1) The start bracket is after character 0
else if(tmpBracketStartIndex>0//    2) The end bracket is after the start bracket
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is nothing in the brackets
&&tmpBracketStopIndex-tmpBracketStartIndex==1){var _tmpBoxedPropertyName2=pAddress.substring(0,tmpBracketStartIndex).trim();if(!Array.isArray(pObject[_tmpBoxedPropertyName2])){// We asked for a set from an array but it isnt' an array.
return false;}var tmpInputArray=pObject[_tmpBoxedPropertyName2];// Count from the end to the beginning so splice doesn't %&%#$ up the array
for(var i=tmpInputArray.length-1;i>=0;i--){// The filtering is complex but allows config-based metaprogramming directly from schema
var tmpKeepRecord=this.checkRecordFilters(pAddress,tmpInputArray[i]);if(tmpKeepRecord){// Delete elements end to beginning
tmpInputArray.splice(i,1);}}return true;}// The object has been flagged as an object set, so treat it as such
else if(tmpObjectTypeMarkerIndex>0){var tmpObjectPropertyName=pAddress.substring(0,tmpObjectTypeMarkerIndex).trim();if(_typeof(pObject[tmpObjectPropertyName])!='object'){// We asked for a set from an array but it isnt' an array.
return false;}delete pObject[tmpObjectPropertyName];return true;}else{// Now is the point in recursion to return the value in the address
delete pObject[pAddress];return true;}}else{var tmpSubObjectName=pAddress.substring(0,tmpSeparatorIndex);var tmpNewAddress=pAddress.substring(tmpSeparatorIndex+1);// BOXED ELEMENTS
// Test if the tmpNewAddress is an array or object
// Check if it's a boxed property
var _tmpBracketStartIndex2=tmpSubObjectName.indexOf('[');var _tmpBracketStopIndex2=tmpSubObjectName.indexOf(']');// Boxed elements look like this:
// 		MyValues[42]
// 		MyValues['Color']
// 		MyValues["Weight"]
// 		MyValues[`Diameter`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
if(_tmpBracketStartIndex2>0//    2) The end bracket has something between them
&&_tmpBracketStopIndex2>_tmpBracketStartIndex2//    3) There is data
&&_tmpBracketStopIndex2-_tmpBracketStartIndex2>1){var _tmpBoxedPropertyName3=tmpSubObjectName.substring(0,_tmpBracketStartIndex2).trim();var _tmpBoxedPropertyReference2=tmpSubObjectName.substring(_tmpBracketStartIndex2+1,_tmpBracketStopIndex2).trim();var _tmpBoxedPropertyNumber2=parseInt(_tmpBoxedPropertyReference2,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students[1].Tardy
//       BUT
//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students["JaneDoe"].Grade
//       BUT
//         StudentData.Sections.Algebra.Students is an array, so the ["JaneDoe"].Grade is not possible to access
// TODO: Should this be an error or something?  Should we keep a log of failures like this?
if(Array.isArray(pObject[_tmpBoxedPropertyName3])==isNaN(_tmpBoxedPropertyNumber2)){return false;}// Check if the boxed property is an object.
if(_typeof(pObject[_tmpBoxedPropertyName3])!='object'){return false;}//This is a bracketed value
//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to reat it as a dynamic object property.
if(isNaN(_tmpBoxedPropertyNumber2)){// This isn't a number ... let's treat it as a dynanmic object property.
_tmpBoxedPropertyReference2=this.cleanWrapCharacters('"',_tmpBoxedPropertyReference2);_tmpBoxedPropertyReference2=this.cleanWrapCharacters('`',_tmpBoxedPropertyReference2);_tmpBoxedPropertyReference2=this.cleanWrapCharacters("'",_tmpBoxedPropertyReference2);// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);// Recurse directly into the subobject
return this.deleteValueAtAddress(pObject[_tmpBoxedPropertyName3][_tmpBoxedPropertyReference2],tmpNewAddress,tmpParentAddress);}else{// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);// We parsed a valid number out of the boxed property name, so recurse into the array
return this.deleteValueAtAddress(pObject[_tmpBoxedPropertyName3][_tmpBoxedPropertyNumber2],tmpNewAddress,tmpParentAddress);}}// The requirements to detect a boxed set element are:
//    1) The start bracket is after character 0
else if(_tmpBracketStartIndex2>0//    2) The end bracket is after the start bracket
&&_tmpBracketStopIndex2>_tmpBracketStartIndex2//    3) There is nothing in the brackets
&&_tmpBracketStopIndex2-_tmpBracketStartIndex2==1){var _tmpBoxedPropertyName4=pAddress.substring(0,_tmpBracketStartIndex2).trim();if(!Array.isArray(pObject[_tmpBoxedPropertyName4])){// We asked for a set from an array but it isnt' an array.
return false;}// We need to enumerate the array and grab the addresses from there.
var tmpArrayProperty=pObject[_tmpBoxedPropertyName4];// Managing the parent address is a bit more complex here -- the box will be added for each element.
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(_tmpBoxedPropertyName4);// The container object is where we have the "Address":SOMEVALUE pairs
var tmpContainerObject={};for(var _i25=0;_i25<tmpArrayProperty.length;_i25++){var tmpPropertyParentAddress="".concat(tmpParentAddress,"[").concat(_i25,"]");var tmpValue=this.deleteValueAtAddress(pObject[_tmpBoxedPropertyName4][_i25],tmpNewAddress,tmpPropertyParentAddress);tmpContainerObject["".concat(tmpPropertyParentAddress,".").concat(tmpNewAddress)]=tmpValue;}return tmpContainerObject;}// OBJECT SET
// Note this will not work with a bracket in the same address box set
var _tmpObjectTypeMarkerIndex=pAddress.indexOf('{}');if(_tmpObjectTypeMarkerIndex>0){var _tmpObjectPropertyName=pAddress.substring(0,_tmpObjectTypeMarkerIndex).trim();if(_typeof(pObject[_tmpObjectPropertyName])!='object'){// We asked for a set from an array but it isnt' an array.
return false;}// We need to enumerate the Object and grab the addresses from there.
var tmpObjectProperty=pObject[_tmpObjectPropertyName];var tmpObjectPropertyKeys=Object.keys(tmpObjectProperty);// Managing the parent address is a bit more complex here -- the box will be added for each element.
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(_tmpObjectPropertyName);// The container object is where we have the "Address":SOMEVALUE pairs
var _tmpContainerObject={};for(var _i26=0;_i26<tmpObjectPropertyKeys.length;_i26++){var _tmpPropertyParentAddress="".concat(tmpParentAddress,".").concat(tmpObjectPropertyKeys[_i26]);var _tmpValue3=this.deleteValueAtAddress(pObject[_tmpObjectPropertyName][tmpObjectPropertyKeys[_i26]],tmpNewAddress,_tmpPropertyParentAddress);// The filtering is complex but allows config-based metaprogramming directly from schema
var _tmpKeepRecord=this.checkRecordFilters(pAddress,_tmpValue3);if(_tmpKeepRecord){_tmpContainerObject["".concat(_tmpPropertyParentAddress,".").concat(tmpNewAddress)]=_tmpValue3;}}return _tmpContainerObject;}// If there is an object property already named for the sub object, but it isn't an object
// then the system can't set the value in there.  Error and abort!
if(tmpSubObjectName in pObject&&_typeof(pObject[tmpSubObjectName])!=='object'){return undefined;}else if(tmpSubObjectName in pObject){// If there is already a subobject pass that to the recursive thingy
// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);return this.deleteValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,tmpParentAddress);}else{// Create a subobject and then pass that
// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);pObject[tmpSubObjectName]={};return this.deleteValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,tmpParentAddress);}}}}]);}();;module.exports=ManyfestObjectAddressResolverDeleteValue;},{"../source/Manyfest-ParseConditionals.js":122,"./Manyfest-CleanWrapCharacters.js":113,"./Manyfest-LogToConsole.js":115}],118:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');var fCleanWrapCharacters=require('./Manyfest-CleanWrapCharacters.js');var fParseConditionals=require("../source/Manyfest-ParseConditionals.js");var _MockFable={DataFormat:require('./Manyfest-ObjectAddress-Parser.js')};/**
* Object Address Resolver - GetValue
*
* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to
*                 be extremely clear what is going on in the recursion for
*                 each of the three address resolution functions.
*
*                 Although there is some opportunity to repeat ourselves a
*                 bit less in this codebase (e.g. with detection of arrays
*                 versus objects versus direct properties), it can make
*                 debugging.. challenging.  The minified version of the code
*                 optimizes out almost anything repeated in here.  So please
*                 be kind and rewind... meaning please keep the codebase less
*                 terse and more verbose so humans can comprehend it.
*
* TODO: Once we validate this pattern is good to go, break these out into
*       three separate modules.
*
* @class ManyfestObjectAddressResolverGetValue
*/var ManyfestObjectAddressResolverGetValue=/*#__PURE__*/function(){function ManyfestObjectAddressResolverGetValue(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestObjectAddressResolverGetValue);// Wire in logging
this.logInfo=typeof pInfoLog=='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog=='function'?pErrorLog:libSimpleLog;this.cleanWrapCharacters=fCleanWrapCharacters;}return _createClass2(ManyfestObjectAddressResolverGetValue,[{key:"checkRecordFilters",value:function checkRecordFilters(pAddress,pRecord){return fParseConditionals(this,pAddress,pRecord);}// Get the value of an element at an address
},{key:"getValueAtAddress",value:function getValueAtAddress(pObject,pAddress,pParentAddress,pRootObject){// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)
if(_typeof(pObject)!='object'){return undefined;}if(pObject===null){return undefined;}// Make sure pAddress (the address we are resolving) is a string
if(typeof pAddress!='string'){return undefined;}// Stash the parent address for later resolution
var tmpParentAddress="";if(typeof pParentAddress=='string'){tmpParentAddress=pParentAddress;}// Set the root object to the passed-in object if it isn't set yet.  This is expected to be the root object.
var tmpRootObject=typeof pRootObject=='undefined'?pObject:pRootObject;// DONE: Make this work for things like SomeRootObject.Metadata["Some.People.Use.Bad.Object.Property.Names"]
var tmpAddressPartBeginning=_MockFable.DataFormat.stringGetFirstSegment(pAddress);// Adding simple back-navigation in objects
if(tmpAddressPartBeginning==''){// Given an address of "Bundle.Contract.IDContract...Project.IDProject" the ... would be interpreted as two back-navigations from IDContract.
// When the address is passed in, though, the first . is already eliminated.  So we can count the dots.
var tmpParentAddressParts=_MockFable.DataFormat.stringGetSegments(tmpParentAddress);var tmpBackNavigationCount=0;// Count the number of dots
for(var i=0;i<pAddress.length;i++){if(pAddress.charAt(i)!='.'){break;}tmpBackNavigationCount++;}var tmpParentAddressLength=tmpParentAddressParts.length-tmpBackNavigationCount;if(tmpParentAddressLength<0){// We are trying to back navigate more than we can.
// TODO: Should this be undefined or should we bank out at the bottom and try to go forward?
// This seems safest for now.
return undefined;}else{// We are trying to back navigate to a parent object.
// Recurse with the back-propagated parent address, and, the new address without the back-navigation dots.
var tmpRecurseAddress=pAddress.slice(tmpBackNavigationCount);if(tmpParentAddressLength>0){tmpRecurseAddress="".concat(tmpParentAddressParts.slice(0,tmpParentAddressLength).join('.'),".").concat(tmpRecurseAddress);}this.logInfo("Back-navigation detected.  Recursing back to address [".concat(tmpRecurseAddress,"]"));return this.getValueAtAddress(tmpRootObject,tmpRecurseAddress);}}// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)
if(tmpAddressPartBeginning.length==pAddress.length){// TODO: Optimize this by having these calls only happen when the previous fails.
// TODO: Alternatively look for all markers in one pass?
// Check if the address refers to a boxed property
var tmpBracketStartIndex=pAddress.indexOf('[');var tmpBracketStopIndex=pAddress.indexOf(']');// Check for the Object Set Type marker.
// Note this will not work with a bracket in the same address box set
var tmpObjectTypeMarkerIndex=pAddress.indexOf('{}');// Check if there is a function somewhere in the address... parenthesis start should only be in a function
var tmpFunctionStartIndex=pAddress.indexOf('(');// NOTE THAT FUNCTIONS MUST RESOLVE FIRST
// Functions look like this
// 		MyFunction()
// 		MyFunction(Some.Address)
// 		MyFunction(Some.Address,Some.Other.Address)
// 		MyFunction(Some.Address,Some.Other.Address,Some.Third.Address)
//
// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,
// To heck with that.  This is a simple function call.
//
// The requirements to detect a function are:
//    1) The start bracket is after character 0
if(tmpFunctionStartIndex>0//    2) The end bracket is after the start bracket
&&_MockFable.DataFormat.stringCountEnclosures(pAddress)>0){var tmpFunctionAddress=pAddress.substring(0,tmpFunctionStartIndex).trim();if(!_typeof(pObject[tmpFunctionAddress])=='function'){// The address suggests it is a function, but it is not.
return false;}// Now see if the function has arguments.
// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *
var tmpFunctionArguments=_MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(pAddress.substring(tmpFunctionAddress.length),0),',');if(tmpFunctionArguments.length==0||tmpFunctionArguments[0]==''){// No arguments... just call the function (bound to the scope of the object it is contained withing)
if(tmpFunctionAddress in pObject){try{return pObject[tmpFunctionAddress].apply(pObject);}catch(pError){// The function call failed, so the address doesn't exist
console.log("Error in getValueAtAddress calling function ".concat(tmpFunctionAddress," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
console.log("Function ".concat(tmpFunctionAddress," does not exist (address [").concat(pAddress,"])"));return false;}}else{var tmpArgumentValues=[];var _tmpRootObject2=typeof pRootObject=='undefined'?pObject:pRootObject;// Now get the value for each argument
for(var _i27=0;_i27<tmpFunctionArguments.length;_i27++){// Resolve the values for each subsequent entry
// Check if the argument value is a string literal or a reference to an address
if(tmpFunctionArguments[_i27].length>=2&&(tmpFunctionArguments[_i27].charAt(0)=='"'||tmpFunctionArguments[_i27].charAt(0)=="'"||tmpFunctionArguments[_i27].charAt(0)=="`")&&(tmpFunctionArguments[_i27].charAt(tmpFunctionArguments[_i27].length-1)=='"'||tmpFunctionArguments[_i27].charAt(tmpFunctionArguments[_i27].length-1)=="'"||tmpFunctionArguments[_i27].charAt(tmpFunctionArguments[_i27].length-1)=="`")){// This is a string literal
tmpArgumentValues.push(tmpFunctionArguments[_i27].substring(1,tmpFunctionArguments[_i27].length-1));}else{// This is a hash address
tmpArgumentValues.push(this.getValueAtAddress(_tmpRootObject2,tmpFunctionArguments[_i27]));}}if(tmpFunctionAddress in pObject){try{return pObject[tmpFunctionAddress].apply(pObject,tmpArgumentValues);}catch(pError){// The function call failed, so the address doesn't exist
console.log("Error in getValueAtAddress calling function ".concat(tmpFunctionAddress," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
console.log("Function ".concat(tmpFunctionAddress," does not exist (address [").concat(pAddress,"])"));return false;}}}// Boxed elements look like this:
// 		MyValues[10]
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
else if(tmpBracketStartIndex>0//    2) The end bracket has something between them
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is data
&&tmpBracketStopIndex-tmpBracketStartIndex>1){// The "Name" of the Object contained too the left of the bracket
var tmpBoxedPropertyName=pAddress.substring(0,tmpBracketStartIndex).trim();// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.
// This is a rare case where Arrays testing as Objects is useful
if(_typeof(pObject[tmpBoxedPropertyName])!=='object'){return undefined;}// The "Reference" to the property within it, either an array element or object property
var tmpBoxedPropertyReference=pAddress.substring(tmpBracketStartIndex+1,tmpBracketStopIndex).trim();// Attempt to parse the reference as a number, which will be used as an array element
var tmpBoxedPropertyNumber=parseInt(tmpBoxedPropertyReference,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
if(Array.isArray(pObject[tmpBoxedPropertyName])==isNaN(tmpBoxedPropertyNumber)){return undefined;}//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to treat it as a dynamic object property.
if(isNaN(tmpBoxedPropertyNumber)){// This isn't a number ... let's treat it as a dynamic object property.
// We would expect the property to be wrapped in some kind of quotes so strip them
tmpBoxedPropertyReference=this.cleanWrapCharacters('"',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters('`',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters("'",tmpBoxedPropertyReference);// Return the value in the property
return pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];}else{return pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];}}// The requirements to detect a boxed set element are:
//    1) The start bracket is after character 0
else if(tmpBracketStartIndex>0//    2) The end bracket is after the start bracket
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is nothing in the brackets
&&tmpBracketStopIndex-tmpBracketStartIndex==1){var _tmpBoxedPropertyName5=pAddress.substring(0,tmpBracketStartIndex).trim();if(!Array.isArray(pObject[_tmpBoxedPropertyName5])){// We asked for a set from an array but it isnt' an array.
return false;}var tmpInputArray=pObject[_tmpBoxedPropertyName5];var tmpOutputArray=[];for(var _i28=0;_i28<tmpInputArray.length;_i28++){// The filtering is complex but allows config-based metaprogramming directly from schema
var tmpKeepRecord=this.checkRecordFilters(pAddress,tmpInputArray[_i28]);if(tmpKeepRecord){tmpOutputArray.push(tmpInputArray[_i28]);}}return tmpOutputArray;}// The object has been flagged as an object set, so treat it as such
else if(tmpObjectTypeMarkerIndex>0){var tmpObjectPropertyName=pAddress.substring(0,tmpObjectTypeMarkerIndex).trim();if(_typeof(pObject[tmpObjectPropertyName])!='object'){// We asked for a set from an array but it isnt' an array.
return false;}return pObject[tmpObjectPropertyName];}else{// Now is the point in recursion to return the value in the address
if(_typeof(pObject[pAddress])!=null){return pObject[pAddress];}else{return null;}}}else{//let tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);
//let tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);
var tmpSubObjectName=tmpAddressPartBeginning;var tmpNewAddress=pAddress.substring(tmpAddressPartBeginning.length+1);// BOXED ELEMENTS
// Test if the tmpNewAddress is an array or object
// Check if it's a boxed property
var _tmpBracketStartIndex3=tmpSubObjectName.indexOf('[');var _tmpBracketStopIndex3=tmpSubObjectName.indexOf(']');// Check if there is a function somewhere in the address... parenthesis start should only be in a function
var _tmpFunctionStartIndex2=tmpSubObjectName.indexOf('(');// NOTE THAT FUNCTIONS MUST RESOLVE FIRST
// Functions look like this
// 		MyFunction()
// 		MyFunction(Some.Address)
// 		MyFunction(Some.Address,Some.Other.Address)
// 		MyFunction(Some.Address,Some.Other.Address,Some.Third.Address)
//
// This could be enhanced to allow purely numeric and string values to be passed to the function.  For now,
// To heck with that.  This is a simple function call.
//
// The requirements to detect a function are:
//    1) The start bracket is after character 0
if(_tmpFunctionStartIndex2>0//    2) The end bracket is after the start bracket
&&_MockFable.DataFormat.stringCountEnclosures(tmpSubObjectName)>0){var _tmpFunctionAddress2=tmpSubObjectName.substring(0,_tmpFunctionStartIndex2).trim();tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);if(!_typeof(pObject[_tmpFunctionAddress2])=='function'){// The address suggests it is a function, but it is not.
return false;}// Now see if the function has arguments.
// Implementation notes: * ARGUMENTS MUST SHARE THE SAME ROOT OBJECT CONTEXT *
var _tmpFunctionArguments=_MockFable.DataFormat.stringGetSegments(_MockFable.DataFormat.stringGetEnclosureValueByIndex(tmpSubObjectName.substring(_tmpFunctionAddress2.length),0),',');if(_tmpFunctionArguments.length==0||_tmpFunctionArguments[0]==''){// No arguments... just call the function (bound to the scope of the object it is contained withing)
if(_tmpFunctionAddress2 in pObject){try{return this.getValueAtAddress(pObject[_tmpFunctionAddress2].apply(pObject),tmpNewAddress,tmpParentAddress,tmpRootObject);}catch(pError){// The function call failed, so the address doesn't exist
console.log("Error in getValueAtAddress calling function ".concat(_tmpFunctionAddress2," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
console.log("Function ".concat(_tmpFunctionAddress2," does not exist (address [").concat(pAddress,"])"));return false;}}else{var _tmpArgumentValues=[];var _tmpRootObject3=typeof pRootObject=='undefined'?pObject:pRootObject;// Now get the value for each argument
for(var _i29=0;_i29<_tmpFunctionArguments.length;_i29++){// Resolve the values for each subsequent entry
// Check if the argument value is a string literal or a reference to an address
if(_tmpFunctionArguments[_i29].length>=2&&(_tmpFunctionArguments[_i29].charAt(0)=='"'||_tmpFunctionArguments[_i29].charAt(0)=="'"||_tmpFunctionArguments[_i29].charAt(0)=="`")&&(_tmpFunctionArguments[_i29].charAt(_tmpFunctionArguments[_i29].length-1)=='"'||_tmpFunctionArguments[_i29].charAt(_tmpFunctionArguments[_i29].length-1)=="'"||_tmpFunctionArguments[_i29].charAt(_tmpFunctionArguments[_i29].length-1)=="`")){// This is a string literal
_tmpArgumentValues.push(_tmpFunctionArguments[_i29].substring(1,_tmpFunctionArguments[_i29].length-1));}else{// This is a hash address
_tmpArgumentValues.push(this.getValueAtAddress(_tmpRootObject3,_tmpFunctionArguments[_i29]));}}if(_tmpFunctionAddress2 in pObject){try{return this.getValueAtAddress(pObject[_tmpFunctionAddress2].apply(pObject,_tmpArgumentValues),tmpNewAddress,tmpParentAddress,_tmpRootObject3);}catch(pError){// The function call failed, so the address doesn't exist
console.log("Error in getValueAtAddress calling function ".concat(_tmpFunctionAddress2," (address [").concat(pAddress,"]): ").concat(pError.message));return false;}}else{// The function doesn't exist, so the address doesn't exist
console.log("Function ".concat(_tmpFunctionAddress2," does not exist (address [").concat(pAddress,"])"));return false;}}}// Boxed elements look like this:
// 		MyValues[42]
// 		MyValues['Color']
// 		MyValues["Weight"]
// 		MyValues[`Diameter`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
else if(_tmpBracketStartIndex3>0//    2) The end bracket has something between them
&&_tmpBracketStopIndex3>_tmpBracketStartIndex3//    3) There is data
&&_tmpBracketStopIndex3-_tmpBracketStartIndex3>1){var _tmpBoxedPropertyName6=tmpSubObjectName.substring(0,_tmpBracketStartIndex3).trim();var _tmpBoxedPropertyReference3=tmpSubObjectName.substring(_tmpBracketStartIndex3+1,_tmpBracketStopIndex3).trim();var _tmpBoxedPropertyNumber3=parseInt(_tmpBoxedPropertyReference3,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students[1].Tardy
//       BUT
//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students["JaneDoe"].Grade
//       BUT
//         StudentData.Sections.Algebra.Students is an array, so the ["JaneDoe"].Grade is not possible to access
// TODO: Should this be an error or something?  Should we keep a log of failures like this?
if(Array.isArray(pObject[_tmpBoxedPropertyName6])==isNaN(_tmpBoxedPropertyNumber3)){return undefined;}// Check if the boxed property is an object.
if(_typeof(pObject[_tmpBoxedPropertyName6])!='object'){return undefined;}//This is a bracketed value
//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to reat it as a dynamic object property.
if(isNaN(_tmpBoxedPropertyNumber3)){// This isn't a number ... let's treat it as a dynanmic object property.
_tmpBoxedPropertyReference3=this.cleanWrapCharacters('"',_tmpBoxedPropertyReference3);_tmpBoxedPropertyReference3=this.cleanWrapCharacters('`',_tmpBoxedPropertyReference3);_tmpBoxedPropertyReference3=this.cleanWrapCharacters("'",_tmpBoxedPropertyReference3);// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);// Recurse directly into the subobject
return this.getValueAtAddress(pObject[_tmpBoxedPropertyName6][_tmpBoxedPropertyReference3],tmpNewAddress,tmpParentAddress,tmpRootObject);}else{// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);// We parsed a valid number out of the boxed property name, so recurse into the array
return this.getValueAtAddress(pObject[_tmpBoxedPropertyName6][_tmpBoxedPropertyNumber3],tmpNewAddress,tmpParentAddress,tmpRootObject);}}// The requirements to detect a boxed set element are:
//    1) The start bracket is after character 0
else if(_tmpBracketStartIndex3>0//    2) The end bracket is after the start bracket
&&_tmpBracketStopIndex3>_tmpBracketStartIndex3//    3) There is nothing in the brackets
&&_tmpBracketStopIndex3-_tmpBracketStartIndex3==1){var _tmpBoxedPropertyName7=pAddress.substring(0,_tmpBracketStartIndex3).trim();if(!Array.isArray(pObject[_tmpBoxedPropertyName7])){// We asked for a set from an array but it isnt' an array.
return false;}// We need to enumerate the array and grab the addresses from there.
var tmpArrayProperty=pObject[_tmpBoxedPropertyName7];// Managing the parent address is a bit more complex here -- the box will be added for each element.
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(_tmpBoxedPropertyName7);// The container object is where we have the "Address":SOMEVALUE pairs
var tmpContainerObject={};for(var _i30=0;_i30<tmpArrayProperty.length;_i30++){var tmpPropertyParentAddress="".concat(tmpParentAddress,"[").concat(_i30,"]");var tmpValue=this.getValueAtAddress(pObject[_tmpBoxedPropertyName7][_i30],tmpNewAddress,tmpPropertyParentAddress,tmpRootObject);tmpContainerObject["".concat(tmpPropertyParentAddress,".").concat(tmpNewAddress)]=tmpValue;}return tmpContainerObject;}// OBJECT SET
// Note this will not work with a bracket in the same address box set
var _tmpObjectTypeMarkerIndex2=pAddress.indexOf('{}');if(_tmpObjectTypeMarkerIndex2>0){var _tmpObjectPropertyName2=pAddress.substring(0,_tmpObjectTypeMarkerIndex2).trim();if(_typeof(pObject[_tmpObjectPropertyName2])!='object'){// We asked for a set from an array but it isnt' an array.
return false;}// We need to enumerate the Object and grab the addresses from there.
var tmpObjectProperty=pObject[_tmpObjectPropertyName2];var tmpObjectPropertyKeys=Object.keys(tmpObjectProperty);// Managing the parent address is a bit more complex here -- the box will be added for each element.
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(_tmpObjectPropertyName2);// The container object is where we have the "Address":SOMEVALUE pairs
var _tmpContainerObject2={};for(var _i31=0;_i31<tmpObjectPropertyKeys.length;_i31++){var _tmpPropertyParentAddress2="".concat(tmpParentAddress,".").concat(tmpObjectPropertyKeys[_i31]);var _tmpValue4=this.getValueAtAddress(pObject[_tmpObjectPropertyName2][tmpObjectPropertyKeys[_i31]],tmpNewAddress,_tmpPropertyParentAddress2,tmpRootObject);// The filtering is complex but allows config-based metaprogramming directly from schema
var _tmpKeepRecord2=this.checkRecordFilters(pAddress,_tmpValue4);if(_tmpKeepRecord2){_tmpContainerObject2["".concat(_tmpPropertyParentAddress2,".").concat(tmpNewAddress)]=_tmpValue4;}}return _tmpContainerObject2;}// If there is an object property already named for the sub object, but it isn't an object
// then the system can't set the value in there.  Error and abort!
if(tmpSubObjectName in pObject&&_typeof(pObject[tmpSubObjectName])!=='object'){return undefined;}else if(tmpSubObjectName in pObject){// If there is already a subobject pass that to the recursive thingy
// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);return this.getValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,tmpParentAddress,tmpRootObject);}else{// Create a subobject and then pass that
// Continue to manage the parent address for recursion
tmpParentAddress="".concat(tmpParentAddress).concat(tmpParentAddress.length>0?'.':'').concat(tmpSubObjectName);pObject[tmpSubObjectName]={};return this.getValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,tmpParentAddress,tmpRootObject);}}}}]);}();;module.exports=ManyfestObjectAddressResolverGetValue;},{"../source/Manyfest-ParseConditionals.js":122,"./Manyfest-CleanWrapCharacters.js":113,"./Manyfest-LogToConsole.js":115,"./Manyfest-ObjectAddress-Parser.js":119}],119:[function(require,module,exports){// TODO: This is an inelegant solution to delay the rewrite of Manyfest.
// Fable 3.0 has a service for data formatting that deals well with nested enclosures.
// The Manyfest library predates fable 3.0 and the services structure of it, so the functions
// are more or less pure javascript and as functional as they can be made to be.
// Until we shift Manyfest to be a fable service, these three functions were pulled out of
// fable to aid in parsing functions with nested enclosures.
module.exports={/**
	 * Count the number of segments in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the count of segments in the string as a number
	 */stringCountSegments:function stringCountSegments(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2};if(pString.length<1){return 0;}var tmpSegmentCount=1;var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Increment the segment count
tmpSegmentCount++;}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}return tmpSegmentCount;},/**
	 * Get the first segment in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the first segment in the string as a string
	 */stringGetFirstSegment:function stringGetFirstSegment(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2};if(pString.length<1){return 0;}var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Return the segment
return tmpString.substring(0,i);}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}return tmpString;},/**
	 * Get all segments in a string, respecting enclosures
	 * 
	 * @param {string} pString 
	 * @param {string} pSeparator 
	 * @param {object} pEnclosureStartSymbolMap 
	 * @param {object} pEnclosureEndSymbolMap 
	 * @returns the first segment in the string as a string
	 */stringGetSegments:function stringGetSegments(pString,pSeparator,pEnclosureStartSymbolMap,pEnclosureEndSymbolMap){var tmpString=typeof pString=='string'?pString:'';var tmpSeparator=typeof pSeparator=='string'?pSeparator:'.';var tmpEnclosureStartSymbolMap=_typeof(pEnclosureStartSymbolMap)=='object'?pEnclosureStart:{'{':0,'[':1,'(':2};var tmpEnclosureEndSymbolMap=_typeof(pEnclosureEndSymbolMap)=='object'?pEnclosureEnd:{'}':0,']':1,')':2};var tmpCurrentSegmentStart=0;var tmpSegmentList=[];if(pString.length<1){return tmpSegmentList;}var tmpEnclosureStack=[];for(var i=0;i<tmpString.length;i++){// IF This is the start of a segment
if(tmpString[i]==tmpSeparator// AND we are not in a nested portion of the string
&&tmpEnclosureStack.length==0){// Return the segment
tmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart,i));tmpCurrentSegmentStart=i+1;}// IF This is the start of an enclosure
else if(tmpString[i]in tmpEnclosureStartSymbolMap){// Add it to the stack!
tmpEnclosureStack.push(tmpEnclosureStartSymbolMap[tmpString[i]]);}// IF This is the end of an enclosure
else if(tmpString[i]in tmpEnclosureEndSymbolMap// AND it matches the current nest level symbol
&&tmpEnclosureEndSymbolMap[tmpString[i]]==tmpEnclosureStack[tmpEnclosureStack.length-1]){// Pop it off the stack!
tmpEnclosureStack.pop();}}if(tmpCurrentSegmentStart<tmpString.length){tmpSegmentList.push(tmpString.substring(tmpCurrentSegmentStart));}return tmpSegmentList;},/**
	 * Count the number of enclosures in a string based on the start and end characters.
	 *
	 * If no start or end characters are specified, it will default to parentheses.  If the string is not a string, it will return 0.
	 *
	 * @param {string} pString
	 * @param {string} pEnclosureStart
	 * @param {string} pEnclosureEnd
	 * @returns the count of full in the string
	 */stringCountEnclosures:function stringCountEnclosures(pString,pEnclosureStart,pEnclosureEnd){var tmpString=typeof pString=='string'?pString:'';var tmpEnclosureStart=typeof pEnclosureStart=='string'?pEnclosureStart:'(';var tmpEnclosureEnd=typeof pEnclosureEnd=='string'?pEnclosureEnd:')';var tmpEnclosureCount=0;var tmpEnclosureDepth=0;for(var i=0;i<tmpString.length;i++){// This is the start of an enclosure
if(tmpString[i]==tmpEnclosureStart){if(tmpEnclosureDepth==0){tmpEnclosureCount++;}tmpEnclosureDepth++;}else if(tmpString[i]==tmpEnclosureEnd){tmpEnclosureDepth--;}}return tmpEnclosureCount;},/**
	 * Get the value of the enclosure at the specified index.
	 *
	 * If the index is not a number, it will default to 0.  If the string is not a string, it will return an empty string.  If the enclosure is not found, it will return an empty string.  If the enclosure
	 *
	 * @param {string} pString
	 * @param {number} pEnclosureIndexToGet
	 * @param {string} pEnclosureStart
	 * @param {string}} pEnclosureEnd
	 * @returns {string}
	 */stringGetEnclosureValueByIndex:function stringGetEnclosureValueByIndex(pString,pEnclosureIndexToGet,pEnclosureStart,pEnclosureEnd){var tmpString=typeof pString=='string'?pString:'';var tmpEnclosureIndexToGet=typeof pEnclosureIndexToGet=='number'?pEnclosureIndexToGet:0;var tmpEnclosureStart=typeof pEnclosureStart=='string'?pEnclosureStart:'(';var tmpEnclosureEnd=typeof pEnclosureEnd=='string'?pEnclosureEnd:')';var tmpEnclosureCount=0;var tmpEnclosureDepth=0;var tmpMatchedEnclosureIndex=false;var tmpEnclosedValueStartIndex=0;var tmpEnclosedValueEndIndex=0;for(var i=0;i<tmpString.length;i++){// This is the start of an enclosure
if(tmpString[i]==tmpEnclosureStart){tmpEnclosureDepth++;// Only count enclosures at depth 1, but still this parses both pairs of all of them.
if(tmpEnclosureDepth==1){tmpEnclosureCount++;if(tmpEnclosureIndexToGet==tmpEnclosureCount-1){// This is the start of *the* enclosure
tmpMatchedEnclosureIndex=true;tmpEnclosedValueStartIndex=i;}}}// This is the end of an enclosure
else if(tmpString[i]==tmpEnclosureEnd){tmpEnclosureDepth--;// Again, only count enclosures at depth 1, but still this parses both pairs of all of them.
if(tmpEnclosureDepth==0&&tmpMatchedEnclosureIndex&&tmpEnclosedValueEndIndex<=tmpEnclosedValueStartIndex){tmpEnclosedValueEndIndex=i;tmpMatchedEnclosureIndex=false;}}}if(tmpEnclosureCount<=tmpEnclosureIndexToGet){// Return an empty string if the enclosure is not found
return'';}if(tmpEnclosedValueEndIndex>0&&tmpEnclosedValueEndIndex>tmpEnclosedValueStartIndex){return tmpString.substring(tmpEnclosedValueStartIndex+1,tmpEnclosedValueEndIndex);}else{return tmpString.substring(tmpEnclosedValueStartIndex+1);}}};},{}],120:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');var fCleanWrapCharacters=require('./Manyfest-CleanWrapCharacters.js');/**
* Object Address Resolver - SetValue
*
* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to
*                 be extremely clear what is going on in the recursion for
*                 each of the three address resolution functions.
*
*                 Although there is some opportunity to repeat ourselves a
*                 bit less in this codebase (e.g. with detection of arrays
*                 versus objects versus direct properties), it can make
*                 debugging.. challenging.  The minified version of the code
*                 optimizes out almost anything repeated in here.  So please
*                 be kind and rewind... meaning please keep the codebase less
*                 terse and more verbose so humans can comprehend it.
*
*
* @class ManyfestObjectAddressSetValue
*/var ManyfestObjectAddressSetValue=/*#__PURE__*/function(){function ManyfestObjectAddressSetValue(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestObjectAddressSetValue);// Wire in logging
this.logInfo=typeof pInfoLog=='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog=='function'?pErrorLog:libSimpleLog;this.cleanWrapCharacters=fCleanWrapCharacters;}// Set the value of an element at an address
return _createClass2(ManyfestObjectAddressSetValue,[{key:"setValueAtAddress",value:function setValueAtAddress(pObject,pAddress,pValue){// Make sure pObject is an object
if(_typeof(pObject)!='object')return false;// Make sure pAddress is a string
if(typeof pAddress!='string')return false;var tmpSeparatorIndex=pAddress.indexOf('.');if(tmpSeparatorIndex==-1){// Check if it's a boxed property
var tmpBracketStartIndex=pAddress.indexOf('[');var tmpBracketStopIndex=pAddress.indexOf(']');// Boxed elements look like this:
// 		MyValues[10]
// 		MyValues['Name']
// 		MyValues["Age"]
// 		MyValues[`Cost`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
if(tmpBracketStartIndex>0//    2) The end bracket has something between them
&&tmpBracketStopIndex>tmpBracketStartIndex//    3) There is data
&&tmpBracketStopIndex-tmpBracketStartIndex>1){// The "Name" of the Object contained too the left of the bracket
var tmpBoxedPropertyName=pAddress.substring(0,tmpBracketStartIndex).trim();// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.
// This is a rare case where Arrays testing as Objects is useful
if(_typeof(pObject[tmpBoxedPropertyName])!=='object'){return false;}// The "Reference" to the property within it, either an array element or object property
var tmpBoxedPropertyReference=pAddress.substring(tmpBracketStartIndex+1,tmpBracketStopIndex).trim();// Attempt to parse the reference as a number, which will be used as an array element
var tmpBoxedPropertyNumber=parseInt(tmpBoxedPropertyReference,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
if(Array.isArray(pObject[tmpBoxedPropertyName])==isNaN(tmpBoxedPropertyNumber)){return false;}//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to treat it as a dynamic object property.
if(isNaN(tmpBoxedPropertyNumber)){// This isn't a number ... let's treat it as a dynamic object property.
// We would expect the property to be wrapped in some kind of quotes so strip them
tmpBoxedPropertyReference=this.cleanWrapCharacters('"',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters('`',tmpBoxedPropertyReference);tmpBoxedPropertyReference=this.cleanWrapCharacters("'",tmpBoxedPropertyReference);// Return the value in the property
pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference]=pValue;return true;}else{pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber]=pValue;return true;}}else{// Now is the time in recursion to set the value in the object
pObject[pAddress]=pValue;return true;}}else{var tmpSubObjectName=pAddress.substring(0,tmpSeparatorIndex);var tmpNewAddress=pAddress.substring(tmpSeparatorIndex+1);// Test if the tmpNewAddress is an array or object
// Check if it's a boxed property
var _tmpBracketStartIndex4=tmpSubObjectName.indexOf('[');var _tmpBracketStopIndex4=tmpSubObjectName.indexOf(']');// Boxed elements look like this:
// 		MyValues[42]
// 		MyValues['Color']
// 		MyValues["Weight"]
// 		MyValues[`Diameter`]
//
// When we are passed SomeObject["Name"] this code below recurses as if it were SomeObject.Name
// The requirements to detect a boxed element are:
//    1) The start bracket is after character 0
if(_tmpBracketStartIndex4>0//    2) The end bracket has something between them
&&_tmpBracketStopIndex4>_tmpBracketStartIndex4//    3) There is data
&&_tmpBracketStopIndex4-_tmpBracketStartIndex4>1){var _tmpBoxedPropertyName8=tmpSubObjectName.substring(0,_tmpBracketStartIndex4).trim();var _tmpBoxedPropertyReference4=tmpSubObjectName.substring(_tmpBracketStartIndex4+1,_tmpBracketStopIndex4).trim();var _tmpBoxedPropertyNumber4=parseInt(_tmpBoxedPropertyReference4,10);// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.
//        This seems confusing to me at first read, so explaination:
//        Is the Boxed Object an Array?  TRUE
//        And is the Reference inside the boxed Object not a number? TRUE
//        -->  So when these are in agreement, it's an impossible access state
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students[1].Tardy
//       BUT
//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access
// This could be a failure in the recursion chain because they passed something like this in:
//    StudentData.Sections.Algebra.Students["JaneDoe"].Grade
//       BUT
//         StudentData.Sections.Algebra.Students is an array, so the ["JaneDoe"].Grade is not possible to access
// TODO: Should this be an error or something?  Should we keep a log of failures like this?
if(Array.isArray(pObject[_tmpBoxedPropertyName8])==isNaN(_tmpBoxedPropertyNumber4)){return false;}//This is a bracketed value
//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,
//       otherwise we will try to reat it as a dynamic object property.
if(isNaN(_tmpBoxedPropertyNumber4)){// This isn't a number ... let's treat it as a dynanmic object property.
_tmpBoxedPropertyReference4=this.cleanWrapCharacters('"',_tmpBoxedPropertyReference4);_tmpBoxedPropertyReference4=this.cleanWrapCharacters('`',_tmpBoxedPropertyReference4);_tmpBoxedPropertyReference4=this.cleanWrapCharacters("'",_tmpBoxedPropertyReference4);// Recurse directly into the subobject
return this.setValueAtAddress(pObject[_tmpBoxedPropertyName8][_tmpBoxedPropertyReference4],tmpNewAddress,pValue);}else{// We parsed a valid number out of the boxed property name, so recurse into the array
return this.setValueAtAddress(pObject[_tmpBoxedPropertyName8][_tmpBoxedPropertyNumber4],tmpNewAddress,pValue);}}// If there is an object property already named for the sub object, but it isn't an object
// then the system can't set the value in there.  Error and abort!
if(tmpSubObjectName in pObject&&_typeof(pObject[tmpSubObjectName])!=='object'){if(!('__ERROR'in pObject))pObject['__ERROR']={};// Put it in an error object so data isn't lost
pObject['__ERROR'][pAddress]=pValue;return false;}else if(tmpSubObjectName in pObject){// If there is already a subobject pass that to the recursive thingy
return this.setValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,pValue);}else{// Create a subobject and then pass that
pObject[tmpSubObjectName]={};return this.setValueAtAddress(pObject[tmpSubObjectName],tmpNewAddress,pValue);}}}}]);}();;module.exports=ManyfestObjectAddressSetValue;},{"./Manyfest-CleanWrapCharacters.js":113,"./Manyfest-LogToConsole.js":115}],121:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');/**
* Object Address Generation
*
* Automagically generate addresses and properties based on a passed-in object,
* to be used for easy creation of schemas.  Meant to simplify the lives of
* developers wanting to create schemas without typing a bunch of stuff.
*
* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to
*                 be extremely clear what is going on in the recursion for
*                 each of the three address resolution functions.
*
*                 Although there is some opportunity to repeat ourselves a
*                 bit less in this codebase (e.g. with detection of arrays
*                 versus objects versus direct properties), it can make
*                 debugging.. challenging.  The minified version of the code
*                 optimizes out almost anything repeated in here.  So please
*                 be kind and rewind... meaning please keep the codebase less
*                 terse and more verbose so humans can comprehend it.
*
*
* @class ManyfestObjectAddressGeneration
*/var ManyfestObjectAddressGeneration=/*#__PURE__*/function(){function ManyfestObjectAddressGeneration(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestObjectAddressGeneration);// Wire in logging
this.logInfo=typeof pInfoLog=='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog=='function'?pErrorLog:libSimpleLog;}// generateAddressses
//
// This flattens an object into a set of key:value pairs for *EVERY SINGLE
// POSSIBLE ADDRESS* in the object.  It can get ... really insane really
// quickly.  This is not meant to be used directly to generate schemas, but
// instead as a starting point for scripts or UIs.
//
// This will return a mega set of key:value pairs with all possible schema
// permutations and default values (when not an object) and everything else.
return _createClass2(ManyfestObjectAddressGeneration,[{key:"generateAddressses",value:function generateAddressses(pObject,pBaseAddress,pSchema){var tmpBaseAddress=typeof pBaseAddress=='string'?pBaseAddress:'';var tmpSchema=_typeof(pSchema)=='object'?pSchema:{};var tmpObjectType=_typeof(pObject);var tmpSchemaObjectEntry={Address:tmpBaseAddress,Hash:tmpBaseAddress,Name:tmpBaseAddress,// This is so scripts and UI controls can force a developer to opt-in.
InSchema:false};if(tmpObjectType=='object'&&pObject==null){tmpObjectType='null';}switch(tmpObjectType){case'string':tmpSchemaObjectEntry.DataType='String';tmpSchemaObjectEntry.Default=pObject;tmpSchema[tmpBaseAddress]=tmpSchemaObjectEntry;break;case'number':case'bigint':tmpSchemaObjectEntry.DataType='Number';tmpSchemaObjectEntry.Default=pObject;tmpSchema[tmpBaseAddress]=tmpSchemaObjectEntry;break;case'undefined':case'null':tmpSchemaObjectEntry.DataType='Any';tmpSchemaObjectEntry.Default=pObject;tmpSchema[tmpBaseAddress]=tmpSchemaObjectEntry;break;case'object':if(Array.isArray(pObject)){tmpSchemaObjectEntry.DataType='Array';if(tmpBaseAddress!=''){tmpSchema[tmpBaseAddress]=tmpSchemaObjectEntry;}for(var i=0;i<pObject.length;i++){this.generateAddressses(pObject[i],"".concat(tmpBaseAddress,"[").concat(i,"]"),tmpSchema);}}else{tmpSchemaObjectEntry.DataType='Object';if(tmpBaseAddress!=''){tmpSchema[tmpBaseAddress]=tmpSchemaObjectEntry;tmpBaseAddress+='.';}var tmpObjectProperties=Object.keys(pObject);for(var _i32=0;_i32<tmpObjectProperties.length;_i32++){this.generateAddressses(pObject[tmpObjectProperties[_i32]],"".concat(tmpBaseAddress).concat(tmpObjectProperties[_i32]),tmpSchema);}}break;case'symbol':case'function':// Symbols and functions neither recurse nor get added to the schema
break;}return tmpSchema;}}]);}();;module.exports=ManyfestObjectAddressGeneration;},{"./Manyfest-LogToConsole.js":115}],122:[function(require,module,exports){// Given a string, parse out any conditional expressions and set whether or not to keep the record.
//
// For instance:
// 		'files[]<<~?format,==,Thumbnail?~>>'
//      'files[]<<~?format,==,Metadata?~>>'
//      'files[]<<~?size,>,4000?~>>'
//
// The wrapping parts are the <<~? and ?~>> megabrackets.
//
// The function does not need to alter the string -- just check the conditionals within.
// TODO: Consider making this an es6 class
// Let's use indexOf since it is apparently the fastest.
var _ConditionalStanzaStart='<<~?';var _ConditionalStanzaStartLength=_ConditionalStanzaStart.length;var _ConditionalStanzaEnd='?~>>';var _ConditionalStanzaEndLength=_ConditionalStanzaEnd.length;// Ugh dependency injection.  Can't wait to make these all fable services.
//let libObjectAddressCheckAddressExists = new (require('./Manyfest-ObjectAddress-CheckAddressExists.js'))();
// Test the condition of a value in a record
var testCondition=function testCondition(pManyfest,pRecord,pSearchAddress,pSearchComparator,pValue){switch(pSearchComparator){case'TRUE':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)===true;break;case'FALSE':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)===false;break;case'LNGT':case'LENGTH_GREATER_THAN':switch(_typeof(pManyfest.getValueAtAddress(pRecord,pSearchAddress))){case'string':return pManyfest.getValueAtAddress(pRecord,pSearchAddress).length>pValue;break;case'object':return pManyfest.getValueAtAddress(pRecord,pSearchAddress).length>pValue;break;default:return false;break;}break;case'LNLT':case'LENGTH_LESS_THAN':switch(_typeof(pManyfest.getValueAtAddress(pRecord,pSearchAddress))){case'string':return pManyfest.getValueAtAddress(pRecord,pSearchAddress).length<pValue;break;case'object':return pManyfest.getValueAtAddress(pRecord,pSearchAddress).length<pValue;break;default:return false;break;}break;// TODO: Welcome to dependency hell.  This fixes itself when we move to fable services.
// case 'EX':
// case 'EXISTS':
// 	return libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);
// 	break;
// case 'DNEX':
// case 'DOES_NOT_EXIST':
// 	return !libObjectAddressCheckAddressExists.checkAddressExists(pRecord, pSearchAddress);
// 	break;
case'!=':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)!=pValue;break;case'<':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)<pValue;break;case'>':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)>pValue;break;case'<=':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)<=pValue;break;case'>=':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)>=pValue;break;case'===':return pManyfest.getValueAtAddress(pRecord,pSearchAddress)===pValue;break;case'==':default:return pManyfest.getValueAtAddress(pRecord,pSearchAddress)==pValue;break;}};var parseConditionals=function parseConditionals(pManyfest,pAddress,pRecord){var tmpKeepRecord=true;/*
		Algorithm is simple:

		1.  Enuerate start points
		2.  Find stop points within each start point
		3. Check the conditional
	*/var tmpStartIndex=pAddress.indexOf(_ConditionalStanzaStart);while(tmpStartIndex!=-1){var tmpStopIndex=pAddress.indexOf(_ConditionalStanzaEnd,tmpStartIndex+_ConditionalStanzaStartLength);if(tmpStopIndex!=-1){var tmpMagicComparisonPatternSet=pAddress.substring(tmpStartIndex+_ConditionalStanzaStartLength,tmpStopIndex).split(',');// The address to search for
var tmpSearchAddress=tmpMagicComparisonPatternSet[0];// The copmparison expression (EXISTS as default)
var tmpSearchComparator='EXISTS';if(tmpMagicComparisonPatternSet.length>1){tmpSearchComparator=tmpMagicComparisonPatternSet[1];}// The value to search for
var tmpSearchValue=false;if(tmpMagicComparisonPatternSet.length>2){tmpSearchValue=tmpMagicComparisonPatternSet[2];}// Process the piece
tmpKeepRecord=tmpKeepRecord&&testCondition(pManyfest,pRecord,tmpSearchAddress,tmpSearchComparator,tmpSearchValue);tmpStartIndex=pAddress.indexOf(_ConditionalStanzaStart,tmpStopIndex+_ConditionalStanzaEndLength);}else{tmpStartIndex=-1;}}return tmpKeepRecord;};module.exports=parseConditionals;},{}],123:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libSimpleLog=require('./Manyfest-LogToConsole.js');/**
* Schema Manipulation Functions
*
* @class ManyfestSchemaManipulation
*/var ManyfestSchemaManipulation=/*#__PURE__*/function(){function ManyfestSchemaManipulation(pInfoLog,pErrorLog){_classCallCheck2(this,ManyfestSchemaManipulation);// Wire in logging
this.logInfo=typeof pInfoLog==='function'?pInfoLog:libSimpleLog;this.logError=typeof pErrorLog==='function'?pErrorLog:libSimpleLog;}// This translates the default address mappings to something different.
//
// For instance you can pass in manyfest schema descriptor object:
// 	{
//	  "Address.Of.a": { "Hash": "a", "Type": "Number" },
//	  "Address.Of.b": { "Hash": "b", "Type": "Number" }
//  }
//
//
// And then an address mapping (basically a Hash->Address map)
//  {
//    "a": "New.Address.Of.a",
//    "b": "New.Address.Of.b"
//  }
//
// NOTE: This mutates the schema object permanently, altering the base hash.
//       If there is a collision with an existing address, it can lead to overwrites.
// TODO: Discuss what should happen on collisions.
return _createClass2(ManyfestSchemaManipulation,[{key:"resolveAddressMappings",value:function resolveAddressMappings(pManyfestSchemaDescriptors,pAddressMapping){if(_typeof(pManyfestSchemaDescriptors)!='object'){this.logError("Attempted to resolve address mapping but the descriptor was not an object.");return false;}if(_typeof(pAddressMapping)!='object'){// No mappings were passed in
return true;}// Get the arrays of both the schema definition and the hash mapping
var tmpManyfestAddresses=Object.keys(pManyfestSchemaDescriptors);var tmpHashMapping={};tmpManyfestAddresses.forEach(function(pAddress){if('Hash'in pManyfestSchemaDescriptors[pAddress]){tmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash]=pAddress;}});var tmpAddressMappingSet=Object.keys(pAddressMapping);tmpAddressMappingSet.forEach(function(pInputAddress){var tmpNewDescriptorAddress=pAddressMapping[pInputAddress];var tmpOldDescriptorAddress=false;var tmpDescriptor=false;// See if there is a matching descriptor either by Address directly or Hash
if(pInputAddress in pManyfestSchemaDescriptors){tmpOldDescriptorAddress=pInputAddress;}else if(pInputAddress in tmpHashMapping){tmpOldDescriptorAddress=tmpHashMapping[pInputAddress];}// If there was a matching descriptor in the manifest, store it in the temporary descriptor
if(tmpOldDescriptorAddress){tmpDescriptor=pManyfestSchemaDescriptors[tmpOldDescriptorAddress];delete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];}else{// Create a new descriptor!  Map it to the input address.
tmpDescriptor={Hash:pInputAddress};}// Now re-add the descriptor to the manyfest schema
pManyfestSchemaDescriptors[tmpNewDescriptorAddress]=tmpDescriptor;});return true;}},{key:"safeResolveAddressMappings",value:function safeResolveAddressMappings(pManyfestSchemaDescriptors,pAddressMapping){// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors
var tmpManyfestSchemaDescriptors=JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));this.resolveAddressMappings(tmpManyfestSchemaDescriptors,pAddressMapping);return tmpManyfestSchemaDescriptors;}},{key:"mergeAddressMappings",value:function mergeAddressMappings(pManyfestSchemaDescriptorsDestination,pManyfestSchemaDescriptorsSource){if(_typeof(pManyfestSchemaDescriptorsSource)!='object'||_typeof(pManyfestSchemaDescriptorsDestination)!='object'){this.logError("Attempted to merge two schema descriptors but both were not objects.");return false;}var tmpSource=JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));var tmpNewManyfestSchemaDescriptors=JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));// The first passed-in set of descriptors takes precedence.
var tmpDescriptorAddresses=Object.keys(tmpSource);tmpDescriptorAddresses.forEach(function(pDescriptorAddress){if(!(pDescriptorAddress in tmpNewManyfestSchemaDescriptors)){tmpNewManyfestSchemaDescriptors[pDescriptorAddress]=tmpSource[pDescriptorAddress];}});return tmpNewManyfestSchemaDescriptors;}}]);}();module.exports=ManyfestSchemaManipulation;},{"./Manyfest-LogToConsole.js":115}],124:[function(require,module,exports){/**
* @author <steven@velozo.com>
*/var libFableServiceProviderBase=require('fable-serviceproviderbase');var libSimpleLog=require('./Manyfest-LogToConsole.js');var libHashTranslation=require('./Manyfest-HashTranslation.js');var libObjectAddressCheckAddressExists=require('./Manyfest-ObjectAddress-CheckAddressExists.js');var libObjectAddressGetValue=require('./Manyfest-ObjectAddress-GetValue.js');var libObjectAddressSetValue=require('./Manyfest-ObjectAddress-SetValue.js');var libObjectAddressDeleteValue=require('./Manyfest-ObjectAddress-DeleteValue.js');var libObjectAddressGeneration=require('./Manyfest-ObjectAddressGeneration.js');var libSchemaManipulation=require('./Manyfest-SchemaManipulation.js');var _DefaultConfiguration={Scope:'DEFAULT',Descriptors:{}};/**
* Manyfest object address-based descriptions and manipulations.
*
* @class Manyfest
*/var Manyfest=/*#__PURE__*/function(_libFableServiceProvi10){function Manyfest(pFable,pManifest,pServiceHash){var _this48;_classCallCheck2(this,Manyfest);if(pFable===undefined){_this48=_callSuper(this,Manyfest,[{}]);}else{_this48=_callSuper(this,Manyfest,[pFable,pManifest,pServiceHash]);}_this48.serviceType='Manifest';// Wire in logging
_this48.logInfo=libSimpleLog;_this48.logError=libSimpleLog;// Create an object address resolver and map in the functions
_this48.objectAddressCheckAddressExists=new libObjectAddressCheckAddressExists(_this48.logInfo,_this48.logError);_this48.objectAddressGetValue=new libObjectAddressGetValue(_this48.logInfo,_this48.logError);_this48.objectAddressSetValue=new libObjectAddressSetValue(_this48.logInfo,_this48.logError);_this48.objectAddressDeleteValue=new libObjectAddressDeleteValue(_this48.logInfo,_this48.logError);if(!('defaultValues'in _this48.options)){_this48.options.defaultValues={"String":"","Number":0,"Float":0.0,"Integer":0,"PreciseNumber":"0.0","Boolean":false,"Binary":0,"DateTime":0,"Array":[],"Object":{},"Null":null};}if(!('strict'in _this48.options)){_this48.options.strict=false;}_this48.scope=undefined;_this48.elementAddresses=undefined;_this48.elementHashes=undefined;_this48.elementDescriptors=undefined;_this48.reset();if(_typeof(_this48.options)==='object'){_this48.loadManifest(_this48.options);}_this48.schemaManipulations=new libSchemaManipulation(_this48.logInfo,_this48.logError);_this48.objectAddressGeneration=new libObjectAddressGeneration(_this48.logInfo,_this48.logError);_this48.hashTranslations=new libHashTranslation(_this48.logInfo,_this48.logError);_this48.numberRegex=/^[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;return _assertThisInitialized(_this48);}/*************************************************************************
	 * Schema Manifest Loading, Reading, Manipulation and Serialization Functions
	 */// Reset critical manifest properties
_inherits(Manyfest,_libFableServiceProvi10);return _createClass2(Manyfest,[{key:"reset",value:function reset(){this.scope='DEFAULT';this.elementAddresses=[];this.elementHashes={};this.elementDescriptors={};}},{key:"clone",value:function clone(){// Make a copy of the options in-place
var tmpNewOptions=JSON.parse(JSON.stringify(this.options));var tmpNewManyfest=new Manyfest(this.getManifest(),this.logInfo,this.logError,tmpNewOptions);// Import the hash translations
tmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);return tmpNewManyfest;}// Deserialize a Manifest from a string
},{key:"deserialize",value:function deserialize(pManifestString){// TODO: Add guards for bad manifest string
return this.loadManifest(JSON.parse(pManifestString));}// Load a manifest from an object
},{key:"loadManifest",value:function loadManifest(pManifest){if(_typeof(pManifest)!=='object'){this.logError("(".concat(this.scope,") Error loading manifest; expecting an object but parameter was type ").concat(_typeof(pManifest),"."));}var tmpManifest=_typeof(pManifest)=='object'?pManifest:{};var tmpDescriptorKeys=Object.keys(_DefaultConfiguration);for(var i=0;i<tmpDescriptorKeys.length;i++){if(!(tmpDescriptorKeys[i]in tmpManifest)){tmpManifest[tmpDescriptorKeys[i]]=JSON.parse(JSON.stringify(_DefaultConfiguration[tmpDescriptorKeys[i]]));}}if('Scope'in tmpManifest){if(typeof tmpManifest.Scope==='string'){this.scope=tmpManifest.Scope;}else{this.logError("(".concat(this.scope,") Error loading scope from manifest; expecting a string but property was type ").concat(_typeof(tmpManifest.Scope),"."),tmpManifest);}}else{this.logError("(".concat(this.scope,") Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object."),tmpManifest);}if('Descriptors'in tmpManifest){if(_typeof(tmpManifest.Descriptors)==='object'){var tmpDescriptionAddresses=Object.keys(tmpManifest.Descriptors);for(var _i33=0;_i33<tmpDescriptionAddresses.length;_i33++){this.addDescriptor(tmpDescriptionAddresses[_i33],tmpManifest.Descriptors[tmpDescriptionAddresses[_i33]]);}}else{this.logError("(".concat(this.scope,") Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ").concat(_typeof(tmpManifest.Descriptors),"."),tmpManifest);}}else{this.logError("(".concat(this.scope,") Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object."),tmpManifest);}if('HashTranslations'in tmpManifest){if(_typeof(tmpManifest.HashTranslations)==='object'){for(var _i34=0;_i34<tmpManifest.HashTranslations.length;_i34++){// Each translation is 
}}}}// Serialize the Manifest to a string
},{key:"serialize",value:function serialize(){return JSON.stringify(this.getManifest());}},{key:"getManifest",value:function getManifest(){return{Scope:this.scope,Descriptors:JSON.parse(JSON.stringify(this.elementDescriptors)),HashTranslations:JSON.parse(JSON.stringify(this.hashTranslations.translationTable))};}// Add a descriptor to the manifest
},{key:"addDescriptor",value:function addDescriptor(pAddress,pDescriptor){if(_typeof(pDescriptor)==='object'){// Add the Address into the Descriptor if it doesn't exist:
if(!('Address'in pDescriptor)){pDescriptor.Address=pAddress;}if(!(pAddress in this.elementDescriptors)){this.elementAddresses.push(pAddress);}// Add the element descriptor to the schema
this.elementDescriptors[pAddress]=pDescriptor;// Always add the address as a hash
this.elementHashes[pAddress]=pAddress;if('Hash'in pDescriptor){// TODO: Check if this is a good idea or not..
//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.
this.elementHashes[pDescriptor.Hash]=pAddress;}else{pDescriptor.Hash=pAddress;}return true;}else{this.logError("(".concat(this.scope,") Error loading object descriptor for address '").concat(pAddress,"' from manifest object.  Expecting an object but property was type ").concat(_typeof(pDescriptor),"."));return false;}}},{key:"getDescriptorByHash",value:function getDescriptorByHash(pHash){return this.getDescriptor(this.resolveHashAddress(pHash));}},{key:"getDescriptor",value:function getDescriptor(pAddress){return this.elementDescriptors[pAddress];}// execute an action function for each descriptor
},{key:"eachDescriptor",value:function eachDescriptor(fAction){var tmpDescriptorAddresses=Object.keys(this.elementDescriptors);for(var i=0;i<tmpDescriptorAddresses.length;i++){fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);}}/*************************************************************************
	 * Beginning of Object Manipulation (read & write) Functions
	 */// Check if an element exists by its hash
},{key:"checkAddressExistsByHash",value:function checkAddressExistsByHash(pObject,pHash){return this.checkAddressExists(pObject,this.resolveHashAddress(pHash));}// Check if an element exists at an address
},{key:"checkAddressExists",value:function checkAddressExists(pObject,pAddress){return this.objectAddressCheckAddressExists.checkAddressExists(pObject,pAddress);}// Turn a hash into an address, factoring in the translation table.
},{key:"resolveHashAddress",value:function resolveHashAddress(pHash){var tmpAddress=undefined;var tmpInElementHashTable=pHash in this.elementHashes;var tmpInTranslationTable=pHash in this.hashTranslations.translationTable;// The most straightforward: the hash exists, no translations.
if(tmpInElementHashTable&&!tmpInTranslationTable){tmpAddress=this.elementHashes[pHash];}// There is a translation from one hash to another, and, the elementHashes contains the pointer end
else if(tmpInTranslationTable&&this.hashTranslations.translate(pHash)in this.elementHashes){tmpAddress=this.elementHashes[this.hashTranslations.translate(pHash)];}// Use the level of indirection only in the Translation Table
else if(tmpInTranslationTable){tmpAddress=this.hashTranslations.translate(pHash);}// Just treat the hash as an address.
// TODO: Discuss this ... it is magic but controversial
else{tmpAddress=pHash;}return tmpAddress;}// Get the value of an element by its hash
},{key:"getValueByHash",value:function getValueByHash(pObject,pHash){var tmpValue=this.getValueAtAddress(pObject,this.resolveHashAddress(pHash));if(typeof tmpValue=='undefined'){// Try to get a default if it exists
tmpValue=this.getDefaultValue(this.getDescriptorByHash(pHash));}return tmpValue;}// Get the value of an element at an address
},{key:"getValueAtAddress",value:function getValueAtAddress(pObject,pAddress){var tmpLintedAddress=pAddress.trim();if(tmpLintedAddress==''){this.logError("(".concat(this.scope,") Error getting value at address; address is an empty string."),pObject);return undefined;}var tmpValue=this.objectAddressGetValue.getValueAtAddress(pObject,pAddress);if(typeof tmpValue=='undefined'){// Try to get a default if it exists
tmpValue=this.getDefaultValue(this.getDescriptor(pAddress));}return tmpValue;}// Set the value of an element by its hash
},{key:"setValueByHash",value:function setValueByHash(pObject,pHash,pValue){return this.setValueAtAddress(pObject,this.resolveHashAddress(pHash),pValue);}// Set the value of an element at an address
},{key:"setValueAtAddress",value:function setValueAtAddress(pObject,pAddress,pValue){return this.objectAddressSetValue.setValueAtAddress(pObject,pAddress,pValue);}// Delete the value of an element by its hash
},{key:"deleteValueByHash",value:function deleteValueByHash(pObject,pHash,pValue){return this.deleteValueAtAddress(pObject,this.resolveHashAddress(pHash),pValue);}// Delete the value of an element at an address
},{key:"deleteValueAtAddress",value:function deleteValueAtAddress(pObject,pAddress,pValue){return this.objectAddressDeleteValue.deleteValueAtAddress(pObject,pAddress,pValue);}// Validate the consistency of an object against the schema
},{key:"validate",value:function validate(pObject){var tmpValidationData={Error:null,Errors:[],MissingElements:[]};if(_typeof(pObject)!=='object'){tmpValidationData.Error=true;tmpValidationData.Errors.push("Expected passed in object to be type object but was passed in ".concat(_typeof(pObject)));}var addValidationError=function addValidationError(pAddress,pErrorMessage){tmpValidationData.Error=true;tmpValidationData.Errors.push("Element at address \"".concat(pAddress,"\" ").concat(pErrorMessage,"."));};// Now enumerate through the values and check for anomalies based on the schema
for(var i=0;i<this.elementAddresses.length;i++){var tmpDescriptor=this.getDescriptor(this.elementAddresses[i]);var tmpValueExists=this.checkAddressExists(pObject,tmpDescriptor.Address);var tmpValue=this.getValueAtAddress(pObject,tmpDescriptor.Address);if(typeof tmpValue=='undefined'||!tmpValueExists){// This will technically mean that `Object.Some.Value = undefined` will end up showing as "missing"
// TODO: Do we want to do a different message based on if the property exists but is undefined?
tmpValidationData.MissingElements.push(tmpDescriptor.Address);if(tmpDescriptor.Required||this.options.strict){addValidationError(tmpDescriptor.Address,'is flagged REQUIRED but is not set in the object');}}// Now see if there is a data type specified for this element
if(tmpDescriptor.DataType){var tmpElementType=_typeof(tmpValue);switch(tmpDescriptor.DataType.toString().trim().toLowerCase()){case'string':if(tmpElementType!='string'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is of the type ").concat(tmpElementType));}break;case"precisenumber":if(tmpElementType!='string'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is of the type ").concat(tmpElementType));}else if(!this.numberRegex.test(tmpValue)){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is not a valid number"));}break;case'number':if(tmpElementType!='number'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is of the type ").concat(tmpElementType));}break;case'integer':if(tmpElementType!='number'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is of the type ").concat(tmpElementType));}else{var tmpValueString=tmpValue.toString();if(tmpValueString.indexOf('.')>-1){// TODO: Is this an error?
addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but has a decimal point in the number."));}}break;case'float':if(tmpElementType!='number'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is of the type ").concat(tmpElementType));}break;case'datetime':var tmpValueDate=new Date(tmpValue);if(tmpValueDate.toString()=='Invalid Date'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," but is not parsable as a Date by Javascript"));}default:// Check if this is a string, in the default case
// Note this is only when a DataType is specified and it is an unrecognized data type.
if(tmpElementType!='string'){addValidationError(tmpDescriptor.Address,"has a DataType ".concat(tmpDescriptor.DataType," (which auto-converted to String because it was unrecognized) but is of the type ").concat(tmpElementType));}break;}}}return tmpValidationData;}// Returns a default value, or, the default value for the data type (which is overridable with configuration)
},{key:"getDefaultValue",value:function getDefaultValue(pDescriptor){if(_typeof(pDescriptor)!='object'){return undefined;}if('Default'in pDescriptor){return pDescriptor.Default;}else{// Default to a null if it doesn't have a type specified.
// This will ensure a placeholder is created but isn't misinterpreted.
var tmpDataType='DataType'in pDescriptor?pDescriptor.DataType:'String';if(tmpDataType in this.options.defaultValues){return this.options.defaultValues[tmpDataType];}else{// give up and return null
return null;}}}// Enumerate through the schema and populate default values if they don't exist.
},{key:"populateDefaults",value:function populateDefaults(pObject,pOverwriteProperties){return this.populateObject(pObject,pOverwriteProperties,// This just sets up a simple filter to see if there is a default set.
function(pDescriptor){return'Default'in pDescriptor;});}// Forcefully populate all values even if they don't have defaults.
// Based on type, this can do unexpected things.
},{key:"populateObject",value:function populateObject(pObject,pOverwriteProperties,fFilter){var _this49=this;// Automatically create an object if one isn't passed in.
var tmpObject=_typeof(pObject)==='object'?pObject:{};// Default to *NOT OVERWRITING* properties
var tmpOverwriteProperties=typeof pOverwriteProperties=='undefined'?false:pOverwriteProperties;// This is a filter function, which is passed the schema and allows complex filtering of population
// The default filter function just returns true, populating everything.
var tmpFilterFunction=typeof fFilter=='function'?fFilter:function(pDescriptor){return true;};this.elementAddresses.forEach(function(pAddress){var tmpDescriptor=_this49.getDescriptor(pAddress);// Check the filter function to see if this is an address we want to set the value for.
if(tmpFilterFunction(tmpDescriptor)){// If we are overwriting properties OR the property does not exist
if(tmpOverwriteProperties||!_this49.checkAddressExists(tmpObject,pAddress)){_this49.setValueAtAddress(tmpObject,pAddress,_this49.getDefaultValue(tmpDescriptor));}}});return tmpObject;}}]);}(libFableServiceProviderBase);;module.exports=Manyfest;},{"./Manyfest-HashTranslation.js":114,"./Manyfest-LogToConsole.js":115,"./Manyfest-ObjectAddress-CheckAddressExists.js":116,"./Manyfest-ObjectAddress-DeleteValue.js":117,"./Manyfest-ObjectAddress-GetValue.js":118,"./Manyfest-ObjectAddress-SetValue.js":120,"./Manyfest-ObjectAddressGeneration.js":121,"./Manyfest-SchemaManipulation.js":123,"fable-serviceproviderbase":59}],125:[function(require,module,exports){'use strict';/** @type {import('./abs')} */module.exports=Math.abs;},{}],126:[function(require,module,exports){'use strict';/** @type {import('./floor')} */module.exports=Math.floor;},{}],127:[function(require,module,exports){'use strict';/** @type {import('./isNaN')} */module.exports=Number.isNaN||function isNaN(a){return a!==a;};},{}],128:[function(require,module,exports){'use strict';/** @type {import('./max')} */module.exports=Math.max;},{}],129:[function(require,module,exports){'use strict';/** @type {import('./min')} */module.exports=Math.min;},{}],130:[function(require,module,exports){'use strict';/** @type {import('./pow')} */module.exports=Math.pow;},{}],131:[function(require,module,exports){'use strict';/** @type {import('./round')} */module.exports=Math.round;},{}],132:[function(require,module,exports){'use strict';var $isNaN=require('./isNaN');/** @type {import('./sign')} */module.exports=function sign(number){if($isNaN(number)||number===0){return number;}return number<0?-1:+1;};},{"./isNaN":127}],133:[function(require,module,exports){(function(global){(function(){var hasMap=typeof Map==='function'&&Map.prototype;var mapSizeDescriptor=Object.getOwnPropertyDescriptor&&hasMap?Object.getOwnPropertyDescriptor(Map.prototype,'size'):null;var mapSize=hasMap&&mapSizeDescriptor&&typeof mapSizeDescriptor.get==='function'?mapSizeDescriptor.get:null;var mapForEach=hasMap&&Map.prototype.forEach;var hasSet=typeof Set==='function'&&Set.prototype;var setSizeDescriptor=Object.getOwnPropertyDescriptor&&hasSet?Object.getOwnPropertyDescriptor(Set.prototype,'size'):null;var setSize=hasSet&&setSizeDescriptor&&typeof setSizeDescriptor.get==='function'?setSizeDescriptor.get:null;var setForEach=hasSet&&Set.prototype.forEach;var hasWeakMap=typeof WeakMap==='function'&&WeakMap.prototype;var weakMapHas=hasWeakMap?WeakMap.prototype.has:null;var hasWeakSet=typeof WeakSet==='function'&&WeakSet.prototype;var weakSetHas=hasWeakSet?WeakSet.prototype.has:null;var hasWeakRef=typeof WeakRef==='function'&&WeakRef.prototype;var weakRefDeref=hasWeakRef?WeakRef.prototype.deref:null;var booleanValueOf=Boolean.prototype.valueOf;var objectToString=Object.prototype.toString;var functionToString=Function.prototype.toString;var $match=String.prototype.match;var $slice=String.prototype.slice;var $replace=String.prototype.replace;var $toUpperCase=String.prototype.toUpperCase;var $toLowerCase=String.prototype.toLowerCase;var $test=RegExp.prototype.test;var $concat=Array.prototype.concat;var $join=Array.prototype.join;var $arrSlice=Array.prototype.slice;var $floor=Math.floor;var bigIntValueOf=typeof BigInt==='function'?BigInt.prototype.valueOf:null;var gOPS=Object.getOwnPropertySymbols;var symToString=typeof Symbol==='function'&&_typeof(Symbol.iterator)==='symbol'?Symbol.prototype.toString:null;var hasShammedSymbols=typeof Symbol==='function'&&_typeof(Symbol.iterator)==='object';// ie, `has-tostringtag/shams
var toStringTag=typeof Symbol==='function'&&Symbol.toStringTag&&(_typeof(Symbol.toStringTag)===hasShammedSymbols?'object':'symbol')?Symbol.toStringTag:null;var isEnumerable=Object.prototype.propertyIsEnumerable;var gPO=(typeof Reflect==='function'?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype// eslint-disable-line no-proto
?function(O){return O.__proto__;// eslint-disable-line no-proto
}:null);function addNumericSeparator(num,str){if(num===Infinity||num===-Infinity||num!==num||num&&num>-1000&&num<1000||$test.call(/e/,str)){return str;}var sepRegex=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if(typeof num==='number'){var _int=num<0?-$floor(-num):$floor(num);// trunc(num)
if(_int!==num){var intStr=String(_int);var dec=$slice.call(str,intStr.length+1);return $replace.call(intStr,sepRegex,'$&_')+'.'+$replace.call($replace.call(dec,/([0-9]{3})/g,'$&_'),/_$/,'');}}return $replace.call(str,sepRegex,'$&_');}var utilInspect=require('./util.inspect');var inspectCustom=utilInspect.custom;var inspectSymbol=isSymbol(inspectCustom)?inspectCustom:null;var quotes={__proto__:null,'double':'"',single:"'"};var quoteREs={__proto__:null,'double':/(["\\])/g,single:/(['\\])/g};module.exports=function inspect_(obj,options,depth,seen){var opts=options||{};if(has(opts,'quoteStyle')&&!has(quotes,opts.quoteStyle)){throw new TypeError('option "quoteStyle" must be "single" or "double"');}if(has(opts,'maxStringLength')&&(typeof opts.maxStringLength==='number'?opts.maxStringLength<0&&opts.maxStringLength!==Infinity:opts.maxStringLength!==null)){throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');}var customInspect=has(opts,'customInspect')?opts.customInspect:true;if(typeof customInspect!=='boolean'&&customInspect!=='symbol'){throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');}if(has(opts,'indent')&&opts.indent!==null&&opts.indent!=='\t'&&!(parseInt(opts.indent,10)===opts.indent&&opts.indent>0)){throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');}if(has(opts,'numericSeparator')&&typeof opts.numericSeparator!=='boolean'){throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');}var numericSeparator=opts.numericSeparator;if(typeof obj==='undefined'){return'undefined';}if(obj===null){return'null';}if(typeof obj==='boolean'){return obj?'true':'false';}if(typeof obj==='string'){return inspectString(obj,opts);}if(typeof obj==='number'){if(obj===0){return Infinity/obj>0?'0':'-0';}var str=String(obj);return numericSeparator?addNumericSeparator(obj,str):str;}if(typeof obj==='bigint'){var bigIntStr=String(obj)+'n';return numericSeparator?addNumericSeparator(obj,bigIntStr):bigIntStr;}var maxDepth=typeof opts.depth==='undefined'?5:opts.depth;if(typeof depth==='undefined'){depth=0;}if(depth>=maxDepth&&maxDepth>0&&_typeof(obj)==='object'){return isArray(obj)?'[Array]':'[Object]';}var indent=getIndent(opts,depth);if(typeof seen==='undefined'){seen=[];}else if(indexOf(seen,obj)>=0){return'[Circular]';}function inspect(value,from,noIndent){if(from){seen=$arrSlice.call(seen);seen.push(from);}if(noIndent){var newOpts={depth:opts.depth};if(has(opts,'quoteStyle')){newOpts.quoteStyle=opts.quoteStyle;}return inspect_(value,newOpts,depth+1,seen);}return inspect_(value,opts,depth+1,seen);}if(typeof obj==='function'&&!isRegExp(obj)){// in older engines, regexes are callable
var name=nameOf(obj);var keys=arrObjKeys(obj,inspect);return'[Function'+(name?': '+name:' (anonymous)')+']'+(keys.length>0?' { '+$join.call(keys,', ')+' }':'');}if(isSymbol(obj)){var symString=hasShammedSymbols?$replace.call(String(obj),/^(Symbol\(.*\))_[^)]*$/,'$1'):symToString.call(obj);return _typeof(obj)==='object'&&!hasShammedSymbols?markBoxed(symString):symString;}if(isElement(obj)){var s='<'+$toLowerCase.call(String(obj.nodeName));var attrs=obj.attributes||[];for(var i=0;i<attrs.length;i++){s+=' '+attrs[i].name+'='+wrapQuotes(quote(attrs[i].value),'double',opts);}s+='>';if(obj.childNodes&&obj.childNodes.length){s+='...';}s+='</'+$toLowerCase.call(String(obj.nodeName))+'>';return s;}if(isArray(obj)){if(obj.length===0){return'[]';}var xs=arrObjKeys(obj,inspect);if(indent&&!singleLineValues(xs)){return'['+indentedJoin(xs,indent)+']';}return'[ '+$join.call(xs,', ')+' ]';}if(isError(obj)){var parts=arrObjKeys(obj,inspect);if(!('cause'in Error.prototype)&&'cause'in obj&&!isEnumerable.call(obj,'cause')){return'{ ['+String(obj)+'] '+$join.call($concat.call('[cause]: '+inspect(obj.cause),parts),', ')+' }';}if(parts.length===0){return'['+String(obj)+']';}return'{ ['+String(obj)+'] '+$join.call(parts,', ')+' }';}if(_typeof(obj)==='object'&&customInspect){if(inspectSymbol&&typeof obj[inspectSymbol]==='function'&&utilInspect){return utilInspect(obj,{depth:maxDepth-depth});}else if(customInspect!=='symbol'&&typeof obj.inspect==='function'){return obj.inspect();}}if(isMap(obj)){var mapParts=[];if(mapForEach){mapForEach.call(obj,function(value,key){mapParts.push(inspect(key,obj,true)+' => '+inspect(value,obj));});}return collectionOf('Map',mapSize.call(obj),mapParts,indent);}if(isSet(obj)){var setParts=[];if(setForEach){setForEach.call(obj,function(value){setParts.push(inspect(value,obj));});}return collectionOf('Set',setSize.call(obj),setParts,indent);}if(isWeakMap(obj)){return weakCollectionOf('WeakMap');}if(isWeakSet(obj)){return weakCollectionOf('WeakSet');}if(isWeakRef(obj)){return weakCollectionOf('WeakRef');}if(isNumber(obj)){return markBoxed(inspect(Number(obj)));}if(isBigInt(obj)){return markBoxed(inspect(bigIntValueOf.call(obj)));}if(isBoolean(obj)){return markBoxed(booleanValueOf.call(obj));}if(isString(obj)){return markBoxed(inspect(String(obj)));}// note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
/* eslint-env browser */if(typeof window!=='undefined'&&obj===window){return'{ [object Window] }';}if(typeof globalThis!=='undefined'&&obj===globalThis||typeof global!=='undefined'&&obj===global){return'{ [object globalThis] }';}if(!isDate(obj)&&!isRegExp(obj)){var ys=arrObjKeys(obj,inspect);var isPlainObject=gPO?gPO(obj)===Object.prototype:obj instanceof Object||obj.constructor===Object;var protoTag=obj instanceof Object?'':'null prototype';var stringTag=!isPlainObject&&toStringTag&&Object(obj)===obj&&toStringTag in obj?$slice.call(toStr(obj),8,-1):protoTag?'Object':'';var constructorTag=isPlainObject||typeof obj.constructor!=='function'?'':obj.constructor.name?obj.constructor.name+' ':'';var tag=constructorTag+(stringTag||protoTag?'['+$join.call($concat.call([],stringTag||[],protoTag||[]),': ')+'] ':'');if(ys.length===0){return tag+'{}';}if(indent){return tag+'{'+indentedJoin(ys,indent)+'}';}return tag+'{ '+$join.call(ys,', ')+' }';}return String(obj);};function wrapQuotes(s,defaultStyle,opts){var style=opts.quoteStyle||defaultStyle;var quoteChar=quotes[style];return quoteChar+s+quoteChar;}function quote(s){return $replace.call(String(s),/"/g,'&quot;');}function isArray(obj){return toStr(obj)==='[object Array]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isDate(obj){return toStr(obj)==='[object Date]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isRegExp(obj){return toStr(obj)==='[object RegExp]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isError(obj){return toStr(obj)==='[object Error]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isString(obj){return toStr(obj)==='[object String]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isNumber(obj){return toStr(obj)==='[object Number]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}function isBoolean(obj){return toStr(obj)==='[object Boolean]'&&(!toStringTag||!(_typeof(obj)==='object'&&toStringTag in obj));}// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj){if(hasShammedSymbols){return obj&&_typeof(obj)==='object'&&obj instanceof Symbol;}if(_typeof(obj)==='symbol'){return true;}if(!obj||_typeof(obj)!=='object'||!symToString){return false;}try{symToString.call(obj);return true;}catch(e){}return false;}function isBigInt(obj){if(!obj||_typeof(obj)!=='object'||!bigIntValueOf){return false;}try{bigIntValueOf.call(obj);return true;}catch(e){}return false;}var hasOwn=Object.prototype.hasOwnProperty||function(key){return key in this;};function has(obj,key){return hasOwn.call(obj,key);}function toStr(obj){return objectToString.call(obj);}function nameOf(f){if(f.name){return f.name;}var m=$match.call(functionToString.call(f),/^function\s*([\w$]+)/);if(m){return m[1];}return null;}function indexOf(xs,x){if(xs.indexOf){return xs.indexOf(x);}for(var i=0,l=xs.length;i<l;i++){if(xs[i]===x){return i;}}return-1;}function isMap(x){if(!mapSize||!x||_typeof(x)!=='object'){return false;}try{mapSize.call(x);try{setSize.call(x);}catch(s){return true;}return x instanceof Map;// core-js workaround, pre-v2.5.0
}catch(e){}return false;}function isWeakMap(x){if(!weakMapHas||!x||_typeof(x)!=='object'){return false;}try{weakMapHas.call(x,weakMapHas);try{weakSetHas.call(x,weakSetHas);}catch(s){return true;}return x instanceof WeakMap;// core-js workaround, pre-v2.5.0
}catch(e){}return false;}function isWeakRef(x){if(!weakRefDeref||!x||_typeof(x)!=='object'){return false;}try{weakRefDeref.call(x);return true;}catch(e){}return false;}function isSet(x){if(!setSize||!x||_typeof(x)!=='object'){return false;}try{setSize.call(x);try{mapSize.call(x);}catch(m){return true;}return x instanceof Set;// core-js workaround, pre-v2.5.0
}catch(e){}return false;}function isWeakSet(x){if(!weakSetHas||!x||_typeof(x)!=='object'){return false;}try{weakSetHas.call(x,weakSetHas);try{weakMapHas.call(x,weakMapHas);}catch(s){return true;}return x instanceof WeakSet;// core-js workaround, pre-v2.5.0
}catch(e){}return false;}function isElement(x){if(!x||_typeof(x)!=='object'){return false;}if(typeof HTMLElement!=='undefined'&&x instanceof HTMLElement){return true;}return typeof x.nodeName==='string'&&typeof x.getAttribute==='function';}function inspectString(str,opts){if(str.length>opts.maxStringLength){var remaining=str.length-opts.maxStringLength;var trailer='... '+remaining+' more character'+(remaining>1?'s':'');return inspectString($slice.call(str,0,opts.maxStringLength),opts)+trailer;}var quoteRE=quoteREs[opts.quoteStyle||'single'];quoteRE.lastIndex=0;// eslint-disable-next-line no-control-regex
var s=$replace.call($replace.call(str,quoteRE,'\\$1'),/[\x00-\x1f]/g,lowbyte);return wrapQuotes(s,'single',opts);}function lowbyte(c){var n=c.charCodeAt(0);var x={8:'b',9:'t',10:'n',12:'f',13:'r'}[n];if(x){return'\\'+x;}return'\\x'+(n<0x10?'0':'')+$toUpperCase.call(n.toString(16));}function markBoxed(str){return'Object('+str+')';}function weakCollectionOf(type){return type+' { ? }';}function collectionOf(type,size,entries,indent){var joinedEntries=indent?indentedJoin(entries,indent):$join.call(entries,', ');return type+' ('+size+') {'+joinedEntries+'}';}function singleLineValues(xs){for(var i=0;i<xs.length;i++){if(indexOf(xs[i],'\n')>=0){return false;}}return true;}function getIndent(opts,depth){var baseIndent;if(opts.indent==='\t'){baseIndent='\t';}else if(typeof opts.indent==='number'&&opts.indent>0){baseIndent=$join.call(Array(opts.indent+1),' ');}else{return null;}return{base:baseIndent,prev:$join.call(Array(depth+1),baseIndent)};}function indentedJoin(xs,indent){if(xs.length===0){return'';}var lineJoiner='\n'+indent.prev+indent.base;return lineJoiner+$join.call(xs,','+lineJoiner)+'\n'+indent.prev;}function arrObjKeys(obj,inspect){var isArr=isArray(obj);var xs=[];if(isArr){xs.length=obj.length;for(var i=0;i<obj.length;i++){xs[i]=has(obj,i)?inspect(obj[i],obj):'';}}var syms=typeof gOPS==='function'?gOPS(obj):[];var symMap;if(hasShammedSymbols){symMap={};for(var k=0;k<syms.length;k++){symMap['$'+syms[k]]=syms[k];}}for(var key in obj){// eslint-disable-line no-restricted-syntax
if(!has(obj,key)){continue;}// eslint-disable-line no-restricted-syntax, no-continue
if(isArr&&String(Number(key))===key&&key<obj.length){continue;}// eslint-disable-line no-restricted-syntax, no-continue
if(hasShammedSymbols&&symMap['$'+key]instanceof Symbol){// this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
continue;// eslint-disable-line no-restricted-syntax, no-continue
}else if($test.call(/[^\w$]/,key)){xs.push(inspect(key,obj)+': '+inspect(obj[key],obj));}else{xs.push(key+': '+inspect(obj[key],obj));}}if(typeof gOPS==='function'){for(var j=0;j<syms.length;j++){if(isEnumerable.call(obj,syms[j])){xs.push('['+inspect(syms[j])+']: '+inspect(obj[syms[j]],obj));}}}return xs;}}).call(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"./util.inspect":18}],134:[function(require,module,exports){var wrappy=require('wrappy');module.exports=wrappy(once);module.exports.strict=wrappy(onceStrict);once.proto=once(function(){Object.defineProperty(Function.prototype,'once',{value:function value(){return once(this);},configurable:true});Object.defineProperty(Function.prototype,'onceStrict',{value:function value(){return onceStrict(this);},configurable:true});});function once(fn){var _f=function f(){if(_f.called)return _f.value;_f.called=true;return _f.value=fn.apply(this,arguments);};_f.called=false;return _f;}function onceStrict(fn){var _f2=function f(){if(_f2.called)throw new Error(_f2.onceError);_f2.called=true;return _f2.value=fn.apply(this,arguments);};var name=fn.name||'Function wrapped with `once`';_f2.onceError=name+" shouldn't be called more than once";_f2.called=false;return _f2;}},{"wrappy":187}],135:[function(require,module,exports){(function(process){(function(){// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';function assertPath(path){if(typeof path!=='string'){throw new TypeError('Path must be a string. Received '+JSON.stringify(path));}}// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path,allowAboveRoot){var res='';var lastSegmentLength=0;var lastSlash=-1;var dots=0;var code;for(var i=0;i<=path.length;++i){if(i<path.length)code=path.charCodeAt(i);else if(code===47/*/*/)break;else code=47/*/*/;if(code===47/*/*/){if(lastSlash===i-1||dots===1){// NOOP
}else if(lastSlash!==i-1&&dots===2){if(res.length<2||lastSegmentLength!==2||res.charCodeAt(res.length-1)!==46/*.*/||res.charCodeAt(res.length-2)!==46/*.*/){if(res.length>2){var lastSlashIndex=res.lastIndexOf('/');if(lastSlashIndex!==res.length-1){if(lastSlashIndex===-1){res='';lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf('/');}lastSlash=i;dots=0;continue;}}else if(res.length===2||res.length===1){res='';lastSegmentLength=0;lastSlash=i;dots=0;continue;}}if(allowAboveRoot){if(res.length>0)res+='/..';else res='..';lastSegmentLength=2;}}else{if(res.length>0)res+='/'+path.slice(lastSlash+1,i);else res=path.slice(lastSlash+1,i);lastSegmentLength=i-lastSlash-1;}lastSlash=i;dots=0;}else if(code===46/*.*/&&dots!==-1){++dots;}else{dots=-1;}}return res;}function _format(sep,pathObject){var dir=pathObject.dir||pathObject.root;var base=pathObject.base||(pathObject.name||'')+(pathObject.ext||'');if(!dir){return base;}if(dir===pathObject.root){return dir+base;}return dir+sep+base;}var posix={// path.resolve([from ...], to)
resolve:function resolve(){var resolvedPath='';var resolvedAbsolute=false;var cwd;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path;if(i>=0)path=arguments[i];else{if(cwd===undefined)cwd=process.cwd();path=cwd;}assertPath(path);// Skip empty entries
if(path.length===0){continue;}resolvedPath=path+'/'+resolvedPath;resolvedAbsolute=path.charCodeAt(0)===47/*/*/;}// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
// Normalize the path
resolvedPath=normalizeStringPosix(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute){if(resolvedPath.length>0)return'/'+resolvedPath;else return'/';}else if(resolvedPath.length>0){return resolvedPath;}else{return'.';}},normalize:function normalize(path){assertPath(path);if(path.length===0)return'.';var isAbsolute=path.charCodeAt(0)===47/*/*/;var trailingSeparator=path.charCodeAt(path.length-1)===47/*/*/;// Normalize the path
path=normalizeStringPosix(path,!isAbsolute);if(path.length===0&&!isAbsolute)path='.';if(path.length>0&&trailingSeparator)path+='/';if(isAbsolute)return'/'+path;return path;},isAbsolute:function isAbsolute(path){assertPath(path);return path.length>0&&path.charCodeAt(0)===47/*/*/;},join:function join(){if(arguments.length===0)return'.';var joined;for(var i=0;i<arguments.length;++i){var arg=arguments[i];assertPath(arg);if(arg.length>0){if(joined===undefined)joined=arg;else joined+='/'+arg;}}if(joined===undefined)return'.';return posix.normalize(joined);},relative:function relative(from,to){assertPath(from);assertPath(to);if(from===to)return'';from=posix.resolve(from);to=posix.resolve(to);if(from===to)return'';// Trim any leading backslashes
var fromStart=1;for(;fromStart<from.length;++fromStart){if(from.charCodeAt(fromStart)!==47/*/*/)break;}var fromEnd=from.length;var fromLen=fromEnd-fromStart;// Trim any leading backslashes
var toStart=1;for(;toStart<to.length;++toStart){if(to.charCodeAt(toStart)!==47/*/*/)break;}var toEnd=to.length;var toLen=toEnd-toStart;// Compare paths to find the longest common path from root
var length=fromLen<toLen?fromLen:toLen;var lastCommonSep=-1;var i=0;for(;i<=length;++i){if(i===length){if(toLen>length){if(to.charCodeAt(toStart+i)===47/*/*/){// We get here if `from` is the exact base path for `to`.
// For example: from='/foo/bar'; to='/foo/bar/baz'
return to.slice(toStart+i+1);}else if(i===0){// We get here if `from` is the root
// For example: from='/'; to='/foo'
return to.slice(toStart+i);}}else if(fromLen>length){if(from.charCodeAt(fromStart+i)===47/*/*/){// We get here if `to` is the exact base path for `from`.
// For example: from='/foo/bar/baz'; to='/foo/bar'
lastCommonSep=i;}else if(i===0){// We get here if `to` is the root.
// For example: from='/foo'; to='/'
lastCommonSep=0;}}break;}var fromCode=from.charCodeAt(fromStart+i);var toCode=to.charCodeAt(toStart+i);if(fromCode!==toCode)break;else if(fromCode===47/*/*/)lastCommonSep=i;}var out='';// Generate the relative path based on the path difference between `to`
// and `from`
for(i=fromStart+lastCommonSep+1;i<=fromEnd;++i){if(i===fromEnd||from.charCodeAt(i)===47/*/*/){if(out.length===0)out+='..';else out+='/..';}}// Lastly, append the rest of the destination (`to`) path that comes after
// the common path parts
if(out.length>0)return out+to.slice(toStart+lastCommonSep);else{toStart+=lastCommonSep;if(to.charCodeAt(toStart)===47/*/*/)++toStart;return to.slice(toStart);}},_makeLong:function _makeLong(path){return path;},dirname:function dirname(path){assertPath(path);if(path.length===0)return'.';var code=path.charCodeAt(0);var hasRoot=code===47/*/*/;var end=-1;var matchedSlash=true;for(var i=path.length-1;i>=1;--i){code=path.charCodeAt(i);if(code===47/*/*/){if(!matchedSlash){end=i;break;}}else{// We saw the first non-path separator
matchedSlash=false;}}if(end===-1)return hasRoot?'/':'.';if(hasRoot&&end===1)return'//';return path.slice(0,end);},basename:function basename(path,ext){if(ext!==undefined&&typeof ext!=='string')throw new TypeError('"ext" argument must be a string');assertPath(path);var start=0;var end=-1;var matchedSlash=true;var i;if(ext!==undefined&&ext.length>0&&ext.length<=path.length){if(ext.length===path.length&&ext===path)return'';var extIdx=ext.length-1;var firstNonSlashEnd=-1;for(i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){start=i+1;break;}}else{if(firstNonSlashEnd===-1){// We saw the first non-path separator, remember this index in case
// we need it if the extension ends up not matching
matchedSlash=false;firstNonSlashEnd=i+1;}if(extIdx>=0){// Try to match the explicit extension
if(code===ext.charCodeAt(extIdx)){if(--extIdx===-1){// We matched the extension, so mark this as the end of our path
// component
end=i;}}else{// Extension does not match, so our result is the entire path
// component
extIdx=-1;end=firstNonSlashEnd;}}}}if(start===end)end=firstNonSlashEnd;else if(end===-1)end=path.length;return path.slice(start,end);}else{for(i=path.length-1;i>=0;--i){if(path.charCodeAt(i)===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){start=i+1;break;}}else if(end===-1){// We saw the first non-path separator, mark this as the end of our
// path component
matchedSlash=false;end=i+1;}}if(end===-1)return'';return path.slice(start,end);}},extname:function extname(path){assertPath(path);var startDot=-1;var startPart=0;var end=-1;var matchedSlash=true;// Track the state of characters (if any) we see before our first dot and
// after any path separator we find
var preDotState=0;for(var i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){startPart=i+1;break;}continue;}if(end===-1){// We saw the first non-path separator, mark this as the end of our
// extension
matchedSlash=false;end=i+1;}if(code===46/*.*/){// If this is our first dot, mark it as the start of our extension
if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1;}else if(startDot!==-1){// We saw a non-dot and non-path separator before our dot, so we should
// have a good chance at having a non-empty extension
preDotState=-1;}}if(startDot===-1||end===-1||// We saw a non-dot character immediately before the dot
preDotState===0||// The (right-most) trimmed path component is exactly '..'
preDotState===1&&startDot===end-1&&startDot===startPart+1){return'';}return path.slice(startDot,end);},format:function format(pathObject){if(pathObject===null||_typeof(pathObject)!=='object'){throw new TypeError('The "pathObject" argument must be of type Object. Received type '+_typeof(pathObject));}return _format('/',pathObject);},parse:function parse(path){assertPath(path);var ret={root:'',dir:'',base:'',ext:'',name:''};if(path.length===0)return ret;var code=path.charCodeAt(0);var isAbsolute=code===47/*/*/;var start;if(isAbsolute){ret.root='/';start=1;}else{start=0;}var startDot=-1;var startPart=0;var end=-1;var matchedSlash=true;var i=path.length-1;// Track the state of characters (if any) we see before our first dot and
// after any path separator we find
var preDotState=0;// Get non-dir info
for(;i>=start;--i){code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){startPart=i+1;break;}continue;}if(end===-1){// We saw the first non-path separator, mark this as the end of our
// extension
matchedSlash=false;end=i+1;}if(code===46/*.*/){// If this is our first dot, mark it as the start of our extension
if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1;}else if(startDot!==-1){// We saw a non-dot and non-path separator before our dot, so we should
// have a good chance at having a non-empty extension
preDotState=-1;}}if(startDot===-1||end===-1||// We saw a non-dot character immediately before the dot
preDotState===0||// The (right-most) trimmed path component is exactly '..'
preDotState===1&&startDot===end-1&&startDot===startPart+1){if(end!==-1){if(startPart===0&&isAbsolute)ret.base=ret.name=path.slice(1,end);else ret.base=ret.name=path.slice(startPart,end);}}else{if(startPart===0&&isAbsolute){ret.name=path.slice(1,startDot);ret.base=path.slice(1,end);}else{ret.name=path.slice(startPart,startDot);ret.base=path.slice(startPart,end);}ret.ext=path.slice(startDot,end);}if(startPart>0)ret.dir=path.slice(0,startPart-1);else if(isAbsolute)ret.dir='/';return ret;},sep:'/',delimiter:':',win32:null,posix:null};posix.posix=posix;module.exports=posix;}).call(this);}).call(this,require('_process'));},{"_process":147}],136:[function(require,module,exports){module.exports={"name":"pict-application","version":"1.0.24","description":"Application base class for a pict view-based application","main":"source/Pict-Application.js","scripts":{"test":"npx mocha -u tdd -R spec","start":"node source/Pict-Application.js","coverage":"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec","build":"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local","docker-dev-run":"docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/pict-application\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" pict-application-image:local","docker-dev-shell":"docker exec -it pict-application-dev /bin/bash","tests":"npx mocha -u tdd --exit -R spec --grep","lint":"eslint source/**","types":"tsc -p ."},"types":"types/source/Pict-Application.d.ts","repository":{"type":"git","url":"git+https://github.com/stevenvelozo/pict-application.git"},"author":"steven velozo <steven@velozo.com>","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/pict-application/issues"},"homepage":"https://github.com/stevenvelozo/pict-application#readme","devDependencies":{"@eslint/js":"^9.17.0","browser-env":"^3.3.0","eslint":"^9.17.0","pict":"^1.0.226","pict-view":"^1.0.55","quackage":"^1.0.36"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"dependencies":{"fable-serviceproviderbase":"^3.0.15"}};},{}],137:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var libPackage=require('../package.json');var defaultPictSettings={Name:'DefaultPictApplication',// The main "viewport" is the view that is used to host our application
MainViewportViewIdentifier:'Default-View',MainViewportRenderableHash:false,MainViewportDestinationAddress:false,MainViewportDefaultDataAddress:false,// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application
AutoSolveAfterInitialize:true,AutoRenderMainViewportViewAfterInitialize:true,AutoRenderViewsAfterInitialize:false,ConfigurationOnlyViews:[],Manifests:{},// The prefix to prepend on all template destination hashes
IdentifierAddressPrefix:'PICT-'};/**
 * Base class for pict applications.
 */var PictApplication=/*#__PURE__*/function(_libFableServiceBase14){/**
	 * @param {import('fable')} pFable
	 * @param {any} [pOptions]
	 * @param {string} [pServiceHash]
	 */function PictApplication(pFable,pOptions,pServiceHash){var _this50;_classCallCheck2(this,PictApplication);var tmpOptions=Object.assign({},JSON.parse(JSON.stringify(defaultPictSettings)),pOptions);_this50=_callSuper(this,PictApplication,[pFable,tmpOptions,pServiceHash]);/** @type {any} */_this50.options;/** @type {any} */_this50.log;/** @type {import('pict') & import('fable')} */_this50.fable;/** @type {string} */_this50.UUID;/** @type {string} */_this50.Hash;/**
		 * @type {{ [key: string]: any }}
		 */_this50.servicesMap;_this50.serviceType='PictApplication';/** @type {Object} */_this50._Package=libPackage;// Convenience and consistency naming
_this50.pict=_this50.fable;// Wire in the essential Pict state
_this50.AppData=_this50.fable.AppData;/** @type {number} */_this50.initializeTimestamp;/** @type {number} */_this50.lastSolvedTimestamp;/** @type {number} */_this50.lastMarshalFromViewsTimestamp;/** @type {number} */_this50.lastMarshalToViewsTimestamp;/** @type {number} */_this50.lastAutoRenderTimestamp;// Load all the manifests for the application
var tmpManifestKeys=Object.keys(_this50.options.Manifests);if(tmpManifestKeys.length>0){for(var i=0;i<tmpManifestKeys.length;i++){// Load each manifest
var tmpManifestKey=tmpManifestKeys[i];_this50.fable.instantiateServiceProvider('Manifest',_this50.options.Manifests[tmpManifestKey],tmpManifestKey);}}return _this50;}/* -------------------------------------------------------------------------- *//*                     Code Section: Solve All Views                          *//* -------------------------------------------------------------------------- *//**
	 * @return {boolean}
	 */_inherits(PictApplication,_libFableServiceBase14);return _createClass2(PictApplication,[{key:"onPreSolve",value:function onPreSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onPreSolve:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onPreSolveAsync",value:function onPreSolveAsync(fCallback){this.onPreSolve();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"onBeforeSolve",value:function onBeforeSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onBeforeSolve:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onBeforeSolveAsync",value:function onBeforeSolveAsync(fCallback){this.onBeforeSolve();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"onSolve",value:function onSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onSolve:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onSolveAsync",value:function onSolveAsync(fCallback){this.onSolve();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"solve",value:function solve(){if(this.pict.LogNoisiness>2){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," executing solve() function..."));}// Walk through any loaded providers and solve them as well.
var tmpLoadedProviders=Object.keys(this.pict.providers);var tmpProvidersToSolve=[];for(var i=0;i<tmpLoadedProviders.length;i++){var tmpProvider=this.pict.providers[tmpLoadedProviders[i]];if(tmpProvider.options.AutoSolveWithApp){tmpProvidersToSolve.push(tmpProvider);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpProvidersToSolve.sort(function(a,b){return a.options.AutoSolveOrdinal-b.options.AutoSolveOrdinal;});for(var _i35=0;_i35<tmpProvidersToSolve.length;_i35++){tmpProvidersToSolve[_i35].solve(tmpProvidersToSolve[_i35]);}this.onBeforeSolve();// Now walk through any loaded views and initialize them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToSolve=[];for(var _i36=0;_i36<tmpLoadedViews.length;_i36++){var tmpView=this.pict.views[tmpLoadedViews[_i36]];if(tmpView.options.AutoInitialize){tmpViewsToSolve.push(tmpView);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpViewsToSolve.sort(function(a,b){return a.options.AutoInitializeOrdinal-b.options.AutoInitializeOrdinal;});for(var _i37=0;_i37<tmpViewsToSolve.length;_i37++){tmpViewsToSolve[_i37].solve();}this.onSolve();this.onAfterSolve();this.lastSolvedTimestamp=this.fable.log.getTimeStamp();return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"solveAsync",value:function solveAsync(fCallback){var _this51=this;var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');tmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this51.log.error("PictApp [".concat(_this51.UUID,"]::[").concat(_this51.Hash,"] ").concat(_this51.options.Name," solveAsync Auto Callback Error: ").concat(pError),pError);}};}// Walk through any loaded providers and solve them as well.
var tmpLoadedProviders=Object.keys(this.pict.providers);var tmpProvidersToSolve=[];for(var i=0;i<tmpLoadedProviders.length;i++){var tmpProvider=this.pict.providers[tmpLoadedProviders[i]];if(tmpProvider.options.AutoSolveWithApp){tmpProvidersToSolve.push(tmpProvider);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpProvidersToSolve.sort(function(a,b){return a.options.AutoSolveOrdinal-b.options.AutoSolveOrdinal;});for(var _i38=0;_i38<tmpProvidersToSolve.length;_i38++){tmpAnticipate.anticipate(tmpProvidersToSolve[_i38].solveAsync.bind(tmpProvidersToSolve[_i38]));}// Walk through any loaded views and solve them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToSolve=[];for(var _i39=0;_i39<tmpLoadedViews.length;_i39++){var tmpView=this.pict.views[tmpLoadedViews[_i39]];if(tmpView.options.AutoSolveWithApp){tmpViewsToSolve.push(tmpView);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpViewsToSolve.sort(function(a,b){return a.options.AutoSolveOrdinal-b.options.AutoSolveOrdinal;});for(var _i40=0;_i40<tmpViewsToSolve.length;_i40++){tmpAnticipate.anticipate(tmpViewsToSolve[_i40].solveAsync.bind(tmpViewsToSolve[_i40]));}tmpAnticipate.anticipate(this.onSolveAsync.bind(this));tmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this51.pict.LogNoisiness>2){_this51.log.trace("PictApp [".concat(_this51.UUID,"]::[").concat(_this51.Hash,"] ").concat(_this51.options.Name," solveAsync() complete."));}_this51.lastSolvedTimestamp=_this51.fable.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * @return {boolean}
	 */},{key:"onAfterSolve",value:function onAfterSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onAfterSolve:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onAfterSolveAsync",value:function onAfterSolveAsync(fCallback){this.onAfterSolve();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Initialize Application                   *//* -------------------------------------------------------------------------- *//**
	 * @return {boolean}
	 */},{key:"onBeforeInitialize",value:function onBeforeInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onBeforeInitialize:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onBeforeInitializeAsync",value:function onBeforeInitializeAsync(fCallback){this.onBeforeInitialize();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"onInitialize",value:function onInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onInitialize:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onInitializeAsync",value:function onInitializeAsync(fCallback){this.onInitialize();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"initialize",value:function initialize(){if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," initialize:"));}if(!this.initializeTimestamp){this.onBeforeInitialize();if('ConfigurationOnlyViews'in this.options){// Load all the configuration only views
for(var i=0;i<this.options.ConfigurationOnlyViews.length;i++){var tmpViewIdentifier=typeof this.options.ConfigurationOnlyViews[i].ViewIdentifier==='undefined'?"AutoView-".concat(this.fable.getUUID()):this.options.ConfigurationOnlyViews[i].ViewIdentifier;this.log.info("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," adding configuration only view: ").concat(tmpViewIdentifier));this.pict.addView(tmpViewIdentifier,this.options.ConfigurationOnlyViews[i]);}}this.onInitialize();// Walk through any loaded providers and initialize them as well.
var tmpLoadedProviders=Object.keys(this.pict.providers);var tmpProvidersToInitialize=[];for(var _i41=0;_i41<tmpLoadedProviders.length;_i41++){var tmpProvider=this.pict.providers[tmpLoadedProviders[_i41]];if(tmpProvider.options.AutoInitialize){tmpProvidersToInitialize.push(tmpProvider);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpProvidersToInitialize.sort(function(a,b){return a.options.AutoInitializeOrdinal-b.options.AutoInitializeOrdinal;});for(var _i42=0;_i42<tmpProvidersToInitialize.length;_i42++){tmpProvidersToInitialize[_i42].initialize();}// Now walk through any loaded views and initialize them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToInitialize=[];for(var _i43=0;_i43<tmpLoadedViews.length;_i43++){var tmpView=this.pict.views[tmpLoadedViews[_i43]];if(tmpView.options.AutoInitialize){tmpViewsToInitialize.push(tmpView);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpViewsToInitialize.sort(function(a,b){return a.options.AutoInitializeOrdinal-b.options.AutoInitializeOrdinal;});for(var _i44=0;_i44<tmpViewsToInitialize.length;_i44++){tmpViewsToInitialize[_i44].initialize();}this.onAfterInitialize();if(this.options.AutoSolveAfterInitialize){if(this.pict.LogNoisiness>1){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," auto solving after initialization..."));}// Solve the template synchronously
this.solve();}// Now check and see if we should automatically render as well
if(this.options.AutoRenderMainViewportViewAfterInitialize){if(this.pict.LogNoisiness>1){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," auto rendering after initialization..."));}// Render the template synchronously
this.render();}this.initializeTimestamp=this.fable.log.getTimeStamp();return true;}else{this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," initialize called but initialization is already completed.  Aborting."));return false;}}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"initializeAsync",value:function initializeAsync(fCallback){var _this52=this;if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," initializeAsync:"));}// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this52.log.error("PictApp [".concat(_this52.UUID,"]::[").concat(_this52.Hash,"] ").concat(_this52.options.Name," initializeAsync Auto Callback Error: ").concat(pError),pError);}};}if(!this.initializeTimestamp){var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," beginning initialization..."));}if('ConfigurationOnlyViews'in this.options){// Load all the configuration only views
for(var i=0;i<this.options.ConfigurationOnlyViews.length;i++){var tmpViewIdentifier=typeof this.options.ConfigurationOnlyViews[i].ViewIdentifier==='undefined'?"AutoView-".concat(this.fable.getUUID()):this.options.ConfigurationOnlyViews[i].ViewIdentifier;this.log.info("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," adding configuration only view: ").concat(tmpViewIdentifier));this.pict.addView(tmpViewIdentifier,this.options.ConfigurationOnlyViews[i]);}}tmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));tmpAnticipate.anticipate(this.onInitializeAsync.bind(this));// Walk through any loaded providers and solve them as well.
var tmpLoadedProviders=Object.keys(this.pict.providers);var tmpProvidersToInitialize=[];for(var _i45=0;_i45<tmpLoadedProviders.length;_i45++){var tmpProvider=this.pict.providers[tmpLoadedProviders[_i45]];if(tmpProvider.options.AutoInitialize){tmpProvidersToInitialize.push(tmpProvider);}}// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)
tmpProvidersToInitialize.sort(function(a,b){return a.options.AutoInitializeOrdinal-b.options.AutoInitializeOrdinal;});for(var _i46=0;_i46<tmpProvidersToInitialize.length;_i46++){tmpAnticipate.anticipate(tmpProvidersToInitialize[_i46].initializeAsync.bind(tmpProvidersToInitialize[_i46]));}// Now walk through any loaded views and initialize them as well.
// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToInitialize=[];for(var _i47=0;_i47<tmpLoadedViews.length;_i47++){var tmpView=this.pict.views[tmpLoadedViews[_i47]];if(tmpView.options.AutoInitialize){tmpViewsToInitialize.push(tmpView);}}// Sort the views by their priority
// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff
tmpViewsToInitialize.sort(function(a,b){return a.options.AutoInitializeOrdinal-b.options.AutoInitializeOrdinal;});for(var _i48=0;_i48<tmpViewsToInitialize.length;_i48++){var _tmpView=tmpViewsToInitialize[_i48];tmpAnticipate.anticipate(_tmpView.initializeAsync.bind(_tmpView));}tmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));if(this.options.AutoSolveAfterInitialize){if(this.pict.LogNoisiness>1){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," auto solving (asynchronously) after initialization..."));}tmpAnticipate.anticipate(this.solveAsync.bind(this));}if(this.options.AutoRenderMainViewportViewAfterInitialize){if(this.pict.LogNoisiness>1){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," auto rendering (asynchronously) after initialization..."));}tmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));}tmpAnticipate.wait(function(pError){if(pError){_this52.log.error("PictApp [".concat(_this52.UUID,"]::[").concat(_this52.Hash,"] ").concat(_this52.options.Name," initializeAsync Error: ").concat(pError.message||pError),{stack:pError.stack});}_this52.initializeTimestamp=_this52.fable.log.getTimeStamp();if(_this52.pict.LogNoisiness>2){_this52.log.trace("PictApp [".concat(_this52.UUID,"]::[").concat(_this52.Hash,"] ").concat(_this52.options.Name," initialization complete."));}return tmpCallback();});}else{this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," async initialize called but initialization is already completed.  Aborting."));// TODO: Should this be an error?
return tmpCallback();}}/**
	 * @return {boolean}
	 */},{key:"onAfterInitialize",value:function onAfterInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onAfterInitialize:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onAfterInitializeAsync",value:function onAfterInitializeAsync(fCallback){this.onAfterInitialize();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Marshal Data From All Views              *//* -------------------------------------------------------------------------- *//**
	 * @return {boolean}
	 */},{key:"onBeforeMarshalFromViews",value:function onBeforeMarshalFromViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onBeforeMarshalFromViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onBeforeMarshalFromViewsAsync",value:function onBeforeMarshalFromViewsAsync(fCallback){this.onBeforeMarshalFromViews();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"onMarshalFromViews",value:function onMarshalFromViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onMarshalFromViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onMarshalFromViewsAsync",value:function onMarshalFromViewsAsync(fCallback){this.onMarshalFromViews();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"marshalFromViews",value:function marshalFromViews(){if(this.pict.LogNoisiness>2){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," executing marshalFromViews() function..."));}this.onBeforeMarshalFromViews();// Now walk through any loaded views and initialize them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToMarshalFromViews=[];for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];tmpViewsToMarshalFromViews.push(tmpView);}for(var _i49=0;_i49<tmpViewsToMarshalFromViews.length;_i49++){tmpViewsToMarshalFromViews[_i49].marshalFromView();}this.onMarshalFromViews();this.onAfterMarshalFromViews();this.lastMarshalFromViewsTimestamp=this.fable.log.getTimeStamp();return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"marshalFromViewsAsync",value:function marshalFromViewsAsync(fCallback){var _this53=this;var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this53.log.error("PictApp [".concat(_this53.UUID,"]::[").concat(_this53.Hash,"] ").concat(_this53.options.Name," marshalFromViewsAsync Auto Callback Error: ").concat(pError),pError);}};}tmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));// Walk through any loaded views and marshalFromViews them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToMarshalFromViews=[];for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];tmpViewsToMarshalFromViews.push(tmpView);}for(var _i50=0;_i50<tmpViewsToMarshalFromViews.length;_i50++){tmpAnticipate.anticipate(tmpViewsToMarshalFromViews[_i50].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[_i50]));}tmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));tmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this53.pict.LogNoisiness>2){_this53.log.trace("PictApp [".concat(_this53.UUID,"]::[").concat(_this53.Hash,"] ").concat(_this53.options.Name," marshalFromViewsAsync() complete."));}_this53.lastMarshalFromViewsTimestamp=_this53.fable.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * @return {boolean}
	 */},{key:"onAfterMarshalFromViews",value:function onAfterMarshalFromViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onAfterMarshalFromViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onAfterMarshalFromViewsAsync",value:function onAfterMarshalFromViewsAsync(fCallback){this.onAfterMarshalFromViews();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Marshal Data To All Views                *//* -------------------------------------------------------------------------- *//**
	 * @return {boolean}
	 */},{key:"onBeforeMarshalToViews",value:function onBeforeMarshalToViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onBeforeMarshalToViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onBeforeMarshalToViewsAsync",value:function onBeforeMarshalToViewsAsync(fCallback){this.onBeforeMarshalToViews();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"onMarshalToViews",value:function onMarshalToViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onMarshalToViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onMarshalToViewsAsync",value:function onMarshalToViewsAsync(fCallback){this.onMarshalToViews();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"marshalToViews",value:function marshalToViews(){if(this.pict.LogNoisiness>2){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," executing marshalToViews() function..."));}this.onBeforeMarshalToViews();// Now walk through any loaded views and initialize them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToMarshalToViews=[];for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];tmpViewsToMarshalToViews.push(tmpView);}for(var _i51=0;_i51<tmpViewsToMarshalToViews.length;_i51++){tmpViewsToMarshalToViews[_i51].marshalToView();}this.onMarshalToViews();this.onAfterMarshalToViews();this.lastMarshalToViewsTimestamp=this.fable.log.getTimeStamp();return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"marshalToViewsAsync",value:function marshalToViewsAsync(fCallback){var _this54=this;var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this54.log.error("PictApp [".concat(_this54.UUID,"]::[").concat(_this54.Hash,"] ").concat(_this54.options.Name," marshalToViewsAsync Auto Callback Error: ").concat(pError),pError);}};}tmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));// Walk through any loaded views and marshalToViews them as well.
var tmpLoadedViews=Object.keys(this.pict.views);var tmpViewsToMarshalToViews=[];for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];tmpViewsToMarshalToViews.push(tmpView);}for(var _i52=0;_i52<tmpViewsToMarshalToViews.length;_i52++){tmpAnticipate.anticipate(tmpViewsToMarshalToViews[_i52].marshalToViewAsync.bind(tmpViewsToMarshalToViews[_i52]));}tmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));tmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this54.pict.LogNoisiness>2){_this54.log.trace("PictApp [".concat(_this54.UUID,"]::[").concat(_this54.Hash,"] ").concat(_this54.options.Name," marshalToViewsAsync() complete."));}_this54.lastMarshalToViewsTimestamp=_this54.fable.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * @return {boolean}
	 */},{key:"onAfterMarshalToViews",value:function onAfterMarshalToViews(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onAfterMarshalToViews:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onAfterMarshalToViewsAsync",value:function onAfterMarshalToViewsAsync(fCallback){this.onAfterMarshalToViews();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Render View                              *//* -------------------------------------------------------------------------- *//**
	 * @return {boolean}
	 */},{key:"onBeforeRender",value:function onBeforeRender(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onBeforeRender:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onBeforeRenderAsync",value:function onBeforeRenderAsync(fCallback){this.onBeforeRender();return fCallback();}/**
	 * @param {string} [pViewIdentifier] - The hash of the view to render. By default, the main viewport view is rendered.
	 * @param {string} [pRenderableHash] - The hash of the renderable to render.
	 * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string} [pTemplateDataAddress] - The address where the data for the template is stored.
	 *
	 * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?
	 */},{key:"render",value:function render(pViewIdentifier,pRenderableHash,pRenderDestinationAddress,pTemplateDataAddress){var tmpViewIdentifier=typeof pViewIdentifier!=='string'?this.options.MainViewportViewIdentifier:pViewIdentifier;var tmpRenderableHash=typeof pRenderableHash!=='string'?this.options.MainViewportRenderableHash:pRenderableHash;var tmpRenderDestinationAddress=typeof pRenderDestinationAddress!=='string'?this.options.MainViewportDestinationAddress:pRenderDestinationAddress;var tmpTemplateDataAddress=typeof pTemplateDataAddress!=='string'?this.options.MainViewportDefaultDataAddress:pTemplateDataAddress;if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," VIEW Renderable[").concat(tmpRenderableHash,"] Destination[").concat(tmpRenderDestinationAddress,"] TemplateDataAddress[").concat(tmpTemplateDataAddress,"] render:"));}this.onBeforeRender();// Now get the view (by hash) from the loaded views
var tmpView=typeof tmpViewIdentifier==='string'?this.servicesMap.PictView[tmpViewIdentifier]:false;if(!tmpView){this.log.error("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," could not render from View ").concat(tmpViewIdentifier," because it is not a valid view."));return false;}this.onRender();tmpView.render(tmpRenderableHash,tmpRenderDestinationAddress,tmpTemplateDataAddress);this.onAfterRender();return true;}/**
	 * @return {boolean}
	 */},{key:"onRender",value:function onRender(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onRender:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onRenderAsync",value:function onRenderAsync(fCallback){this.onRender();return fCallback();}/**
	 * @param {string|((error?: Error) => void)} pViewIdentifier - The hash of the view to render. By default, the main viewport view is rendered. (or the callback)
	 * @param {string|((error?: Error) => void)} [pRenderableHash] - The hash of the renderable to render. (or the callback)
	 * @param {string|((error?: Error) => void)} [pRenderDestinationAddress] - The address where the renderable will be rendered. (or the callback)
	 * @param {string|((error?: Error) => void)} [pTemplateDataAddress] - The address where the data for the template is stored. (or the callback)
	 * @param {(error?: Error) => void} [fCallback] - The callback, if all other parameters are provided.
	 *
	 * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?
	 */},{key:"renderAsync",value:function renderAsync(pViewIdentifier,pRenderableHash,pRenderDestinationAddress,pTemplateDataAddress,fCallback){var _this55=this;var tmpViewIdentifier=typeof pViewIdentifier!=='string'?this.options.MainViewportViewIdentifier:pViewIdentifier;var tmpRenderableHash=typeof pRenderableHash!=='string'?this.options.MainViewportRenderableHash:pRenderableHash;var tmpRenderDestinationAddress=typeof pRenderDestinationAddress!=='string'?this.options.MainViewportDestinationAddress:pRenderDestinationAddress;var tmpTemplateDataAddress=typeof pTemplateDataAddress!=='string'?this.options.MainViewportDefaultDataAddress:pTemplateDataAddress;// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:typeof pTemplateDataAddress==='function'?pTemplateDataAddress:typeof pRenderDestinationAddress==='function'?pRenderDestinationAddress:typeof pRenderableHash==='function'?pRenderableHash:typeof pViewIdentifier==='function'?pViewIdentifier:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this55.log.error("PictApp [".concat(_this55.UUID,"]::[").concat(_this55.Hash,"] ").concat(_this55.options.Name," renderAsync Auto Callback Error: ").concat(pError),pError);}};}if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," VIEW Renderable[").concat(tmpRenderableHash,"] Destination[").concat(tmpRenderDestinationAddress,"] TemplateDataAddress[").concat(tmpTemplateDataAddress,"] renderAsync:"));}var tmpRenderAnticipate=this.fable.newAnticipate();tmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));var tmpView=typeof tmpViewIdentifier==='string'?this.servicesMap.PictView[tmpViewIdentifier]:false;if(!tmpView){var tmpErrorMessage="PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," could not asynchronously render from View ").concat(tmpViewIdentifier," because it is not a valid view.");if(this.pict.LogNoisiness>3){this.log.error(tmpErrorMessage);}return tmpCallback(new Error(tmpErrorMessage));}tmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));tmpRenderAnticipate.anticipate(function(fNext){tmpView.renderAsync.call(tmpView,tmpRenderableHash,tmpRenderDestinationAddress,tmpTemplateDataAddress,fNext);});tmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));return tmpRenderAnticipate.wait(tmpCallback);}/**
	 * @return {boolean}
	 */},{key:"onAfterRender",value:function onAfterRender(){if(this.pict.LogNoisiness>3){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," onAfterRender:"));}return true;}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"onAfterRenderAsync",value:function onAfterRenderAsync(fCallback){this.onAfterRender();return fCallback();}/**
	 * @return {boolean}
	 */},{key:"renderMainViewport",value:function renderMainViewport(){if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderMainViewport:"));}return this.render();}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"renderMainViewportAsync",value:function renderMainViewportAsync(fCallback){if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow APPLICATION [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderMainViewportAsync:"));}return this.renderAsync(fCallback);}/**
	 * @return {void}
	 */},{key:"renderAutoViews",value:function renderAutoViews(){var _this56=this;if(this.pict.LogNoisiness>0){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," beginning renderAutoViews..."));}// Now walk through any loaded views and sort them by the AutoRender ordinal
var tmpLoadedViews=Object.keys(this.pict.views);// Sort the views by their priority
// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff
tmpLoadedViews.sort(function(a,b){return _this56.pict.views[a].options.AutoRenderOrdinal-_this56.pict.views[b].options.AutoRenderOrdinal;});for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];if(tmpView.options.AutoRender){tmpView.render();}}if(this.pict.LogNoisiness>0){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderAutoViewsAsync complete."));}}/**
	 * @param {(error?: Error) => void} fCallback
	 */},{key:"renderAutoViewsAsync",value:function renderAutoViewsAsync(fCallback){var _this57=this;var tmpAnticipate=this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this57.log.error("PictApp [".concat(_this57.UUID,"]::[").concat(_this57.Hash,"] ").concat(_this57.options.Name," renderAutoViewsAsync Auto Callback Error: ").concat(pError),pError);}};}if(this.pict.LogNoisiness>0){this.log.trace("PictApp [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," beginning renderAutoViewsAsync..."));}// Now walk through any loaded views and sort them by the AutoRender ordinal
// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.
var tmpLoadedViews=Object.keys(this.pict.views);// Sort the views by their priority
// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff
tmpLoadedViews.sort(function(a,b){return _this57.pict.views[a].options.AutoRenderOrdinal-_this57.pict.views[b].options.AutoRenderOrdinal;});for(var i=0;i<tmpLoadedViews.length;i++){var tmpView=this.pict.views[tmpLoadedViews[i]];if(tmpView.options.AutoRender){tmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));}}tmpAnticipate.wait(function(pError){_this57.lastAutoRenderTimestamp=_this57.fable.log.getTimeStamp();if(_this57.pict.LogNoisiness>0){_this57.log.trace("PictApp [".concat(_this57.UUID,"]::[").concat(_this57.Hash,"] ").concat(_this57.options.Name," renderAutoViewsAsync complete."));}return tmpCallback(pError);});}/**
	 * @return {boolean}
	 */},{key:"isPictApplication",get:function get(){return true;}}]);}(libFableServiceBase);module.exports=PictApplication;},{"../package.json":136,"fable-serviceproviderbase":59}],138:[function(require,module,exports){module.exports={"name":"pict-provider","version":"1.0.3","description":"Pict Provider Base Class","main":"source/Pict-Provider.js","scripts":{"start":"node source/Pict-Provider.js","test":"npx mocha -u tdd -R spec","tests":"npx mocha -u tdd --exit -R spec --grep","coverage":"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec","build":"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-provider-image:local","docker-dev-run":"docker run -it -d --name pict-provider-dev -p 24125:8080 -p 30027:8086 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/pict-provider\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" pict-provider-image:local","docker-dev-shell":"docker exec -it pict-provider-dev /bin/bash"},"repository":{"type":"git","url":"git+https://github.com/stevenvelozo/pict-provider.git"},"author":"steven velozo <steven@velozo.com>","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/pict-provider/issues"},"homepage":"https://github.com/stevenvelozo/pict-provider#readme","devDependencies":{"pict":"^1.0.215","quackage":"^1.0.33"},"dependencies":{"fable-serviceproviderbase":"^3.0.15"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]}};},{}],139:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var libPackage=require('../package.json');var defaultPictProviderSettings={ProviderIdentifier:false,// If this is set to true, when the App initializes this will.
// After the App initializes, initialize will be called as soon as it's added.
AutoInitialize:true,AutoInitializeOrdinal:0,AutoSolveWithApp:true,AutoSolveOrdinal:0,Manifests:{},Templates:[]};var PictProvider=/*#__PURE__*/function(_libFableServiceBase15){function PictProvider(pFable,pOptions,pServiceHash){var _this58;_classCallCheck2(this,PictProvider);// Intersect default options, parent constructor, service information
var tmpOptions=Object.assign({},JSON.parse(JSON.stringify(defaultPictProviderSettings)),pOptions);_this58=_callSuper(this,PictProvider,[pFable,tmpOptions,pServiceHash]);if(!_this58.options.ProviderIdentifier){_this58.options.ProviderIdentifier="AutoProviderID-".concat(_this58.fable.getUUID());}_this58.serviceType='PictProvider';/** @type {Object} */_this58._Package=libPackage;// Convenience and consistency naming
_this58.pict=_this58.fable;// Wire in the essential Pict application state
_this58.AppData=_this58.pict.AppData;_this58.initializeTimestamp=false;_this58.lastSolvedTimestamp=false;for(var i=0;i<_this58.options.Templates.length;i++){var tmpDefaultTemplate=_this58.options.Templates[i];if(!tmpDefaultTemplate.hasOwnProperty('Postfix')||!tmpDefaultTemplate.hasOwnProperty('Template')){_this58.log.error("PictProvider [".concat(_this58.UUID,"]::[").concat(_this58.Hash,"] ").concat(_this58.options.ProviderIdentifier," could not load Default Template ").concat(i," in the options array."),tmpDefaultTemplate);}else{if(!tmpDefaultTemplate.Source){tmpDefaultTemplate.Source="PictProvider [".concat(_this58.UUID,"]::[").concat(_this58.Hash,"] ").concat(_this58.options.ProviderIdentifier," options object.");}_this58.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix,tmpDefaultTemplate.Postfix,tmpDefaultTemplate.Template,tmpDefaultTemplate.Source);}}return _this58;}/* -------------------------------------------------------------------------- *//*                        Code Section: Initialization                        *//* -------------------------------------------------------------------------- */_inherits(PictProvider,_libFableServiceBase15);return _createClass2(PictProvider,[{key:"onBeforeInitialize",value:function onBeforeInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," onBeforeInitialize:"));}return true;}},{key:"onBeforeInitializeAsync",value:function onBeforeInitializeAsync(fCallback){this.onBeforeInitialize();return fCallback();}},{key:"onInitialize",value:function onInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," onInitialize:"));}return true;}},{key:"onInitializeAsync",value:function onInitializeAsync(fCallback){this.onInitialize();return fCallback();}},{key:"initialize",value:function initialize(){if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow PROVIDER [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," initialize:"));}if(!this.initializeTimestamp){this.onBeforeInitialize();this.onInitialize();this.onAfterInitialize();this.initializeTimestamp=this.pict.log.getTimeStamp();return true;}else{this.log.warn("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," initialize called but initialization is already completed.  Aborting."));return false;}}},{key:"initializeAsync",value:function initializeAsync(fCallback){var _this59=this;if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow PROVIDER [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," initializeAsync:"));}if(!this.initializeTimestamp){var tmpAnticipate=this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');if(this.pict.LogNoisiness>0){this.log.info("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," beginning initialization..."));}tmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));tmpAnticipate.anticipate(this.onInitializeAsync.bind(this));tmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));tmpAnticipate.wait(function(pError){_this59.initializeTimestamp=_this59.pict.log.getTimeStamp();if(_this59.pict.LogNoisiness>0){_this59.log.info("PictProvider [".concat(_this59.UUID,"]::[").concat(_this59.Hash,"] ").concat(_this59.options.ProviderIdentifier," initialization complete."));}return fCallback();});}else{this.log.warn("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," async initialize called but initialization is already completed.  Aborting."));// TODO: Should this be an error?
return fCallback();}}},{key:"onAfterInitialize",value:function onAfterInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," onAfterInitialize:"));}return true;}},{key:"onAfterInitializeAsync",value:function onAfterInitializeAsync(fCallback){this.onAfterInitialize();return fCallback();}},{key:"onPreRender",value:function onPreRender(){if(this.pict.LogNoisiness>3){this.log.trace("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," onPreRender:"));}return true;}},{key:"onPreRenderAsync",value:function onPreRenderAsync(fCallback){this.onPreRender();return fCallback();}},{key:"render",value:function render(){return this.onPreRender();}},{key:"renderAsync",value:function renderAsync(fCallback){this.onPreRender();return fCallback();}},{key:"onPreSolve",value:function onPreSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictProvider [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ProviderIdentifier," onPreSolve:"));}return true;}},{key:"onPreSolveAsync",value:function onPreSolveAsync(fCallback){this.onPreSolve();return fCallback();}},{key:"solve",value:function solve(){return this.onPreSolve();}},{key:"solveAsync",value:function solveAsync(fCallback){this.onPreSolve();return fCallback();}}]);}(libFableServiceBase);module.exports=PictProvider;},{"../package.json":138,"fable-serviceproviderbase":59}],140:[function(require,module,exports){module.exports={"name":"pict-template","version":"1.0.10","description":"Pict Template Base Class","main":"source/Pict-Template.js","scripts":{"start":"node source/Pict-Template.js","test":"npx mocha -u tdd -R spec","tests":"npx mocha -u tdd --exit -R spec --grep","coverage":"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec","build":"npx quack build","types":"tsc -p ."},"types":"types/source/Pict-Template.d.ts","repository":{"type":"git","url":"git+https://github.com/stevenvelozo/pict-view.git"},"author":"steven velozo <steven@velozo.com>","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/pict-view/issues"},"homepage":"https://github.com/stevenvelozo/pict-view#readme","devDependencies":{"pict":"^1.0.227","quackage":"^1.0.36","typescript":"^5.7.2"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"dependencies":{"fable-serviceproviderbase":"^3.0.15"}};},{}],141:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var libPackage=require('../package.json');/** @typedef {import('pict') & {
 *     [key: string]: any, // represent services for now as a workaround
 * }} Pict *//**
 * @class PictTemplateExpression
 * @classdesc The PictTemplateExpression class is a service provider for the pict anti-framework that provides template rendering services.
 */var PictTemplateExpression=/*#__PURE__*/function(_libFableServiceBase16){/**
	 * @param {Pict} pFable - The Fable Framework instance
	 * @param {any} [pOptions] - The options for the service
	 * @param {String} [pServiceHash] - The hash of the service
	 */function PictTemplateExpression(pFable,pOptions,pServiceHash){var _this60;_classCallCheck2(this,PictTemplateExpression);_this60=_callSuper(this,PictTemplateExpression,[pFable,pOptions,pServiceHash]);/** @type {Pict} */_this60.fable;/** @type {Pict} */_this60.pict=_this60.fable;_this60.serviceType='PictTemplate';/** @type {Object} */_this60._Package=libPackage;return _this60;}/**
	 * Render a template expression, returning a string with the resulting content.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 *
	 * @return {string} The rendered template
	 */_inherits(PictTemplateExpression,_libFableServiceBase16);return _createClass2(PictTemplateExpression,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){return'';}/**
	 * Render a template expression, deliver a string with the resulting content to a callback function.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 * @param {(error?: Error, content?: String) => void} fCallback - callback function invoked with the rendered template, or an error
	 *
	 * @return {void}
	 */},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){return fCallback(null,this.render(pTemplateHash,pRecord,pContextArray));}/**
	 * Provide a match criteria for a template expression.  Anything between these two values is returned as the template hash.
	 *
	 * @param {string} pMatchStart - The string pattern to start a match in the template trie
	 * @param {string} pMatchEnd  - The string pattern to stop a match in the trie acyclic graph
	 *
	 * @return {void}
	 */},{key:"addPattern",value:function addPattern(pMatchStart,pMatchEnd){return this.pict.MetaTemplate.addPatternBoth(pMatchStart,pMatchEnd,this.render,this.renderAsync,this);}/**
	 * Read a value from a nested object using a dot notation string.
	 *
	 * @param {string} pAddress - The address to resolve
	 * @param {any} pRecord - The record to resolve
	 * @param {Array<any>} pContextArray - The context array to resolve (optional)
	 * @param {any} pRootDataObject - The root data object to resolve (optional)
	 *
	 * @return {any} The value at the given address, or undefined
	 */},{key:"resolveStateFromAddress",value:function resolveStateFromAddress(pAddress,pRecord,pContextArray,pRootDataObject){var tmpContextArray=Array.isArray(pContextArray)?pContextArray:[this.pict];var tmpRootDataObject=_typeof(pRootDataObject)==='object'?pRootDataObject:{};tmpRootDataObject.Pict=this.pict;tmpRootDataObject.AppData=this.pict.AppData;tmpRootDataObject.Bundle=this.pict.Bundle;tmpRootDataObject.Context=tmpContextArray;tmpRootDataObject.Record=pRecord;return this.pict.manifest.getValueByHash(tmpRootDataObject,pAddress);}}]);}(libFableServiceBase);module.exports=PictTemplateExpression;module.exports.template_hash='Default';},{"../package.json":140,"fable-serviceproviderbase":59}],142:[function(require,module,exports){module.exports={"name":"pict-view","version":"1.0.59","description":"Pict View Base Class","main":"source/Pict-View.js","scripts":{"test":"./node_modules/.bin/mocha -u tdd -R spec","start":"node source/Pict-View.js","coverage":"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec","build":"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-view-image:local","docker-dev-run":"docker run -it -d --name pict-view-dev -p 30001:8080 -p 38086:8086 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/pict-view\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" pict-view-image:local","docker-dev-shell":"docker exec -it pict-view-dev /bin/bash","types":"tsc -p .","lint":"eslint source/**"},"types":"types/source/Pict-View.d.ts","repository":{"type":"git","url":"git+https://github.com/stevenvelozo/pict-view.git"},"author":"steven velozo <steven@velozo.com>","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/pict-view/issues"},"homepage":"https://github.com/stevenvelozo/pict-view#readme","devDependencies":{"@eslint/js":"^9.17.0","browser-env":"^3.3.0","eslint":"^9.17.0","pict":"^1.0.228","quackage":"^1.0.36","typescript":"^5.7.2"},"mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"dependencies":{"fable":"^3.0.146","fable-serviceproviderbase":"^3.0.15"}};},{}],143:[function(require,module,exports){var libFableServiceBase=require('fable-serviceproviderbase');var libPackage=require('../package.json');var defaultPictViewSettings={DefaultRenderable:false,DefaultDestinationAddress:false,DefaultTemplateRecordAddress:false,ViewIdentifier:false,// If this is set to true, when the App initializes this will.
// After the App initializes, initialize will be called as soon as it's added.
AutoInitialize:true,AutoInitializeOrdinal:0,// If this is set to true, when the App autorenders (on load) this will.
// After the App initializes, render will be called as soon as it's added.
AutoRender:true,AutoRenderOrdinal:0,AutoSolveWithApp:true,AutoSolveOrdinal:0,CSSHash:false,CSS:false,CSSProvider:false,CSSPriority:500,Templates:[],DefaultTemplates:[],Renderables:[],Manifests:{}};/** @typedef {(error?: Error) => void} ErrorCallback *//** @typedef {number | boolean} PictTimestamp *//**
 * @typedef {'replace' | 'append' | 'prepend' | 'append_once'} RenderMethod
 *//**
 * @typedef {Object} Renderable
 *
 * @property {string} RenderableHash - A unique hash for the renderable.
 * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.
 * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.
 * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.
 * @property {RenderMethod} [RenderMethod=replace] - The method to use when projecting the renderable to the DOM ('replace', 'append', 'prepend', 'append_once').
 * @property {string} [TestAddress] - The address to use for testing the renderable.
 *//**
 * Represents a view in the Pict ecosystem.
 */var PictView=/*#__PURE__*/function(_libFableServiceBase17){/**
	 * @param {any} pFable - The Fable object that this service is attached to.
	 * @param {any} [pOptions] - (optional) The options for this service.
	 * @param {string} [pServiceHash] - (optional) The hash of the service.
	 */function PictView(pFable,pOptions,pServiceHash){var _this61;_classCallCheck2(this,PictView);// Intersect default options, parent constructor, service information
var tmpOptions=Object.assign({},JSON.parse(JSON.stringify(defaultPictViewSettings)),pOptions);_this61=_callSuper(this,PictView,[pFable,tmpOptions,pServiceHash]);//FIXME: add types to fable and ancillaries
/** @type {any} */_this61.fable;/** @type {any} */_this61.options;/** @type {String} */_this61.UUID;/** @type {String} */_this61.Hash;/** @type {any} */_this61.log;if(!_this61.options.ViewIdentifier){_this61.options.ViewIdentifier="AutoViewID-".concat(_this61.fable.getUUID());}_this61.serviceType='PictView';/** @type {Object} */_this61._Package=libPackage;// Convenience and consistency naming
/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */_this61.pict=_this61.fable;// Wire in the essential Pict application state
_this61.AppData=_this61.pict.AppData;/** @type {PictTimestamp} */_this61.initializeTimestamp=false;/** @type {PictTimestamp} */_this61.lastSolvedTimestamp=false;/** @type {PictTimestamp} */_this61.lastRenderedTimestamp=false;/** @type {PictTimestamp} */_this61.lastMarshalFromViewTimestamp=false;/** @type {PictTimestamp} */_this61.lastMarshalToViewTimestamp=false;// Load all templates from the array in the options
// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}
for(var i=0;i<_this61.options.Templates.length;i++){var tmpTemplate=_this61.options.Templates[i];if(!('Hash'in tmpTemplate)||!('Template'in tmpTemplate)){_this61.log.error("PictView [".concat(_this61.UUID,"]::[").concat(_this61.Hash,"] ").concat(_this61.options.ViewIdentifier," could not load Template ").concat(i," in the options array."),tmpTemplate);}else{if(!tmpTemplate.Source){tmpTemplate.Source="PictView [".concat(_this61.UUID,"]::[").concat(_this61.Hash,"] ").concat(_this61.options.ViewIdentifier," options object.");}_this61.pict.TemplateProvider.addTemplate(tmpTemplate.Hash,tmpTemplate.Template,tmpTemplate.Source);}}// Load all default templates from the array in the options
// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}
for(var _i53=0;_i53<_this61.options.DefaultTemplates.length;_i53++){var tmpDefaultTemplate=_this61.options.DefaultTemplates[_i53];if(!('Postfix'in tmpDefaultTemplate)||!('Template'in tmpDefaultTemplate)){_this61.log.error("PictView [".concat(_this61.UUID,"]::[").concat(_this61.Hash,"] ").concat(_this61.options.ViewIdentifier," could not load Default Template ").concat(_i53," in the options array."),tmpDefaultTemplate);}else{if(!tmpDefaultTemplate.Source){tmpDefaultTemplate.Source="PictView [".concat(_this61.UUID,"]::[").concat(_this61.Hash,"] ").concat(_this61.options.ViewIdentifier," options object.");}_this61.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix,tmpDefaultTemplate.Postfix,tmpDefaultTemplate.Template,tmpDefaultTemplate.Source);}}// Load the CSS if it's available
if(_this61.options.CSS){var tmpCSSHash=_this61.options.CSSHash?_this61.options.CSSHash:"View-".concat(_this61.options.ViewIdentifier);var tmpCSSProvider=_this61.options.CSSProvider?_this61.options.CSSProvider:tmpCSSHash;_this61.pict.CSSMap.addCSS(tmpCSSHash,_this61.options.CSS,tmpCSSProvider,_this61.options.CSSPriority);}// Load all renderables
// Renderables are launchable renderable instructions with templates
// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}
// The only parts that are necessary are Identifier and Template
// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress
/** @type {Object<String, Renderable>} */_this61.renderables={};for(var _i54=0;_i54<_this61.options.Renderables.length;_i54++){/** @type {Renderable} */var tmpRenderable=_this61.options.Renderables[_i54];_this61.addRenderable(tmpRenderable);}return _this61;}/**
	 * Adds a renderable to the view.
	 *
	 * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.
	 * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.
	 * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.
	 * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.
	 * @param {RenderMethod} [pRenderMethod=replace] - (optional) The method to use when rendering the renderable (ex. 'replace').
	 */_inherits(PictView,_libFableServiceBase17);return _createClass2(PictView,[{key:"addRenderable",value:function addRenderable(pRenderableHash,pTemplateHash,pDefaultTemplateRecordAddress,pDefaultDestinationAddress,pRenderMethod){/** @type {Renderable} */var tmpRenderable;if(_typeof(pRenderableHash)=='object'){// The developer passed in the renderable as an object.
// Use theirs instead!
tmpRenderable=pRenderableHash;}else{/** @type {RenderMethod} */var tmpRenderMethod=typeof pRenderMethod!=='string'?pRenderMethod:'replace';tmpRenderable={RenderableHash:pRenderableHash,TemplateHash:pTemplateHash,DefaultTemplateRecordAddress:pDefaultTemplateRecordAddress,ContentDestinationAddress:pDefaultDestinationAddress,RenderMethod:tmpRenderMethod};}if(typeof tmpRenderable.RenderableHash!='string'||typeof tmpRenderable.TemplateHash!='string'){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not load Renderable; RenderableHash or TemplateHash are invalid."),tmpRenderable);}else{if(this.pict.LogNoisiness>0){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," adding renderable [").concat(tmpRenderable.RenderableHash,"] pointed to template ").concat(tmpRenderable.TemplateHash,"."));}this.renderables[tmpRenderable.RenderableHash]=tmpRenderable;}}/* -------------------------------------------------------------------------- *//*                        Code Section: Initialization                        *//* -------------------------------------------------------------------------- *//**
	 * Lifecycle hook that triggers before the view is initialized.
	 */},{key:"onBeforeInitialize",value:function onBeforeInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onBeforeInitialize:"));}return true;}/**
	 * Lifecycle hook that triggers before the view is initialized (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onBeforeInitializeAsync",value:function onBeforeInitializeAsync(fCallback){this.onBeforeInitialize();return fCallback();}/**
	 * Lifecycle hook that triggers when the view is initialized.
	 */},{key:"onInitialize",value:function onInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onInitialize:"));}return true;}/**
	 * Lifecycle hook that triggers when the view is initialized (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onInitializeAsync",value:function onInitializeAsync(fCallback){this.onInitialize();return fCallback();}/**
	 * Performs view initialization.
	 */},{key:"initialize",value:function initialize(){if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow VIEW [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," initialize:"));}if(!this.initializeTimestamp){this.onBeforeInitialize();this.onInitialize();this.onAfterInitialize();this.initializeTimestamp=this.pict.log.getTimeStamp();return true;}else{this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," initialize called but initialization is already completed.  Aborting."));return false;}}/**
	 * Performs view initialization (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"initializeAsync",value:function initializeAsync(fCallback){var _this62=this;if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow VIEW [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," initializeAsync:"));}if(!this.initializeTimestamp){var tmpAnticipate=this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');if(this.pict.LogNoisiness>0){this.log.info("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," beginning initialization..."));}tmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));tmpAnticipate.anticipate(this.onInitializeAsync.bind(this));tmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));tmpAnticipate.wait(/** @param {Error} pError */function(pError){if(pError){_this62.log.error("PictView [".concat(_this62.UUID,"]::[").concat(_this62.Hash,"] ").concat(_this62.options.ViewIdentifier," initialization failed: ").concat(pError.message||pError),{stack:pError.stack});}_this62.initializeTimestamp=_this62.pict.log.getTimeStamp();if(_this62.pict.LogNoisiness>0){_this62.log.info("PictView [".concat(_this62.UUID,"]::[").concat(_this62.Hash,"] ").concat(_this62.options.ViewIdentifier," initialization complete."));}return fCallback();});}else{this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," async initialize called but initialization is already completed.  Aborting."));// TODO: Should this be an error?
return fCallback();}}},{key:"onAfterInitialize",value:function onAfterInitialize(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onAfterInitialize:"));}return true;}/**
	 * Lifecycle hook that triggers after the view is initialized (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onAfterInitializeAsync",value:function onAfterInitializeAsync(fCallback){this.onAfterInitialize();return fCallback();}/* -------------------------------------------------------------------------- *//*                            Code Section: Render                            *//* -------------------------------------------------------------------------- *//**
	 * Lifecycle hook that triggers before the view is rendered.
	 *
	 * @param {Renderable} pRenderable - The renderable that will be rendered.
	 * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.
	 * @param {any} pRecord - The record (data) that will be used to render the renderable.
	 */},{key:"onBeforeRender",value:function onBeforeRender(pRenderable,pRenderDestinationAddress,pRecord){// Overload this to mess with stuff before the content gets generated from the template
if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onBeforeRender:"));}return true;}/**
	 * Lifecycle hook that triggers before the view is rendered (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onBeforeRenderAsync",value:function onBeforeRenderAsync(fCallback){return fCallback();}/**
	 * Builds the render options for a renderable.
	 *
	 * For DRY purposes on the three flavors of render.
	 *
	 * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.
	 * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.
	 */},{key:"buildRenderOptions",value:function buildRenderOptions(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress){var tmpRenderOptions={Valid:true};tmpRenderOptions.RenderableHash=typeof pRenderableHash==='string'?pRenderableHash:typeof this.options.DefaultRenderable=='string'?this.options.DefaultRenderable:false;if(!tmpRenderOptions.RenderableHash){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not find a suitable RenderableHash ").concat(tmpRenderOptions.RenderableHash," (param ").concat(pRenderableHash,"because it is not a valid renderable."));tmpRenderOptions.Valid=false;}tmpRenderOptions.Renderable=this.renderables[tmpRenderOptions.RenderableHash];if(!tmpRenderOptions.Renderable){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderOptions.RenderableHash," (param ").concat(pRenderableHash,") because it does not exist."));tmpRenderOptions.Valid=false;}tmpRenderOptions.DestinationAddress=typeof pRenderDestinationAddress==='string'?pRenderDestinationAddress:typeof tmpRenderOptions.Renderable.ContentDestinationAddress==='string'?tmpRenderOptions.Renderable.ContentDestinationAddress:typeof this.options.DefaultDestinationAddress==='string'?this.options.DefaultDestinationAddress:false;if(!tmpRenderOptions.DestinationAddress){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderOptions.RenderableHash," (param ").concat(pRenderableHash,") because it does not have a valid destination address (param ").concat(pRenderDestinationAddress,")."));tmpRenderOptions.Valid=false;}if(_typeof(pTemplateRecordAddress)==='object'){tmpRenderOptions.RecordAddress='Passed in as object';tmpRenderOptions.Record=pTemplateRecordAddress;}else{tmpRenderOptions.RecordAddress=typeof pTemplateRecordAddress==='string'?pTemplateRecordAddress:typeof tmpRenderOptions.Renderable.DefaultTemplateRecordAddress==='string'?tmpRenderOptions.Renderable.DefaultTemplateRecordAddress:typeof this.options.DefaultTemplateRecordAddress==='string'?this.options.DefaultTemplateRecordAddress:false;tmpRenderOptions.Record=typeof tmpRenderOptions.RecordAddress==='string'?this.pict.DataProvider.getDataByAddress(tmpRenderOptions.RecordAddress):undefined;}return tmpRenderOptions;}/**
	 * Assigns the content to the destination address.
	 *
	 * For DRY purposes on the three flavors of render.
	 *
	 * @param {Renderable} pRenderable - The renderable to render.
	 * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.
	 * @param {string} pContent - The content to render.
	 * @returns {boolean} - Returns true if the content was assigned successfully.
	 * @memberof PictView
	 */},{key:"assignRenderContent",value:function assignRenderContent(pRenderable,pRenderDestinationAddress,pContent){return this.pict.ContentAssignment.projectContent(pRenderable.RenderMethod,pRenderDestinationAddress,pContent,pRenderable.TestAddress);}/**
	 * Render a renderable from this view.
	 *
	 * @param {string} [pRenderable] - The hash of the renderable to render.
	 * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string|object} [pTemplateRecordAddress] - The address where the data for the template is stored.
	 * @return {boolean}
	 */},{key:"render",value:function render(pRenderable,pRenderDestinationAddress,pTemplateRecordAddress){var tmpRenderableHash=typeof pRenderable==='string'?pRenderable:typeof this.options.DefaultRenderable=='string'?this.options.DefaultRenderable:false;if(!tmpRenderableHash){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderable,") because it is not a valid renderable."));return false;}var tmpRenderable=this.renderables[tmpRenderableHash];if(!tmpRenderable){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderable,") because it does not exist."));return false;}var tmpRenderDestinationAddress=typeof pRenderDestinationAddress==='string'?pRenderDestinationAddress:typeof tmpRenderable.ContentDestinationAddress==='string'?tmpRenderable.ContentDestinationAddress:typeof this.options.DefaultDestinationAddress==='string'?this.options.DefaultDestinationAddress:false;if(!tmpRenderDestinationAddress){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderable,") because it does not have a valid destination address."));return false;}var tmpRecordAddress;var tmpRecord;if(_typeof(pTemplateRecordAddress)==='object'){tmpRecord=pTemplateRecordAddress;tmpRecordAddress='Passed in as object';}else{tmpRecordAddress=typeof pTemplateRecordAddress==='string'?pTemplateRecordAddress:typeof tmpRenderable.DefaultTemplateRecordAddress==='string'?tmpRenderable.DefaultTemplateRecordAddress:typeof this.options.DefaultTemplateRecordAddress==='string'?this.options.DefaultTemplateRecordAddress:false;tmpRecord=typeof tmpRecordAddress==='string'?this.pict.DataProvider.getDataByAddress(tmpRecordAddress):undefined;}// Execute the developer-overridable pre-render behavior
this.onBeforeRender(tmpRenderable,tmpRenderDestinationAddress,tmpRecord);if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow VIEW [".concat(this.UUID,"]::[").concat(this.Hash,"] Renderable[").concat(tmpRenderableHash,"] Destination[").concat(tmpRenderDestinationAddress,"] TemplateRecordAddress[").concat(tmpRecordAddress,"] render:"));}if(this.pict.LogNoisiness>0){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," Beginning Render of Renderable[").concat(tmpRenderableHash,"] to Destination [").concat(tmpRenderDestinationAddress,"]..."));}// Generate the content output from the template and data
var tmpContent=this.pict.parseTemplateByHash(tmpRenderable.TemplateHash,tmpRecord,null,[this]);if(this.pict.LogNoisiness>0){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," Assigning Renderable[").concat(tmpRenderableHash,"] content length ").concat(tmpContent.length," to Destination [").concat(tmpRenderDestinationAddress,"] using render method [").concat(tmpRenderable.RenderMethod,"]."));}// Assign the content to the destination address
this.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod,tmpRenderDestinationAddress,tmpContent,tmpRenderable.TestAddress);// Execute the developer-overridable post-render behavior
this.onAfterRender(tmpRenderable,tmpRenderDestinationAddress,tmpRecord,tmpContent);this.lastRenderedTimestamp=this.pict.log.getTimeStamp();return true;}/**
	 * Render a renderable from this view.
	 *
	 * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.
	 * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.
	 * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.
	 *
	 * @return {void}
	 */},{key:"renderAsync",value:function renderAsync(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress,fCallback){var _this63=this;var tmpRenderableHash=typeof pRenderableHash==='string'?pRenderableHash:typeof this.options.DefaultRenderable=='string'?this.options.DefaultRenderable:false;// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:typeof pTemplateRecordAddress==='function'?pTemplateRecordAddress:typeof pRenderDestinationAddress==='function'?pRenderDestinationAddress:typeof pRenderableHash==='function'?pRenderableHash:false;if(!tmpCallback){this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this63.log.error("PictView [".concat(_this63.UUID,"]::[").concat(_this63.Hash,"] ").concat(_this63.options.Name," renderAsync Auto Callback Error: ").concat(pError),pError);}};}if(!tmpRenderableHash){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not asynchronously render ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,"because it is not a valid renderable."));return tmpCallback(Error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not asynchronously render ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,"because it is not a valid renderable.")));}var tmpRenderable=this.renderables[tmpRenderableHash];if(!tmpRenderable){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,") because it does not exist."));return tmpCallback(Error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,") because it does not exist.")));}var tmpRenderDestinationAddress=typeof pRenderDestinationAddress==='string'?pRenderDestinationAddress:typeof tmpRenderable.ContentDestinationAddress==='string'?tmpRenderable.ContentDestinationAddress:typeof this.options.DefaultDestinationAddress==='string'?this.options.DefaultDestinationAddress:false;if(!tmpRenderDestinationAddress){this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not render ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,") because it does not have a valid destination address."));return tmpCallback(Error("Could not render ".concat(tmpRenderableHash)));}var tmpRecordAddress;var tmpRecord;if(_typeof(pTemplateRecordAddress)==='object'){tmpRecord=pTemplateRecordAddress;tmpRecordAddress='Passed in as object';}else{tmpRecordAddress=typeof pTemplateRecordAddress==='string'?pTemplateRecordAddress:typeof tmpRenderable.DefaultTemplateRecordAddress==='string'?tmpRenderable.DefaultTemplateRecordAddress:typeof this.options.DefaultTemplateRecordAddress==='string'?this.options.DefaultTemplateRecordAddress:false;tmpRecord=typeof tmpRecordAddress==='string'?this.pict.DataProvider.getDataByAddress(tmpRecordAddress):undefined;}if(this.pict.LogControlFlow){this.log.trace("PICT-ControlFlow VIEW [".concat(this.UUID,"]::[").concat(this.Hash,"] Renderable[").concat(tmpRenderableHash,"] Destination[").concat(tmpRenderDestinationAddress,"] TemplateRecordAddress[").concat(tmpRecordAddress,"] renderAsync:"));}if(this.pict.LogNoisiness>2){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," Beginning Asynchronous Render (callback-style)..."));}var tmpAnticipate=this.fable.newAnticipate();tmpAnticipate.anticipate(function(fOnBeforeRenderCallback){_this63.onBeforeRender(tmpRenderable,tmpRenderDestinationAddress,tmpRecord);_this63.onBeforeRenderAsync(fOnBeforeRenderCallback);});var tmpContent;tmpAnticipate.anticipate(function(fAsyncTemplateCallback){// Render the template (asynchronously)
_this63.pict.parseTemplateByHash(tmpRenderable.TemplateHash,tmpRecord,function(pError,pContent){if(pError){_this63.log.error("PictView [".concat(_this63.UUID,"]::[").concat(_this63.Hash,"] ").concat(_this63.options.ViewIdentifier," could not render (asynchronously) ").concat(tmpRenderableHash," (param ").concat(pRenderableHash,") because it did not parse the template."),pError);return fAsyncTemplateCallback(pError);}tmpContent=pContent;if(_this63.pict.LogNoisiness>0){_this63.log.trace("PictView [".concat(_this63.UUID,"]::[").concat(_this63.Hash,"] ").concat(_this63.options.ViewIdentifier," Assigning Renderable[").concat(tmpRenderableHash,"] content length ").concat(pContent.length," to Destination [").concat(tmpRenderDestinationAddress,"] using Async render method ").concat(tmpRenderable.RenderMethod,"."));}_this63.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod,tmpRenderDestinationAddress,pContent,tmpRenderable.TestAddress);// Execute the developer-overridable asynchronous post-render behavior
_this63.lastRenderedTimestamp=_this63.pict.log.getTimeStamp();return fAsyncTemplateCallback();},[_this63]);});tmpAnticipate.anticipate(function(fOnAfterRenderCallback){_this63.onAfterRender(tmpRenderable,tmpRenderDestinationAddress,tmpRecord,tmpContent);_this63.onAfterRenderAsync(fOnAfterRenderCallback);});tmpAnticipate.wait(tmpCallback);}/**
	 * Renders the default renderable.
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"renderDefaultAsync",value:function renderDefaultAsync(fCallback){// Render the default renderable
this.renderAsync(fCallback);}/**
	 * @param {string} [pRenderableHash] - The hash of the renderable to render.
	 * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.
	 */},{key:"basicRender",value:function basicRender(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress){var tmpRenderOptions=this.buildRenderOptions(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress);if(tmpRenderOptions.Valid){this.assignRenderContent(tmpRenderOptions.Renderable,tmpRenderOptions.DestinationAddress,this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash,tmpRenderOptions.Record,null,[this]));return true;}else{this.log.error("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not perform a basic render of ").concat(tmpRenderOptions.RenderableHash," because it is not valid."));return false;}}/**
	 * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.
	 * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.
	 * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.
	 * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.
	 */},{key:"basicRenderAsync",value:function basicRenderAsync(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress,fCallback){var _this64=this;// Allow the callback to be passed in as the last parameter no matter what
var tmpCallback=typeof fCallback==='function'?fCallback:typeof pTemplateRecordAddress==='function'?pTemplateRecordAddress:typeof pRenderDestinationAddress==='function'?pRenderDestinationAddress:typeof pRenderableHash==='function'?pRenderableHash:false;var tmpRenderOptions=this.buildRenderOptions(pRenderableHash,pRenderDestinationAddress,pTemplateRecordAddress);if(tmpRenderOptions.Valid){this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash,tmpRenderOptions.Record,function(pError,pContent){if(pError){_this64.log.error("PictView [".concat(_this64.UUID,"]::[").concat(_this64.Hash,"] ").concat(_this64.options.ViewIdentifier," could not render (asynchronously) ").concat(tmpRenderOptions.RenderableHash," because it did not parse the template."),pError);return tmpCallback(pError);}_this64.assignRenderContent(tmpRenderOptions.Renderable,tmpRenderOptions.DestinationAddress,pContent);return tmpCallback();},[this]);}else{var tmpErrorMessage="PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," could not perform a basic render of ").concat(tmpRenderOptions.RenderableHash," because it is not valid.");this.log.error(tmpErrorMessage);return tmpCallback(tmpErrorMessage);}}/**
	 * Lifecycle hook that triggers after the view is rendered.
	 *
	 * @param {Renderable} pRenderable - The renderable that was rendered.
	 * @param {string} pRenderDestinationAddress - The address where the renderable was rendered.
	 * @param {any} pRecord - The record (data) that was used by the renderable.
	 * @param {string} pContent - The content that was rendered.
	 */},{key:"onAfterRender",value:function onAfterRender(pRenderable,pRenderDestinationAddress,pRecord,pContent){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onAfterRender:"));}return true;}/**
	 * Lifecycle hook that triggers after the view is rendered (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onAfterRenderAsync",value:function onAfterRenderAsync(fCallback){return fCallback();}/* -------------------------------------------------------------------------- *//*                            Code Section: Solver                            *//* -------------------------------------------------------------------------- *//**
	 * Lifecycle hook that triggers before the view is solved.
	 */},{key:"onBeforeSolve",value:function onBeforeSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onBeforeSolve:"));}return true;}/**
	 * Lifecycle hook that triggers before the view is solved (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onBeforeSolveAsync",value:function onBeforeSolveAsync(fCallback){this.onBeforeSolve();return fCallback();}/**
	 * Lifecycle hook that triggers when the view is solved.
	 */},{key:"onSolve",value:function onSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onSolve:"));}return true;}/**
	 * Lifecycle hook that triggers when the view is solved (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onSolveAsync",value:function onSolveAsync(fCallback){this.onSolve();return fCallback();}/**
	 * Performs view solving and triggers lifecycle hooks.
	 *
	 * @return {boolean} - True if the view was solved successfully, false otherwise.
	 */},{key:"solve",value:function solve(){if(this.pict.LogNoisiness>2){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," executing solve() function..."));}this.onBeforeSolve();this.onSolve();this.onAfterSolve();this.lastSolvedTimestamp=this.pict.log.getTimeStamp();return true;}/**
	 * Performs view solving and triggers lifecycle hooks (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"solveAsync",value:function solveAsync(fCallback){var _this65=this;var tmpAnticipate=this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this65.log.error("PictView [".concat(_this65.UUID,"]::[").concat(_this65.Hash,"] ").concat(_this65.options.Name," solveAsync Auto Callback Error: ").concat(pError),pError);}};}tmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));tmpAnticipate.anticipate(this.onSolveAsync.bind(this));tmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this65.pict.LogNoisiness>2){_this65.log.trace("PictView [".concat(_this65.UUID,"]::[").concat(_this65.Hash,"] ").concat(_this65.options.ViewIdentifier," solveAsync() complete."));}_this65.lastSolvedTimestamp=_this65.pict.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * Lifecycle hook that triggers after the view is solved.
	 */},{key:"onAfterSolve",value:function onAfterSolve(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onAfterSolve:"));}return true;}/**
	 * Lifecycle hook that triggers after the view is solved (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onAfterSolveAsync",value:function onAfterSolveAsync(fCallback){this.onAfterSolve();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Marshal From View                        *//* -------------------------------------------------------------------------- *//**
	 * Lifecycle hook that triggers before data is marshaled from the view.
	 *
	 * @return {boolean} - True if the operation was successful, false otherwise.
	 */},{key:"onBeforeMarshalFromView",value:function onBeforeMarshalFromView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onBeforeMarshalFromView:"));}return true;}/**
	 * Lifecycle hook that triggers before data is marshaled from the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onBeforeMarshalFromViewAsync",value:function onBeforeMarshalFromViewAsync(fCallback){this.onBeforeMarshalFromView();return fCallback();}/**
	 * Lifecycle hook that triggers when data is marshaled from the view.
	 */},{key:"onMarshalFromView",value:function onMarshalFromView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onMarshalFromView:"));}return true;}/**
	 * Lifecycle hook that triggers when data is marshaled from the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onMarshalFromViewAsync",value:function onMarshalFromViewAsync(fCallback){this.onMarshalFromView();return fCallback();}/**
	 * Marshals data from the view.
	 *
	 * @return {boolean} - True if the operation was successful, false otherwise.
	 */},{key:"marshalFromView",value:function marshalFromView(){if(this.pict.LogNoisiness>2){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," executing solve() function..."));}this.onBeforeMarshalFromView();this.onMarshalFromView();this.onAfterMarshalFromView();this.lastMarshalFromViewTimestamp=this.pict.log.getTimeStamp();return true;}/**
	 * Marshals data from the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"marshalFromViewAsync",value:function marshalFromViewAsync(fCallback){var _this66=this;var tmpAnticipate=this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this66.log.error("PictView [".concat(_this66.UUID,"]::[").concat(_this66.Hash,"] ").concat(_this66.options.Name," marshalFromViewAsync Auto Callback Error: ").concat(pError),pError);}};}tmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));tmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));tmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this66.pict.LogNoisiness>2){_this66.log.trace("PictView [".concat(_this66.UUID,"]::[").concat(_this66.Hash,"] ").concat(_this66.options.ViewIdentifier," marshalFromViewAsync() complete."));}_this66.lastMarshalFromViewTimestamp=_this66.pict.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * Lifecycle hook that triggers after data is marshaled from the view.
	 */},{key:"onAfterMarshalFromView",value:function onAfterMarshalFromView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onAfterMarshalFromView:"));}return true;}/**
	 * Lifecycle hook that triggers after data is marshaled from the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onAfterMarshalFromViewAsync",value:function onAfterMarshalFromViewAsync(fCallback){this.onAfterMarshalFromView();return fCallback();}/* -------------------------------------------------------------------------- *//*                     Code Section: Marshal To View                          *//* -------------------------------------------------------------------------- *//**
	 * Lifecycle hook that triggers before data is marshaled into the view.
	 */},{key:"onBeforeMarshalToView",value:function onBeforeMarshalToView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onBeforeMarshalToView:"));}return true;}/**
	 * Lifecycle hook that triggers before data is marshaled into the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onBeforeMarshalToViewAsync",value:function onBeforeMarshalToViewAsync(fCallback){this.onBeforeMarshalToView();return fCallback();}/**
	 * Lifecycle hook that triggers when data is marshaled into the view.
	 */},{key:"onMarshalToView",value:function onMarshalToView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onMarshalToView:"));}return true;}/**
	 * Lifecycle hook that triggers when data is marshaled into the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onMarshalToViewAsync",value:function onMarshalToViewAsync(fCallback){this.onMarshalToView();return fCallback();}/**
	 * Marshals data into the view.
	 *
	 * @return {boolean} - True if the operation was successful, false otherwise.
	 */},{key:"marshalToView",value:function marshalToView(){if(this.pict.LogNoisiness>2){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," executing solve() function..."));}this.onBeforeMarshalToView();this.onMarshalToView();this.onAfterMarshalToView();this.lastMarshalToViewTimestamp=this.pict.log.getTimeStamp();return true;}/**
	 * Marshals data into the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"marshalToViewAsync",value:function marshalToViewAsync(fCallback){var _this67=this;var tmpAnticipate=this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');var tmpCallback=typeof fCallback==='function'?fCallback:false;if(!tmpCallback){this.log.warn("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.Name," marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions."));tmpCallback=function tmpCallback(pError){if(pError){_this67.log.error("PictView [".concat(_this67.UUID,"]::[").concat(_this67.Hash,"] ").concat(_this67.options.Name," marshalToViewAsync Auto Callback Error: ").concat(pError),pError);}};}tmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));tmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));tmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));tmpAnticipate.wait(function(pError){if(_this67.pict.LogNoisiness>2){_this67.log.trace("PictView [".concat(_this67.UUID,"]::[").concat(_this67.Hash,"] ").concat(_this67.options.ViewIdentifier," marshalToViewAsync() complete."));}_this67.lastMarshalToViewTimestamp=_this67.pict.log.getTimeStamp();return tmpCallback(pError);});}/**
	 * Lifecycle hook that triggers after data is marshaled into the view.
	 */},{key:"onAfterMarshalToView",value:function onAfterMarshalToView(){if(this.pict.LogNoisiness>3){this.log.trace("PictView [".concat(this.UUID,"]::[").concat(this.Hash,"] ").concat(this.options.ViewIdentifier," onAfterMarshalToView:"));}return true;}/**
	 * Lifecycle hook that triggers after data is marshaled into the view (async flow).
	 *
	 * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.
	 */},{key:"onAfterMarshalToViewAsync",value:function onAfterMarshalToViewAsync(fCallback){this.onAfterMarshalToView();return fCallback();}/** @return {boolean} - True if the object is a PictView. */},{key:"isPictView",get:function get(){return true;}}]);}(libFableServiceBase);module.exports=PictView;},{"../package.json":142,"fable-serviceproviderbase":59}],144:[function(require,module,exports){/**
* Precedent Meta-Templating
*
* @license     MIT
*
* @author      Steven Velozo <steven@velozo.com>
*
* @description Process text streams, parsing out meta-template expressions.
*/var libWordTree=require("./WordTree.js");var libStringParser=require("./StringParser.js");var Precedent=/*#__PURE__*/function(){/**
	 * Precedent Constructor
	 */function Precedent(){_classCallCheck2(this,Precedent);this.WordTree=new libWordTree();this.StringParser=new libStringParser();this.ParseTree=this.WordTree.ParseTree;}/**
	 * Add a Pattern to the Parse Tree
	 * @method addPattern
	 * @param {Object} pTree - A node on the parse tree to push the characters into
	 * @param {string} pPattern - The string to add to the tree
	 * @param {number} pIndex - callback function
	 * @return {bool} True if adding the pattern was successful
	 */return _createClass2(Precedent,[{key:"addPattern",value:function addPattern(pPatternStart,pPatternEnd,pParser){return this.WordTree.addPattern(pPatternStart,pPatternEnd,pParser);}/**
	 * Parse a string with the existing parse tree
	 * @method parseString
	 * @param {string} pString - The string to parse
	 * @param {object} pData - Data to pass in as the second argument
	 * @return {string} The result from the parser
	 */},{key:"parseString",value:function parseString(pString,pData){return this.StringParser.parseString(pString,this.ParseTree,pData);}}]);}();module.exports=Precedent;},{"./StringParser.js":145,"./WordTree.js":146}],145:[function(require,module,exports){/**
* String Parser
* @author      Steven Velozo <steven@velozo.com>
* @description Parse a string, properly processing each matched token in the word tree.
*/var StringParser=/*#__PURE__*/function(){/**
	 * StringParser Constructor
	 */function StringParser(){_classCallCheck2(this,StringParser);}/**
	 * Create a fresh parsing state object to work with.
	 * @method newParserState
	 * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)
	 * @return {Object} A new parser state object for running a character parser on
	 * @private
	 */return _createClass2(StringParser,[{key:"newParserState",value:function newParserState(pParseTree){return{ParseTree:pParseTree,Asynchronous:false,Output:'',OutputBuffer:'',Pattern:{},PatternMatch:false,PatternMatchEnd:false};}/**
	 * Append a character to the output buffer in the parser state.
	 * This output buffer is used when a potential match is being explored, or a match is being explored.
	 * @method appendOutputBuffer
	 * @param {string} pCharacter - The character to append
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"appendOutputBuffer",value:function appendOutputBuffer(pCharacter,pParserState){pParserState.OutputBuffer+=pCharacter;}/**
	 * Flush the output buffer to the output and clear it.
	 * @method flushOutputBuffer
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"flushOutputBuffer",value:function flushOutputBuffer(pParserState){pParserState.Output+=pParserState.OutputBuffer;pParserState.OutputBuffer='';}},{key:"resetOutputBuffer",value:function resetOutputBuffer(pParserState){// Flush the output buffer.
this.flushOutputBuffer(pParserState);// End pattern mode
pParserState.Pattern=false;pParserState.PatternStartNode=false;pParserState.StartPatternMatchComplete=false;pParserState.EndPatternMatchBegan=false;pParserState.PatternMatch=false;return true;}/**
	 * Parse a character in the buffer.
	 * @method parseCharacter
	 * @param {string} pCharacter - The character to append
	 * @param {Object} pParserState - The state object for the current parsing task
	 * @private
	 */},{key:"parseCharacter",value:function parseCharacter(pCharacter,pParserState,pData){// If we are already in a pattern match traversal
if(pParserState.PatternMatch){// If the pattern is still matching the start and we haven't passed the buffer
if(!pParserState.StartPatternMatchComplete&&pParserState.Pattern.hasOwnProperty(pCharacter)){pParserState.Pattern=pParserState.Pattern[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else if(pParserState.EndPatternMatchBegan){if(pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter)){// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// Flush the output buffer.
this.appendOutputBuffer(pCharacter,pParserState);// If this last character is the end of the pattern, parse it.
if(pParserState.Pattern.hasOwnProperty('Parse')){// Run the function
pParserState.OutputBuffer=pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData);return this.resetOutputBuffer(pParserState);}}else if(pParserState.PatternStartNode.PatternEnd.hasOwnProperty(pCharacter)){// We broke out of the end -- see if this is a new start of the end.
pParserState.Pattern=pParserState.PatternStartNode.PatternEnd[pCharacter];this.appendOutputBuffer(pCharacter,pParserState);}else{pParserState.EndPatternMatchBegan=false;this.appendOutputBuffer(pCharacter,pParserState);}}else if(pParserState.Pattern.hasOwnProperty('PatternEnd')){if(!pParserState.StartPatternMatchComplete){pParserState.StartPatternMatchComplete=true;pParserState.PatternStartNode=pParserState.Pattern;}this.appendOutputBuffer(pCharacter,pParserState);if(pParserState.Pattern.PatternEnd.hasOwnProperty(pCharacter)){// This is the first character of the end pattern.
pParserState.EndPatternMatchBegan=true;// This leaf has a PatternEnd tree, so we will wait until that end is met.
pParserState.Pattern=pParserState.Pattern.PatternEnd[pCharacter];// If this last character is the end of the pattern, parse it.
if(pParserState.Pattern.hasOwnProperty('Parse')){// Run the t*mplate function
pParserState.OutputBuffer=pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStartString.length,pParserState.OutputBuffer.length-(pParserState.Pattern.PatternStartString.length+pParserState.Pattern.PatternEndString.length)),pData);return this.resetOutputBuffer(pParserState);}}}else{// We are in a pattern start but didn't match one; reset and start trying again from this character.
this.resetOutputBuffer(pParserState);}}// If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....
if(!pParserState.PatternMatch){// This may be the start of a new pattern....
if(pParserState.ParseTree.hasOwnProperty(pCharacter)){// ... assign the root node as the matched node.
this.resetOutputBuffer(pParserState);this.appendOutputBuffer(pCharacter,pParserState);pParserState.Pattern=pParserState.ParseTree[pCharacter];pParserState.PatternMatch=true;return true;}else{this.appendOutputBuffer(pCharacter,pParserState);}}return false;}/**
	 * Parse a string for matches, and process any template segments that occur.
	 * @method parseString
	 * @param {string} pString - The string to parse.
	 * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)
	 * @param {Object} pData - The data to pass to the function as a second parameter
	 */},{key:"parseString",value:function parseString(pString,pParseTree,pData){var tmpParserState=this.newParserState(pParseTree);for(var i=0;i<pString.length;i++){this.parseCharacter(pString[i],tmpParserState,pData);}this.flushOutputBuffer(tmpParserState);return tmpParserState.Output;}}]);}();module.exports=StringParser;},{}],146:[function(require,module,exports){/**
* Word Tree
* @author      Steven Velozo <steven@velozo.com>
* @description Create a tree (directed graph) of Javascript objects, one character per object.
*/var WordTree=/*#__PURE__*/function(){/**
	 * WordTree Constructor
	 */function WordTree(){_classCallCheck2(this,WordTree);this.ParseTree={};}/**
	 * Add a child character to a Parse Tree node
	 * @method addChild
	 * @param {Object} pTree - A parse tree to push the characters into
	 * @param {string} pPattern - The string to add to the tree
	 * @returns {Object} The resulting leaf node that was added (or found)
	 * @private
	 */return _createClass2(WordTree,[{key:"addChild",value:function addChild(pTree,pPattern){if(!pTree.hasOwnProperty(pPattern)){pTree[pPattern]={};}return pTree[pPattern];}/**
	 * Add a child character to a Parse Tree PatternEnd subtree
	 * @method addChild
	 * @param {Object} pTree - A parse tree to push the characters into
	 * @param {string} pPattern - The string to add to the tree
	 * @returns {Object} The resulting leaf node that was added (or found)
	 * @private
	 */},{key:"addEndChild",value:function addEndChild(pTree,pPattern){if(!pTree.hasOwnProperty('PatternEnd')){pTree.PatternEnd={};}pTree.PatternEnd[pPattern]={};return pTree.PatternEnd[pPattern];}/** Add a Pattern to the Parse Tree
	 * @method addPattern
	 * @param {Object} pPatternStart - The starting string for the pattern (e.g. "${")
	 * @param {string} pPatternEnd - The ending string for the pattern (e.g. "}")
	 * @param {function} fParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.
	 * @return {bool} True if adding the pattern was successful
	 */},{key:"addPattern",value:function addPattern(pPatternStart,pPatternEnd,fParser){if(pPatternStart.length<1){return false;}if(typeof pPatternEnd==='string'&&pPatternEnd.length<1){return false;}var tmpLeaf=this.ParseTree;// Add the tree of leaves iteratively
for(var i=0;i<pPatternStart.length;i++){tmpLeaf=this.addChild(tmpLeaf,pPatternStart[i],i);}if(!tmpLeaf.hasOwnProperty('PatternEnd')){tmpLeaf.PatternEnd={};}var tmpPatternEnd=typeof pPatternEnd==='string'?pPatternEnd:pPatternStart;for(var _i55=0;_i55<tmpPatternEnd.length;_i55++){tmpLeaf=this.addEndChild(tmpLeaf,tmpPatternEnd[_i55],_i55);}tmpLeaf.PatternStartString=pPatternStart;tmpLeaf.PatternEndString=tmpPatternEnd;tmpLeaf.Parse=typeof fParser==='function'?fParser:typeof fParser==='string'?function(){return fParser;}:function(pData){return pData;};return true;}}]);}();module.exports=WordTree;},{}],147:[function(require,module,exports){// shim for using process in browser
var process=module.exports={};// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations
return setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined
if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations
return clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined
if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects
function Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues
process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],148:[function(require,module,exports){(function(global){(function(){/*! https://mths.be/punycode v1.4.1 by @mathias */;(function(root){/** Detect free variables */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;var freeModule=_typeof(module)=='object'&&module&&!module.nodeType&&module;var freeGlobal=_typeof(global)=='object'&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal||freeGlobal.self===freeGlobal){root=freeGlobal;}/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */var punycode,/** Highest positive signed 32-bit float value */maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80
delimiter='-',// '\x2D'
/** Regular expressions */regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */errors={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},/** Convenience shortcuts */baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,/** Temporary variable */key;/*--------------------------------------------------------------------------*//**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function error(type){throw new RangeError(errors[type]);}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function map(array,fn){var length=array.length;var result=[];while(length--){result[length]=fn(array[length]);}return result;}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function mapDomain(string,fn){var parts=string.split('@');var result='';if(parts.length>1){// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result=parts[0]+'@';string=parts[1];}// Avoid `split(regex)` for IE8 compatibility. See #17.
string=string.replace(regexSeparators,'\x2E');var labels=string.split('.');var encoded=map(labels,fn).join('.');return result+encoded;}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function ucs2decode(string){var output=[],counter=0,length=string.length,value,extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// high surrogate, and there is a next character
extra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// low surrogate
output.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else{// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value);counter--;}}else{output.push(value);}}return output;}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function ucs2encode(array){return map(array,function(value){var output='';if(value>0xFFFF){value-=0x10000;output+=stringFromCharCode(value>>>10&0x3FF|0xD800);value=0xDC00|value&0x3FF;}output+=stringFromCharCode(value);return output;}).join('');}/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */function basicToDigit(codePoint){if(codePoint-48<10){return codePoint-22;}if(codePoint-65<26){return codePoint-65;}if(codePoint-97<26){return codePoint-97;}return base;}/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */function digitToBasic(digit,flag){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26)-((flag!=0)<<5);}/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor(delta/damp):delta>>1;delta+=floor(delta/numPoints);for/* no initialization */(;delta>baseMinusTMin*tMax>>1;k+=base){delta=floor(delta/baseMinusTMin);}return floor(k+(baseMinusTMin+1)*delta/(delta+skew));}/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */function decode(input){// Don't use UCS-2
var output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,/** Cached calculation results */baseMinusT;// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
basic=input.lastIndexOf(delimiter);if(basic<0){basic=0;}for(j=0;j<basic;++j){// if it's not a basic code point
if(input.charCodeAt(j)>=0x80){error('not-basic');}output.push(input.charCodeAt(j));}// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for/* no final expression */(index=basic>0?basic+1:0;index<inputLength;){// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for/* no condition */(oldi=i,w=1,k=base;;k+=base){if(index>=inputLength){error('invalid-input');}digit=basicToDigit(input.charCodeAt(index++));if(digit>=base||digit>floor((maxInt-i)/w)){error('overflow');}i+=digit*w;t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(digit<t){break;}baseMinusT=base-t;if(w>floor(maxInt/baseMinusT)){error('overflow');}w*=baseMinusT;}out=output.length+1;bias=adapt(i-oldi,out,oldi==0);// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
if(floor(i/out)>maxInt-n){error('overflow');}n+=floor(i/out);i%=out;// Insert `n` at position `i` of the output
output.splice(i++,0,n);}return ucs2encode(output);}/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],/** `inputLength` will hold the number of code points in `input`. */inputLength,/** Cached calculation results */handledCPCountPlusOne,baseMinusT,qMinusT;// Convert the input in UCS-2 to Unicode
input=ucs2decode(input);// Cache the length
inputLength=input.length;// Initialize the state
n=initialN;delta=0;bias=initialBias;// Handle the basic code points
for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<0x80){output.push(stringFromCharCode(currentValue));}}handledCPCount=basicLength=output.length;// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if(basicLength){output.push(delimiter);}// Main encoding loop:
while(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next
// larger one:
for(m=maxInt,j=0;j<inputLength;++j){currentValue=input[j];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
handledCPCountPlusOne=handledCPCount+1;if(m-n>floor((maxInt-delta)/handledCPCountPlusOne)){error('overflow');}delta+=(m-n)*handledCPCountPlusOne;n=m;for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<n&&++delta>maxInt){error('overflow');}if(currentValue==n){// Represent delta as a generalized variable-length integer
for/* no condition */(q=delta,k=base;;k+=base){t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(q<t){break;}qMinusT=q-t;baseMinusT=base-t;output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));q=floor(qMinusT/baseMinusT);}output.push(stringFromCharCode(digitToBasic(q,0)));bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');}/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string;});}/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string)?'xn--'+encode(string):string;});}/*--------------------------------------------------------------------------*//** Define the public API */punycode={/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */'version':'1.4.1',/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */'ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};/** Expose `punycode` */// Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(typeof define=='function'&&_typeof(define.amd)=='object'&&define.amd){define('punycode',function(){return punycode;});}else if(freeExports&&freeModule){if(module.exports==freeExports){// in Node.js, io.js, or RingoJS v0.8.0+
freeModule.exports=punycode;}else{// in Narwhal or RingoJS v0.7.0-
for(key in punycode){punycode.hasOwnProperty(key)&&(freeExports[key]=punycode[key]);}}}else{// in Rhino or a web browser
root.punycode=punycode;}})(this);}).call(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],149:[function(require,module,exports){'use strict';var replace=String.prototype.replace;var percentTwenties=/%20/g;var Format={RFC1738:'RFC1738',RFC3986:'RFC3986'};module.exports={'default':Format.RFC3986,formatters:{RFC1738:function RFC1738(value){return replace.call(value,percentTwenties,'+');},RFC3986:function RFC3986(value){return String(value);}},RFC1738:Format.RFC1738,RFC3986:Format.RFC3986};},{}],150:[function(require,module,exports){'use strict';var stringify=require('./stringify');var parse=require('./parse');var formats=require('./formats');module.exports={formats:formats,parse:parse,stringify:stringify};},{"./formats":149,"./parse":151,"./stringify":152}],151:[function(require,module,exports){'use strict';var utils=require('./utils');var has=Object.prototype.hasOwnProperty;var isArray=Array.isArray;var defaults={allowDots:false,allowEmptyArrays:false,allowPrototypes:false,allowSparse:false,arrayLimit:20,charset:'utf-8',charsetSentinel:false,comma:false,decodeDotInKeys:false,decoder:utils.decode,delimiter:'&',depth:5,duplicates:'combine',ignoreQueryPrefix:false,interpretNumericEntities:false,parameterLimit:1000,parseArrays:true,plainObjects:false,strictDepth:false,strictNullHandling:false};var interpretNumericEntities=function interpretNumericEntities(str){return str.replace(/&#(\d+);/g,function($0,numberStr){return String.fromCharCode(parseInt(numberStr,10));});};var parseArrayValue=function parseArrayValue(val,options){if(val&&typeof val==='string'&&options.comma&&val.indexOf(',')>-1){return val.split(',');}return val;};// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel='utf8=%26%2310003%3B';// encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel='utf8=%E2%9C%93';// encodeURIComponent('')
var parseValues=function parseQueryStringValues(str,options){var obj={__proto__:null};var cleanStr=options.ignoreQueryPrefix?str.replace(/^\?/,''):str;cleanStr=cleanStr.replace(/%5B/gi,'[').replace(/%5D/gi,']');var limit=options.parameterLimit===Infinity?undefined:options.parameterLimit;var parts=cleanStr.split(options.delimiter,limit);var skipIndex=-1;// Keep track of where the utf8 sentinel was found
var i;var charset=options.charset;if(options.charsetSentinel){for(i=0;i<parts.length;++i){if(parts[i].indexOf('utf8=')===0){if(parts[i]===charsetSentinel){charset='utf-8';}else if(parts[i]===isoSentinel){charset='iso-8859-1';}skipIndex=i;i=parts.length;// The eslint settings do not allow break;
}}}for(i=0;i<parts.length;++i){if(i===skipIndex){continue;}var part=parts[i];var bracketEqualsPos=part.indexOf(']=');var pos=bracketEqualsPos===-1?part.indexOf('='):bracketEqualsPos+1;var key;var val;if(pos===-1){key=options.decoder(part,defaults.decoder,charset,'key');val=options.strictNullHandling?null:'';}else{key=options.decoder(part.slice(0,pos),defaults.decoder,charset,'key');val=utils.maybeMap(parseArrayValue(part.slice(pos+1),options),function(encodedVal){return options.decoder(encodedVal,defaults.decoder,charset,'value');});}if(val&&options.interpretNumericEntities&&charset==='iso-8859-1'){val=interpretNumericEntities(String(val));}if(part.indexOf('[]=')>-1){val=isArray(val)?[val]:val;}var existing=has.call(obj,key);if(existing&&options.duplicates==='combine'){obj[key]=utils.combine(obj[key],val);}else if(!existing||options.duplicates==='last'){obj[key]=val;}}return obj;};var parseObject=function parseObject(chain,val,options,valuesParsed){var leaf=valuesParsed?val:parseArrayValue(val,options);for(var i=chain.length-1;i>=0;--i){var obj;var root=chain[i];if(root==='[]'&&options.parseArrays){obj=options.allowEmptyArrays&&(leaf===''||options.strictNullHandling&&leaf===null)?[]:[].concat(leaf);}else{obj=options.plainObjects?{__proto__:null}:{};var cleanRoot=root.charAt(0)==='['&&root.charAt(root.length-1)===']'?root.slice(1,-1):root;var decodedRoot=options.decodeDotInKeys?cleanRoot.replace(/%2E/g,'.'):cleanRoot;var index=parseInt(decodedRoot,10);if(!options.parseArrays&&decodedRoot===''){obj={0:leaf};}else if(!isNaN(index)&&root!==decodedRoot&&String(index)===decodedRoot&&index>=0&&options.parseArrays&&index<=options.arrayLimit){obj=[];obj[index]=leaf;}else if(decodedRoot!=='__proto__'){obj[decodedRoot]=leaf;}}leaf=obj;}return leaf;};var parseKeys=function parseQueryStringKeys(givenKey,val,options,valuesParsed){if(!givenKey){return;}// Transform dot notation to bracket notation
var key=options.allowDots?givenKey.replace(/\.([^.[]+)/g,'[$1]'):givenKey;// The regex chunks
var brackets=/(\[[^[\]]*])/;var child=/(\[[^[\]]*])/g;// Get the parent
var segment=options.depth>0&&brackets.exec(key);var parent=segment?key.slice(0,segment.index):key;// Stash the parent if it exists
var keys=[];if(parent){// If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
if(!options.plainObjects&&has.call(Object.prototype,parent)){if(!options.allowPrototypes){return;}}keys.push(parent);}// Loop through children appending to the array until we hit depth
var i=0;while(options.depth>0&&(segment=child.exec(key))!==null&&i<options.depth){i+=1;if(!options.plainObjects&&has.call(Object.prototype,segment[1].slice(1,-1))){if(!options.allowPrototypes){return;}}keys.push(segment[1]);}// If there's a remainder, check strictDepth option for throw, else just add whatever is left
if(segment){if(options.strictDepth===true){throw new RangeError('Input depth exceeded depth option of '+options.depth+' and strictDepth is true');}keys.push('['+key.slice(segment.index)+']');}return parseObject(keys,val,options,valuesParsed);};var normalizeParseOptions=function normalizeParseOptions(opts){if(!opts){return defaults;}if(typeof opts.allowEmptyArrays!=='undefined'&&typeof opts.allowEmptyArrays!=='boolean'){throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');}if(typeof opts.decodeDotInKeys!=='undefined'&&typeof opts.decodeDotInKeys!=='boolean'){throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');}if(opts.decoder!==null&&typeof opts.decoder!=='undefined'&&typeof opts.decoder!=='function'){throw new TypeError('Decoder has to be a function.');}if(typeof opts.charset!=='undefined'&&opts.charset!=='utf-8'&&opts.charset!=='iso-8859-1'){throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');}var charset=typeof opts.charset==='undefined'?defaults.charset:opts.charset;var duplicates=typeof opts.duplicates==='undefined'?defaults.duplicates:opts.duplicates;if(duplicates!=='combine'&&duplicates!=='first'&&duplicates!=='last'){throw new TypeError('The duplicates option must be either combine, first, or last');}var allowDots=typeof opts.allowDots==='undefined'?opts.decodeDotInKeys===true?true:defaults.allowDots:!!opts.allowDots;return{allowDots:allowDots,allowEmptyArrays:typeof opts.allowEmptyArrays==='boolean'?!!opts.allowEmptyArrays:defaults.allowEmptyArrays,allowPrototypes:typeof opts.allowPrototypes==='boolean'?opts.allowPrototypes:defaults.allowPrototypes,allowSparse:typeof opts.allowSparse==='boolean'?opts.allowSparse:defaults.allowSparse,arrayLimit:typeof opts.arrayLimit==='number'?opts.arrayLimit:defaults.arrayLimit,charset:charset,charsetSentinel:typeof opts.charsetSentinel==='boolean'?opts.charsetSentinel:defaults.charsetSentinel,comma:typeof opts.comma==='boolean'?opts.comma:defaults.comma,decodeDotInKeys:typeof opts.decodeDotInKeys==='boolean'?opts.decodeDotInKeys:defaults.decodeDotInKeys,decoder:typeof opts.decoder==='function'?opts.decoder:defaults.decoder,delimiter:typeof opts.delimiter==='string'||utils.isRegExp(opts.delimiter)?opts.delimiter:defaults.delimiter,// eslint-disable-next-line no-implicit-coercion, no-extra-parens
depth:typeof opts.depth==='number'||opts.depth===false?+opts.depth:defaults.depth,duplicates:duplicates,ignoreQueryPrefix:opts.ignoreQueryPrefix===true,interpretNumericEntities:typeof opts.interpretNumericEntities==='boolean'?opts.interpretNumericEntities:defaults.interpretNumericEntities,parameterLimit:typeof opts.parameterLimit==='number'?opts.parameterLimit:defaults.parameterLimit,parseArrays:opts.parseArrays!==false,plainObjects:typeof opts.plainObjects==='boolean'?opts.plainObjects:defaults.plainObjects,strictDepth:typeof opts.strictDepth==='boolean'?!!opts.strictDepth:defaults.strictDepth,strictNullHandling:typeof opts.strictNullHandling==='boolean'?opts.strictNullHandling:defaults.strictNullHandling};};module.exports=function(str,opts){var options=normalizeParseOptions(opts);if(str===''||str===null||typeof str==='undefined'){return options.plainObjects?{__proto__:null}:{};}var tempObj=typeof str==='string'?parseValues(str,options):str;var obj=options.plainObjects?{__proto__:null}:{};// Iterate over the keys and setup the new object
var keys=Object.keys(tempObj);for(var i=0;i<keys.length;++i){var key=keys[i];var newObj=parseKeys(key,tempObj[key],options,typeof str==='string');obj=utils.merge(obj,newObj,options);}if(options.allowSparse===true){return obj;}return utils.compact(obj);};},{"./utils":153}],152:[function(require,module,exports){'use strict';var getSideChannel=require('side-channel');var utils=require('./utils');var formats=require('./formats');var has=Object.prototype.hasOwnProperty;var arrayPrefixGenerators={brackets:function brackets(prefix){return prefix+'[]';},comma:'comma',indices:function indices(prefix,key){return prefix+'['+key+']';},repeat:function repeat(prefix){return prefix;}};var isArray=Array.isArray;var push=Array.prototype.push;var pushToArray=function pushToArray(arr,valueOrArray){push.apply(arr,isArray(valueOrArray)?valueOrArray:[valueOrArray]);};var toISO=Date.prototype.toISOString;var defaultFormat=formats['default'];var defaults={addQueryPrefix:false,allowDots:false,allowEmptyArrays:false,arrayFormat:'indices',charset:'utf-8',charsetSentinel:false,commaRoundTrip:false,delimiter:'&',encode:true,encodeDotInKeys:false,encoder:utils.encode,encodeValuesOnly:false,filter:void undefined,format:defaultFormat,formatter:formats.formatters[defaultFormat],// deprecated
indices:false,serializeDate:function serializeDate(date){return toISO.call(date);},skipNulls:false,strictNullHandling:false};var isNonNullishPrimitive=function isNonNullishPrimitive(v){return typeof v==='string'||typeof v==='number'||typeof v==='boolean'||_typeof(v)==='symbol'||typeof v==='bigint';};var sentinel={};var stringify=function stringify(object,prefix,generateArrayPrefix,commaRoundTrip,allowEmptyArrays,strictNullHandling,skipNulls,encodeDotInKeys,encoder,filter,sort,allowDots,serializeDate,format,formatter,encodeValuesOnly,charset,sideChannel){var obj=object;var tmpSc=sideChannel;var step=0;var findFlag=false;while((tmpSc=tmpSc.get(sentinel))!==void undefined&&!findFlag){// Where object last appeared in the ref tree
var pos=tmpSc.get(object);step+=1;if(typeof pos!=='undefined'){if(pos===step){throw new RangeError('Cyclic object value');}else{findFlag=true;// Break while
}}if(typeof tmpSc.get(sentinel)==='undefined'){step=0;}}if(typeof filter==='function'){obj=filter(prefix,obj);}else if(obj instanceof Date){obj=serializeDate(obj);}else if(generateArrayPrefix==='comma'&&isArray(obj)){obj=utils.maybeMap(obj,function(value){if(value instanceof Date){return serializeDate(value);}return value;});}if(obj===null){if(strictNullHandling){return encoder&&!encodeValuesOnly?encoder(prefix,defaults.encoder,charset,'key',format):prefix;}obj='';}if(isNonNullishPrimitive(obj)||utils.isBuffer(obj)){if(encoder){var keyValue=encodeValuesOnly?prefix:encoder(prefix,defaults.encoder,charset,'key',format);return[formatter(keyValue)+'='+formatter(encoder(obj,defaults.encoder,charset,'value',format))];}return[formatter(prefix)+'='+formatter(String(obj))];}var values=[];if(typeof obj==='undefined'){return values;}var objKeys;if(generateArrayPrefix==='comma'&&isArray(obj)){// we need to join elements in
if(encodeValuesOnly&&encoder){obj=utils.maybeMap(obj,encoder);}objKeys=[{value:obj.length>0?obj.join(',')||null:void undefined}];}else if(isArray(filter)){objKeys=filter;}else{var keys=Object.keys(obj);objKeys=sort?keys.sort(sort):keys;}var encodedPrefix=encodeDotInKeys?String(prefix).replace(/\./g,'%2E'):String(prefix);var adjustedPrefix=commaRoundTrip&&isArray(obj)&&obj.length===1?encodedPrefix+'[]':encodedPrefix;if(allowEmptyArrays&&isArray(obj)&&obj.length===0){return adjustedPrefix+'[]';}for(var j=0;j<objKeys.length;++j){var key=objKeys[j];var value=_typeof(key)==='object'&&key&&typeof key.value!=='undefined'?key.value:obj[key];if(skipNulls&&value===null){continue;}var encodedKey=allowDots&&encodeDotInKeys?String(key).replace(/\./g,'%2E'):String(key);var keyPrefix=isArray(obj)?typeof generateArrayPrefix==='function'?generateArrayPrefix(adjustedPrefix,encodedKey):adjustedPrefix:adjustedPrefix+(allowDots?'.'+encodedKey:'['+encodedKey+']');sideChannel.set(object,step);var valueSideChannel=getSideChannel();valueSideChannel.set(sentinel,sideChannel);pushToArray(values,stringify(value,keyPrefix,generateArrayPrefix,commaRoundTrip,allowEmptyArrays,strictNullHandling,skipNulls,encodeDotInKeys,generateArrayPrefix==='comma'&&encodeValuesOnly&&isArray(obj)?null:encoder,filter,sort,allowDots,serializeDate,format,formatter,encodeValuesOnly,charset,valueSideChannel));}return values;};var normalizeStringifyOptions=function normalizeStringifyOptions(opts){if(!opts){return defaults;}if(typeof opts.allowEmptyArrays!=='undefined'&&typeof opts.allowEmptyArrays!=='boolean'){throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');}if(typeof opts.encodeDotInKeys!=='undefined'&&typeof opts.encodeDotInKeys!=='boolean'){throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');}if(opts.encoder!==null&&typeof opts.encoder!=='undefined'&&typeof opts.encoder!=='function'){throw new TypeError('Encoder has to be a function.');}var charset=opts.charset||defaults.charset;if(typeof opts.charset!=='undefined'&&opts.charset!=='utf-8'&&opts.charset!=='iso-8859-1'){throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');}var format=formats['default'];if(typeof opts.format!=='undefined'){if(!has.call(formats.formatters,opts.format)){throw new TypeError('Unknown format option provided.');}format=opts.format;}var formatter=formats.formatters[format];var filter=defaults.filter;if(typeof opts.filter==='function'||isArray(opts.filter)){filter=opts.filter;}var arrayFormat;if(opts.arrayFormat in arrayPrefixGenerators){arrayFormat=opts.arrayFormat;}else if('indices'in opts){arrayFormat=opts.indices?'indices':'repeat';}else{arrayFormat=defaults.arrayFormat;}if('commaRoundTrip'in opts&&typeof opts.commaRoundTrip!=='boolean'){throw new TypeError('`commaRoundTrip` must be a boolean, or absent');}var allowDots=typeof opts.allowDots==='undefined'?opts.encodeDotInKeys===true?true:defaults.allowDots:!!opts.allowDots;return{addQueryPrefix:typeof opts.addQueryPrefix==='boolean'?opts.addQueryPrefix:defaults.addQueryPrefix,allowDots:allowDots,allowEmptyArrays:typeof opts.allowEmptyArrays==='boolean'?!!opts.allowEmptyArrays:defaults.allowEmptyArrays,arrayFormat:arrayFormat,charset:charset,charsetSentinel:typeof opts.charsetSentinel==='boolean'?opts.charsetSentinel:defaults.charsetSentinel,commaRoundTrip:!!opts.commaRoundTrip,delimiter:typeof opts.delimiter==='undefined'?defaults.delimiter:opts.delimiter,encode:typeof opts.encode==='boolean'?opts.encode:defaults.encode,encodeDotInKeys:typeof opts.encodeDotInKeys==='boolean'?opts.encodeDotInKeys:defaults.encodeDotInKeys,encoder:typeof opts.encoder==='function'?opts.encoder:defaults.encoder,encodeValuesOnly:typeof opts.encodeValuesOnly==='boolean'?opts.encodeValuesOnly:defaults.encodeValuesOnly,filter:filter,format:format,formatter:formatter,serializeDate:typeof opts.serializeDate==='function'?opts.serializeDate:defaults.serializeDate,skipNulls:typeof opts.skipNulls==='boolean'?opts.skipNulls:defaults.skipNulls,sort:typeof opts.sort==='function'?opts.sort:null,strictNullHandling:typeof opts.strictNullHandling==='boolean'?opts.strictNullHandling:defaults.strictNullHandling};};module.exports=function(object,opts){var obj=object;var options=normalizeStringifyOptions(opts);var objKeys;var filter;if(typeof options.filter==='function'){filter=options.filter;obj=filter('',obj);}else if(isArray(options.filter)){filter=options.filter;objKeys=filter;}var keys=[];if(_typeof(obj)!=='object'||obj===null){return'';}var generateArrayPrefix=arrayPrefixGenerators[options.arrayFormat];var commaRoundTrip=generateArrayPrefix==='comma'&&options.commaRoundTrip;if(!objKeys){objKeys=Object.keys(obj);}if(options.sort){objKeys.sort(options.sort);}var sideChannel=getSideChannel();for(var i=0;i<objKeys.length;++i){var key=objKeys[i];var value=obj[key];if(options.skipNulls&&value===null){continue;}pushToArray(keys,stringify(value,key,generateArrayPrefix,commaRoundTrip,options.allowEmptyArrays,options.strictNullHandling,options.skipNulls,options.encodeDotInKeys,options.encode?options.encoder:null,options.filter,options.sort,options.allowDots,options.serializeDate,options.format,options.formatter,options.encodeValuesOnly,options.charset,sideChannel));}var joined=keys.join(options.delimiter);var prefix=options.addQueryPrefix===true?'?':'';if(options.charsetSentinel){if(options.charset==='iso-8859-1'){// encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
prefix+='utf8=%26%2310003%3B&';}else{// encodeURIComponent('')
prefix+='utf8=%E2%9C%93&';}}return joined.length>0?prefix+joined:'';};},{"./formats":149,"./utils":153,"side-channel":161}],153:[function(require,module,exports){'use strict';var formats=require('./formats');var has=Object.prototype.hasOwnProperty;var isArray=Array.isArray;var hexTable=function(){var array=[];for(var i=0;i<256;++i){array.push('%'+((i<16?'0':'')+i.toString(16)).toUpperCase());}return array;}();var compactQueue=function compactQueue(queue){while(queue.length>1){var item=queue.pop();var obj=item.obj[item.prop];if(isArray(obj)){var compacted=[];for(var j=0;j<obj.length;++j){if(typeof obj[j]!=='undefined'){compacted.push(obj[j]);}}item.obj[item.prop]=compacted;}}};var arrayToObject=function arrayToObject(source,options){var obj=options&&options.plainObjects?{__proto__:null}:{};for(var i=0;i<source.length;++i){if(typeof source[i]!=='undefined'){obj[i]=source[i];}}return obj;};var merge=function merge(target,source,options){/* eslint no-param-reassign: 0 */if(!source){return target;}if(_typeof(source)!=='object'&&typeof source!=='function'){if(isArray(target)){target.push(source);}else if(target&&_typeof(target)==='object'){if(options&&(options.plainObjects||options.allowPrototypes)||!has.call(Object.prototype,source)){target[source]=true;}}else{return[target,source];}return target;}if(!target||_typeof(target)!=='object'){return[target].concat(source);}var mergeTarget=target;if(isArray(target)&&!isArray(source)){mergeTarget=arrayToObject(target,options);}if(isArray(target)&&isArray(source)){source.forEach(function(item,i){if(has.call(target,i)){var targetItem=target[i];if(targetItem&&_typeof(targetItem)==='object'&&item&&_typeof(item)==='object'){target[i]=merge(targetItem,item,options);}else{target.push(item);}}else{target[i]=item;}});return target;}return Object.keys(source).reduce(function(acc,key){var value=source[key];if(has.call(acc,key)){acc[key]=merge(acc[key],value,options);}else{acc[key]=value;}return acc;},mergeTarget);};var assign=function assignSingleSource(target,source){return Object.keys(source).reduce(function(acc,key){acc[key]=source[key];return acc;},target);};var decode=function decode(str,defaultDecoder,charset){var strWithoutPlus=str.replace(/\+/g,' ');if(charset==='iso-8859-1'){// unescape never throws, no try...catch needed:
return strWithoutPlus.replace(/%[0-9a-f]{2}/gi,unescape);}// utf-8
try{return decodeURIComponent(strWithoutPlus);}catch(e){return strWithoutPlus;}};var limit=1024;/* eslint operator-linebreak: [2, "before"] */var encode=function encode(str,defaultEncoder,charset,kind,format){// This code was originally written by Brian White (mscdex) for the io.js core querystring library.
// It has been adapted here for stricter adherence to RFC 3986
if(str.length===0){return str;}var string=str;if(_typeof(str)==='symbol'){string=Symbol.prototype.toString.call(str);}else if(typeof str!=='string'){string=String(str);}if(charset==='iso-8859-1'){return escape(string).replace(/%u[0-9a-f]{4}/gi,function($0){return'%26%23'+parseInt($0.slice(2),16)+'%3B';});}var out='';for(var j=0;j<string.length;j+=limit){var segment=string.length>=limit?string.slice(j,j+limit):string;var arr=[];for(var i=0;i<segment.length;++i){var c=segment.charCodeAt(i);if(c===0x2D// -
||c===0x2E// .
||c===0x5F// _
||c===0x7E// ~
||c>=0x30&&c<=0x39// 0-9
||c>=0x41&&c<=0x5A// a-z
||c>=0x61&&c<=0x7A// A-Z
||format===formats.RFC1738&&(c===0x28||c===0x29)// ( )
){arr[arr.length]=segment.charAt(i);continue;}if(c<0x80){arr[arr.length]=hexTable[c];continue;}if(c<0x800){arr[arr.length]=hexTable[0xC0|c>>6]+hexTable[0x80|c&0x3F];continue;}if(c<0xD800||c>=0xE000){arr[arr.length]=hexTable[0xE0|c>>12]+hexTable[0x80|c>>6&0x3F]+hexTable[0x80|c&0x3F];continue;}i+=1;c=0x10000+((c&0x3FF)<<10|segment.charCodeAt(i)&0x3FF);arr[arr.length]=hexTable[0xF0|c>>18]+hexTable[0x80|c>>12&0x3F]+hexTable[0x80|c>>6&0x3F]+hexTable[0x80|c&0x3F];}out+=arr.join('');}return out;};var compact=function compact(value){var queue=[{obj:{o:value},prop:'o'}];var refs=[];for(var i=0;i<queue.length;++i){var item=queue[i];var obj=item.obj[item.prop];var keys=Object.keys(obj);for(var j=0;j<keys.length;++j){var key=keys[j];var val=obj[key];if(_typeof(val)==='object'&&val!==null&&refs.indexOf(val)===-1){queue.push({obj:obj,prop:key});refs.push(val);}}}compactQueue(queue);return value;};var isRegExp=function isRegExp(obj){return Object.prototype.toString.call(obj)==='[object RegExp]';};var isBuffer=function isBuffer(obj){if(!obj||_typeof(obj)!=='object'){return false;}return!!(obj.constructor&&obj.constructor.isBuffer&&obj.constructor.isBuffer(obj));};var combine=function combine(a,b){return[].concat(a,b);};var maybeMap=function maybeMap(val,fn){if(isArray(val)){var mapped=[];for(var i=0;i<val.length;i+=1){mapped.push(fn(val[i]));}return mapped;}return fn(val);};module.exports={arrayToObject:arrayToObject,assign:assign,combine:combine,compact:compact,decode:decode,encode:encode,isBuffer:isBuffer,isRegExp:isRegExp,maybeMap:maybeMap,merge:merge};},{"./formats":149}],154:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}module.exports=function(qs,sep,eq,options){sep=sep||'&';eq=eq||'=';var obj={};if(typeof qs!=='string'||qs.length===0){return obj;}var regexp=/\+/g;qs=qs.split(sep);var maxKeys=1000;if(options&&typeof options.maxKeys==='number'){maxKeys=options.maxKeys;}var len=qs.length;// maxKeys <= 0 means that we should not limit keys count
if(maxKeys>0&&len>maxKeys){len=maxKeys;}for(var i=0;i<len;++i){var x=qs[i].replace(regexp,'%20'),idx=x.indexOf(eq),kstr,vstr,k,v;if(idx>=0){kstr=x.substr(0,idx);vstr=x.substr(idx+1);}else{kstr=x;vstr='';}k=decodeURIComponent(kstr);v=decodeURIComponent(vstr);if(!hasOwnProperty(obj,k)){obj[k]=v;}else if(isArray(obj[k])){obj[k].push(v);}else{obj[k]=[obj[k],v];}}return obj;};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};},{}],155:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var stringifyPrimitive=function stringifyPrimitive(v){switch(_typeof(v)){case'string':return v;case'boolean':return v?'true':'false';case'number':return isFinite(v)?v:'';default:return'';}};module.exports=function(obj,sep,eq,name){sep=sep||'&';eq=eq||'=';if(obj===null){obj=undefined;}if(_typeof(obj)==='object'){return map(objectKeys(obj),function(k){var ks=encodeURIComponent(stringifyPrimitive(k))+eq;if(isArray(obj[k])){return map(obj[k],function(v){return ks+encodeURIComponent(stringifyPrimitive(v));}).join(sep);}else{return ks+encodeURIComponent(stringifyPrimitive(obj[k]));}}).join(sep);}if(!name)return'';return encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj));};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};function map(xs,f){if(xs.map)return xs.map(f);var res=[];for(var i=0;i<xs.length;i++){res.push(f(xs[i],i));}return res;}var objectKeys=Object.keys||function(obj){var res=[];for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))res.push(key);}return res;};},{}],156:[function(require,module,exports){'use strict';exports.decode=exports.parse=require('./decode');exports.encode=exports.stringify=require('./encode');},{"./decode":154,"./encode":155}],157:[function(require,module,exports){/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *//* eslint-disable node/no-deprecated-api */var buffer=require('buffer');var Buffer=buffer.Buffer;// alternative to using Object.keys for old browsers
function copyProps(src,dst){for(var key in src){dst[key]=src[key];}}if(Buffer.from&&Buffer.alloc&&Buffer.allocUnsafe&&Buffer.allocUnsafeSlow){module.exports=buffer;}else{// Copy properties from require('buffer')
copyProps(buffer,exports);exports.Buffer=SafeBuffer;}function SafeBuffer(arg,encodingOrOffset,length){return Buffer(arg,encodingOrOffset,length);}SafeBuffer.prototype=Object.create(Buffer.prototype);// Copy static methods from Buffer
copyProps(Buffer,SafeBuffer);SafeBuffer.from=function(arg,encodingOrOffset,length){if(typeof arg==='number'){throw new TypeError('Argument must not be a number');}return Buffer(arg,encodingOrOffset,length);};SafeBuffer.alloc=function(size,fill,encoding){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}var buf=Buffer(size);if(fill!==undefined){if(typeof encoding==='string'){buf.fill(fill,encoding);}else{buf.fill(fill);}}else{buf.fill(0);}return buf;};SafeBuffer.allocUnsafe=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return Buffer(size);};SafeBuffer.allocUnsafeSlow=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return buffer.SlowBuffer(size);};},{"buffer":20}],158:[function(require,module,exports){'use strict';var inspect=require('object-inspect');var $TypeError=require('es-errors/type');/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*//** @type {import('./list.d.ts').listGetNode} */// eslint-disable-next-line consistent-return
var listGetNode=function listGetNode(list,key,isDelete){/** @type {typeof list | NonNullable<(typeof list)['next']>} */var prev=list;/** @type {(typeof list)['next']} */var curr;// eslint-disable-next-line eqeqeq
for(;(curr=prev.next)!=null;prev=curr){if(curr.key===key){prev.next=curr.next;if(!isDelete){// eslint-disable-next-line no-extra-parens
curr.next=/** @type {NonNullable<typeof list.next>} */list.next;list.next=curr;// eslint-disable-line no-param-reassign
}return curr;}}};/** @type {import('./list.d.ts').listGet} */var listGet=function listGet(objects,key){if(!objects){return void undefined;}var node=listGetNode(objects,key);return node&&node.value;};/** @type {import('./list.d.ts').listSet} */var listSet=function listSet(objects,key,value){var node=listGetNode(objects,key);if(node){node.value=value;}else{// Prepend the new node to the beginning of the list
objects.next=/** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */{// eslint-disable-line no-param-reassign, no-extra-parens
key:key,next:objects.next,value:value};}};/** @type {import('./list.d.ts').listHas} */var listHas=function listHas(objects,key){if(!objects){return false;}return!!listGetNode(objects,key);};/** @type {import('./list.d.ts').listDelete} */// eslint-disable-next-line consistent-return
var listDelete=function listDelete(objects,key){if(objects){return listGetNode(objects,key,true);}};/** @type {import('.')} */module.exports=function getSideChannelList(){/** @typedef {ReturnType<typeof getSideChannelList>} Channel *//** @typedef {Parameters<Channel['get']>[0]} K *//** @typedef {Parameters<Channel['set']>[1]} V *//** @type {import('./list.d.ts').RootNode<V, K> | undefined} */var $o;/** @type {Channel} */var channel={assert:function assert(key){if(!channel.has(key)){throw new $TypeError('Side channel does not contain '+inspect(key));}},'delete':function _delete(key){var root=$o&&$o.next;var deletedNode=listDelete($o,key);if(deletedNode&&root&&root===deletedNode){$o=void undefined;}return!!deletedNode;},get:function get(key){return listGet($o,key);},has:function has(key){return listHas($o,key);},set:function set(key,value){if(!$o){// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
$o={next:void undefined};}// eslint-disable-next-line no-extra-parens
listSet(/** @type {NonNullable<typeof $o>} */$o,key,value);}};// @ts-expect-error TODO: figure out why this is erroring
return channel;};},{"es-errors/type":47,"object-inspect":133}],159:[function(require,module,exports){'use strict';var GetIntrinsic=require('get-intrinsic');var callBound=require('call-bound');var inspect=require('object-inspect');var $TypeError=require('es-errors/type');var $Map=GetIntrinsic('%Map%',true);/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */var $mapGet=callBound('Map.prototype.get',true);/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */var $mapSet=callBound('Map.prototype.set',true);/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */var $mapHas=callBound('Map.prototype.has',true);/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */var $mapDelete=callBound('Map.prototype.delete',true);/** @type {<K, V>(thisArg: Map<K, V>) => number} */var $mapSize=callBound('Map.prototype.size',true);/** @type {import('.')} */module.exports=!!$Map&&/** @type {Exclude<import('.'), false>} */function getSideChannelMap(){/** @typedef {ReturnType<typeof getSideChannelMap>} Channel *//** @typedef {Parameters<Channel['get']>[0]} K *//** @typedef {Parameters<Channel['set']>[1]} V *//** @type {Map<K, V> | undefined} */var $m;/** @type {Channel} */var channel={assert:function assert(key){if(!channel.has(key)){throw new $TypeError('Side channel does not contain '+inspect(key));}},'delete':function _delete(key){if($m){var result=$mapDelete($m,key);if($mapSize($m)===0){$m=void undefined;}return result;}return false;},get:function get(key){// eslint-disable-line consistent-return
if($m){return $mapGet($m,key);}},has:function has(key){if($m){return $mapHas($m,key);}return false;},set:function set(key,value){if(!$m){// @ts-expect-error TS can't handle narrowing a variable inside a closure
$m=new $Map();}$mapSet($m,key,value);}};// @ts-expect-error TODO: figure out why TS is erroring here
return channel;};},{"call-bound":30,"es-errors/type":47,"get-intrinsic":101,"object-inspect":133}],160:[function(require,module,exports){'use strict';var GetIntrinsic=require('get-intrinsic');var callBound=require('call-bound');var inspect=require('object-inspect');var getSideChannelMap=require('side-channel-map');var $TypeError=require('es-errors/type');var $WeakMap=GetIntrinsic('%WeakMap%',true);/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */var $weakMapGet=callBound('WeakMap.prototype.get',true);/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */var $weakMapSet=callBound('WeakMap.prototype.set',true);/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */var $weakMapHas=callBound('WeakMap.prototype.has',true);/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */var $weakMapDelete=callBound('WeakMap.prototype.delete',true);/** @type {import('.')} */module.exports=$WeakMap?/** @type {Exclude<import('.'), false>} */function getSideChannelWeakMap(){/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel *//** @typedef {Parameters<Channel['get']>[0]} K *//** @typedef {Parameters<Channel['set']>[1]} V *//** @type {WeakMap<K & object, V> | undefined} */var $wm;/** @type {Channel | undefined} */var $m;/** @type {Channel} */var channel={assert:function assert(key){if(!channel.has(key)){throw new $TypeError('Side channel does not contain '+inspect(key));}},'delete':function _delete(key){if($WeakMap&&key&&(_typeof(key)==='object'||typeof key==='function')){if($wm){return $weakMapDelete($wm,key);}}else if(getSideChannelMap){if($m){return $m['delete'](key);}}return false;},get:function get(key){if($WeakMap&&key&&(_typeof(key)==='object'||typeof key==='function')){if($wm){return $weakMapGet($wm,key);}}return $m&&$m.get(key);},has:function has(key){if($WeakMap&&key&&(_typeof(key)==='object'||typeof key==='function')){if($wm){return $weakMapHas($wm,key);}}return!!$m&&$m.has(key);},set:function set(key,value){if($WeakMap&&key&&(_typeof(key)==='object'||typeof key==='function')){if(!$wm){$wm=new $WeakMap();}$weakMapSet($wm,key,value);}else if(getSideChannelMap){if(!$m){$m=getSideChannelMap();}// eslint-disable-next-line no-extra-parens
/** @type {NonNullable<typeof $m>} */$m.set(key,value);}}};// @ts-expect-error TODO: figure out why this is erroring
return channel;}:getSideChannelMap;},{"call-bound":30,"es-errors/type":47,"get-intrinsic":101,"object-inspect":133,"side-channel-map":159}],161:[function(require,module,exports){'use strict';var $TypeError=require('es-errors/type');var inspect=require('object-inspect');var getSideChannelList=require('side-channel-list');var getSideChannelMap=require('side-channel-map');var getSideChannelWeakMap=require('side-channel-weakmap');var makeChannel=getSideChannelWeakMap||getSideChannelMap||getSideChannelList;/** @type {import('.')} */module.exports=function getSideChannel(){/** @typedef {ReturnType<typeof getSideChannel>} Channel *//** @type {Channel | undefined} */var $channelData;/** @type {Channel} */var channel={assert:function assert(key){if(!channel.has(key)){throw new $TypeError('Side channel does not contain '+inspect(key));}},'delete':function _delete(key){return!!$channelData&&$channelData['delete'](key);},get:function get(key){return $channelData&&$channelData.get(key);},has:function has(key){return!!$channelData&&$channelData.has(key);},set:function set(key,value){if(!$channelData){$channelData=makeChannel();}$channelData.set(key,value);}};// @ts-expect-error TODO: figure out why this is erroring
return channel;};},{"es-errors/type":47,"object-inspect":133,"side-channel-list":158,"side-channel-map":159,"side-channel-weakmap":160}],162:[function(require,module,exports){(function(Buffer){(function(){/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */module.exports=function(stream,cb){var chunks=[];stream.on('data',function(chunk){chunks.push(chunk);});stream.once('end',function(){if(cb)cb(null,Buffer.concat(chunks));cb=null;});stream.once('error',function(err){if(cb)cb(err);cb=null;});};}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":20}],163:[function(require,module,exports){(function(Buffer){(function(){/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */module.exports=simpleGet;var concat=require('simple-concat');var decompressResponse=require('decompress-response');// excluded from browser build
var http=require('http');var https=require('https');var once=require('once');var querystring=require('querystring');var url=require('url');var isStream=function isStream(o){return o!==null&&_typeof(o)==='object'&&typeof o.pipe==='function';};function simpleGet(opts,cb){opts=Object.assign({maxRedirects:10},typeof opts==='string'?{url:opts}:opts);cb=once(cb);if(opts.url){var _url$parse=url.parse(opts.url),hostname=_url$parse.hostname,port=_url$parse.port,_protocol=_url$parse.protocol,auth=_url$parse.auth,path=_url$parse.path;// eslint-disable-line node/no-deprecated-api
delete opts.url;if(!hostname&&!port&&!_protocol&&!auth)opts.path=path;// Relative redirect
else Object.assign(opts,{hostname:hostname,port:port,protocol:_protocol,auth:auth,path:path});// Absolute redirect
}var headers={'accept-encoding':'gzip, deflate'};if(opts.headers)Object.keys(opts.headers).forEach(function(k){return headers[k.toLowerCase()]=opts.headers[k];});opts.headers=headers;var body;if(opts.body){body=opts.json&&!isStream(opts.body)?JSON.stringify(opts.body):opts.body;}else if(opts.form){body=typeof opts.form==='string'?opts.form:querystring.stringify(opts.form);opts.headers['content-type']='application/x-www-form-urlencoded';}if(body){if(!opts.method)opts.method='POST';if(!isStream(body))opts.headers['content-length']=Buffer.byteLength(body);if(opts.json&&!opts.form)opts.headers['content-type']='application/json';}delete opts.body;delete opts.form;if(opts.json)opts.headers.accept='application/json';if(opts.method)opts.method=opts.method.toUpperCase();var originalHost=opts.hostname;// hostname before potential redirect
var protocol=opts.protocol==='https:'?https:http;// Support http/https urls
var req=protocol.request(opts,function(res){if(opts.followRedirects!==false&&res.statusCode>=300&&res.statusCode<400&&res.headers.location){opts.url=res.headers.location;// Follow 3xx redirects
delete opts.headers.host;// Discard `host` header on redirect (see #32)
res.resume();// Discard response
var redirectHost=url.parse(opts.url).hostname;// eslint-disable-line node/no-deprecated-api
// If redirected host is different than original host, drop headers to prevent cookie leak (#73)
if(redirectHost!==null&&redirectHost!==originalHost){delete opts.headers.cookie;delete opts.headers.authorization;}if(opts.method==='POST'&&[301,302].includes(res.statusCode)){opts.method='GET';// On 301/302 redirect, change POST to GET (see #35)
delete opts.headers['content-length'];delete opts.headers['content-type'];}if(opts.maxRedirects--===0)return cb(new Error('too many redirects'));else return simpleGet(opts,cb);}var tryUnzip=typeof decompressResponse==='function'&&opts.method!=='HEAD';cb(null,tryUnzip?decompressResponse(res):res);});req.on('timeout',function(){req.abort();cb(new Error('Request timed out'));});req.on('error',cb);if(isStream(body))body.on('error',cb).pipe(req);else req.end(body);return req;}simpleGet.concat=function(opts,cb){return simpleGet(opts,function(err,res){if(err)return cb(err);concat(res,function(err,data){if(err)return cb(err);if(opts.json){try{data=JSON.parse(data.toString());}catch(err){return cb(err,res,data);}}cb(null,res,data);});});};['get','post','put','patch','head','delete'].forEach(function(method){simpleGet[method]=function(opts,cb){if(typeof opts==='string')opts={url:opts};return simpleGet(Object.assign({method:method.toUpperCase()},opts),cb);};});}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":20,"decompress-response":18,"http":164,"https":110,"once":134,"querystring":156,"simple-concat":162,"url":185}],164:[function(require,module,exports){(function(global){(function(){var ClientRequest=require('./lib/request');var response=require('./lib/response');var extend=require('xtend');var statusCodes=require('builtin-status-codes');var url=require('url');var http=exports;http.request=function(opts,cb){if(typeof opts==='string')opts=url.parse(opts);else opts=extend(opts);// Normally, the page is loaded from http or https, so not specifying a protocol
// will result in a (valid) protocol-relative url. However, this won't work if
// the protocol is something else, like 'file:'
var defaultProtocol=global.location.protocol.search(/^https?:$/)===-1?'http:':'';var protocol=opts.protocol||defaultProtocol;var host=opts.hostname||opts.host;var port=opts.port;var path=opts.path||'/';// Necessary for IPv6 addresses
if(host&&host.indexOf(':')!==-1)host='['+host+']';// This may be a relative url. The browser should always be able to interpret it correctly.
opts.url=(host?protocol+'//'+host:'')+(port?':'+port:'')+path;opts.method=(opts.method||'GET').toUpperCase();opts.headers=opts.headers||{};// Also valid opts.auth, opts.mode
var req=new ClientRequest(opts);if(cb)req.on('response',cb);return req;};http.get=function get(opts,cb){var req=http.request(opts,cb);req.end();return req;};http.ClientRequest=ClientRequest;http.IncomingMessage=response.IncomingMessage;http.Agent=function(){};http.Agent.defaultMaxSockets=4;http.globalAgent=new http.Agent();http.STATUS_CODES=statusCodes;http.METHODS=['CHECKOUT','CONNECT','COPY','DELETE','GET','HEAD','LOCK','M-SEARCH','MERGE','MKACTIVITY','MKCOL','MOVE','NOTIFY','OPTIONS','PATCH','POST','PROPFIND','PROPPATCH','PURGE','PUT','REPORT','SEARCH','SUBSCRIBE','TRACE','UNLOCK','UNSUBSCRIBE'];}).call(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"./lib/request":166,"./lib/response":167,"builtin-status-codes":21,"url":185,"xtend":188}],165:[function(require,module,exports){(function(global){(function(){exports.fetch=isFunction(global.fetch)&&isFunction(global.ReadableStream);exports.writableStream=isFunction(global.WritableStream);exports.abortController=isFunction(global.AbortController);// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr;function getXHR(){// Cache the xhr value
if(xhr!==undefined)return xhr;if(global.XMLHttpRequest){xhr=new global.XMLHttpRequest();// If XDomainRequest is available (ie only, where xhr might not work
// cross domain), use the page location. Otherwise use example.com
// Note: this doesn't actually make an http request.
try{xhr.open('GET',global.XDomainRequest?'/':'https://example.com');}catch(e){xhr=null;}}else{// Service workers don't have XHR
xhr=null;}return xhr;}function checkTypeSupport(type){var xhr=getXHR();if(!xhr)return false;try{xhr.responseType=type;return xhr.responseType===type;}catch(e){}return false;}// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer=exports.fetch||checkTypeSupport('arraybuffer');// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream=!exports.fetch&&checkTypeSupport('ms-stream');exports.mozchunkedarraybuffer=!exports.fetch&&checkTypeSupport('moz-chunked-arraybuffer');// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType=exports.fetch||(getXHR()?isFunction(getXHR().overrideMimeType):false);function isFunction(value){return typeof value==='function';}xhr=null;// Help gc
}).call(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],166:[function(require,module,exports){(function(process,global,Buffer){(function(){var capability=require('./capability');var inherits=require('inherits');var response=require('./response');var stream=require('readable-stream');var IncomingMessage=response.IncomingMessage;var rStates=response.readyStates;function decideMode(preferBinary,useFetch){if(capability.fetch&&useFetch){return'fetch';}else if(capability.mozchunkedarraybuffer){return'moz-chunked-arraybuffer';}else if(capability.msstream){return'ms-stream';}else if(capability.arraybuffer&&preferBinary){return'arraybuffer';}else{return'text';}}var ClientRequest=module.exports=function(opts){var self=this;stream.Writable.call(self);self._opts=opts;self._body=[];self._headers={};if(opts.auth)self.setHeader('Authorization','Basic '+Buffer.from(opts.auth).toString('base64'));Object.keys(opts.headers).forEach(function(name){self.setHeader(name,opts.headers[name]);});var preferBinary;var useFetch=true;if(opts.mode==='disable-fetch'||'requestTimeout'in opts&&!capability.abortController){// If the use of XHR should be preferred. Not typically needed.
useFetch=false;preferBinary=true;}else if(opts.mode==='prefer-streaming'){// If streaming is a high priority but binary compatibility and
// the accuracy of the 'content-type' header aren't
preferBinary=false;}else if(opts.mode==='allow-wrong-content-type'){// If streaming is more important than preserving the 'content-type' header
preferBinary=!capability.overrideMimeType;}else if(!opts.mode||opts.mode==='default'||opts.mode==='prefer-fast'){// Use binary if text streaming may corrupt data or the content-type header, or for speed
preferBinary=true;}else{throw new Error('Invalid value for opts.mode');}self._mode=decideMode(preferBinary,useFetch);self._fetchTimer=null;self._socketTimeout=null;self._socketTimer=null;self.on('finish',function(){self._onFinish();});};inherits(ClientRequest,stream.Writable);ClientRequest.prototype.setHeader=function(name,value){var self=this;var lowerName=name.toLowerCase();// This check is not necessary, but it prevents warnings from browsers about setting unsafe
// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
// http-browserify did it, so I will too.
if(unsafeHeaders.indexOf(lowerName)!==-1)return;self._headers[lowerName]={name:name,value:value};};ClientRequest.prototype.getHeader=function(name){var header=this._headers[name.toLowerCase()];if(header)return header.value;return null;};ClientRequest.prototype.removeHeader=function(name){var self=this;delete self._headers[name.toLowerCase()];};ClientRequest.prototype._onFinish=function(){var self=this;if(self._destroyed)return;var opts=self._opts;if('timeout'in opts&&opts.timeout!==0){self.setTimeout(opts.timeout);}var headersObj=self._headers;var body=null;if(opts.method!=='GET'&&opts.method!=='HEAD'){body=new Blob(self._body,{type:(headersObj['content-type']||{}).value||''});}// create flattened list of headers
var headersList=[];Object.keys(headersObj).forEach(function(keyName){var name=headersObj[keyName].name;var value=headersObj[keyName].value;if(Array.isArray(value)){value.forEach(function(v){headersList.push([name,v]);});}else{headersList.push([name,value]);}});if(self._mode==='fetch'){var signal=null;if(capability.abortController){var controller=new AbortController();signal=controller.signal;self._fetchAbortController=controller;if('requestTimeout'in opts&&opts.requestTimeout!==0){self._fetchTimer=global.setTimeout(function(){self.emit('requestTimeout');if(self._fetchAbortController)self._fetchAbortController.abort();},opts.requestTimeout);}}global.fetch(self._opts.url,{method:self._opts.method,headers:headersList,body:body||undefined,mode:'cors',credentials:opts.withCredentials?'include':'same-origin',signal:signal}).then(function(response){self._fetchResponse=response;self._resetTimers(false);self._connect();},function(reason){self._resetTimers(true);if(!self._destroyed)self.emit('error',reason);});}else{var xhr=self._xhr=new global.XMLHttpRequest();try{xhr.open(self._opts.method,self._opts.url,true);}catch(err){process.nextTick(function(){self.emit('error',err);});return;}// Can't set responseType on really old browsers
if('responseType'in xhr)xhr.responseType=self._mode;if('withCredentials'in xhr)xhr.withCredentials=!!opts.withCredentials;if(self._mode==='text'&&'overrideMimeType'in xhr)xhr.overrideMimeType('text/plain; charset=x-user-defined');if('requestTimeout'in opts){xhr.timeout=opts.requestTimeout;xhr.ontimeout=function(){self.emit('requestTimeout');};}headersList.forEach(function(header){xhr.setRequestHeader(header[0],header[1]);});self._response=null;xhr.onreadystatechange=function(){switch(xhr.readyState){case rStates.LOADING:case rStates.DONE:self._onXHRProgress();break;}};// Necessary for streaming in Firefox, since xhr.response is ONLY defined
// in onprogress, not in onreadystatechange with xhr.readyState = 3
if(self._mode==='moz-chunked-arraybuffer'){xhr.onprogress=function(){self._onXHRProgress();};}xhr.onerror=function(){if(self._destroyed)return;self._resetTimers(true);self.emit('error',new Error('XHR error'));};try{xhr.send(body);}catch(err){process.nextTick(function(){self.emit('error',err);});return;}}};/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */function statusValid(xhr){try{var status=xhr.status;return status!==null&&status!==0;}catch(e){return false;}}ClientRequest.prototype._onXHRProgress=function(){var self=this;self._resetTimers(false);if(!statusValid(self._xhr)||self._destroyed)return;if(!self._response)self._connect();self._response._onXHRProgress(self._resetTimers.bind(self));};ClientRequest.prototype._connect=function(){var self=this;if(self._destroyed)return;self._response=new IncomingMessage(self._xhr,self._fetchResponse,self._mode,self._resetTimers.bind(self));self._response.on('error',function(err){self.emit('error',err);});self.emit('response',self._response);};ClientRequest.prototype._write=function(chunk,encoding,cb){var self=this;self._body.push(chunk);cb();};ClientRequest.prototype._resetTimers=function(done){var self=this;global.clearTimeout(self._socketTimer);self._socketTimer=null;if(done){global.clearTimeout(self._fetchTimer);self._fetchTimer=null;}else if(self._socketTimeout){self._socketTimer=global.setTimeout(function(){self.emit('timeout');},self._socketTimeout);}};ClientRequest.prototype.abort=ClientRequest.prototype.destroy=function(err){var self=this;self._destroyed=true;self._resetTimers(true);if(self._response)self._response._destroyed=true;if(self._xhr)self._xhr.abort();else if(self._fetchAbortController)self._fetchAbortController.abort();if(err)self.emit('error',err);};ClientRequest.prototype.end=function(data,encoding,cb){var self=this;if(typeof data==='function'){cb=data;data=undefined;}stream.Writable.prototype.end.call(self,data,encoding,cb);};ClientRequest.prototype.setTimeout=function(timeout,cb){var self=this;if(cb)self.once('timeout',cb);self._socketTimeout=timeout;self._resetTimers(false);};ClientRequest.prototype.flushHeaders=function(){};ClientRequest.prototype.setNoDelay=function(){};ClientRequest.prototype.setSocketKeepAlive=function(){};// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders=['accept-charset','accept-encoding','access-control-request-headers','access-control-request-method','connection','content-length','cookie','cookie2','date','dnt','expect','host','keep-alive','origin','referer','te','trailer','transfer-encoding','upgrade','via'];}).call(this);}).call(this,require('_process'),typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{},require("buffer").Buffer);},{"./capability":165,"./response":167,"_process":147,"buffer":20,"inherits":112,"readable-stream":182}],167:[function(require,module,exports){(function(process,global,Buffer){(function(){var capability=require('./capability');var inherits=require('inherits');var stream=require('readable-stream');var rStates=exports.readyStates={UNSENT:0,OPENED:1,HEADERS_RECEIVED:2,LOADING:3,DONE:4};var IncomingMessage=exports.IncomingMessage=function(xhr,response,mode,resetTimers){var self=this;stream.Readable.call(self);self._mode=mode;self.headers={};self.rawHeaders=[];self.trailers={};self.rawTrailers=[];// Fake the 'close' event, but only once 'end' fires
self.on('end',function(){// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
process.nextTick(function(){self.emit('close');});});if(mode==='fetch'){var _read=function read(){reader.read().then(function(result){if(self._destroyed)return;resetTimers(result.done);if(result.done){self.push(null);return;}self.push(Buffer.from(result.value));_read();})["catch"](function(err){resetTimers(true);if(!self._destroyed)self.emit('error',err);});};self._fetchResponse=response;self.url=response.url;self.statusCode=response.status;self.statusMessage=response.statusText;response.headers.forEach(function(header,key){self.headers[key.toLowerCase()]=header;self.rawHeaders.push(key,header);});if(capability.writableStream){var writable=new WritableStream({write:function write(chunk){resetTimers(false);return new Promise(function(resolve,reject){if(self._destroyed){reject();}else if(self.push(Buffer.from(chunk))){resolve();}else{self._resumeFetch=resolve;}});},close:function close(){resetTimers(true);if(!self._destroyed)self.push(null);},abort:function abort(err){resetTimers(true);if(!self._destroyed)self.emit('error',err);}});try{response.body.pipeTo(writable)["catch"](function(err){resetTimers(true);if(!self._destroyed)self.emit('error',err);});return;}catch(e){}// pipeTo method isn't defined. Can't find a better way to feature test this
}// fallback for when writableStream or pipeTo aren't available
var reader=response.body.getReader();_read();}else{self._xhr=xhr;self._pos=0;self.url=xhr.responseURL;self.statusCode=xhr.status;self.statusMessage=xhr.statusText;var headers=xhr.getAllResponseHeaders().split(/\r?\n/);headers.forEach(function(header){var matches=header.match(/^([^:]+):\s*(.*)/);if(matches){var key=matches[1].toLowerCase();if(key==='set-cookie'){if(self.headers[key]===undefined){self.headers[key]=[];}self.headers[key].push(matches[2]);}else if(self.headers[key]!==undefined){self.headers[key]+=', '+matches[2];}else{self.headers[key]=matches[2];}self.rawHeaders.push(matches[1],matches[2]);}});self._charset='x-user-defined';if(!capability.overrideMimeType){var mimeType=self.rawHeaders['mime-type'];if(mimeType){var charsetMatch=mimeType.match(/;\s*charset=([^;])(;|$)/);if(charsetMatch){self._charset=charsetMatch[1].toLowerCase();}}if(!self._charset)self._charset='utf-8';// best guess
}}};inherits(IncomingMessage,stream.Readable);IncomingMessage.prototype._read=function(){var self=this;var resolve=self._resumeFetch;if(resolve){self._resumeFetch=null;resolve();}};IncomingMessage.prototype._onXHRProgress=function(resetTimers){var self=this;var xhr=self._xhr;var response=null;switch(self._mode){case'text':response=xhr.responseText;if(response.length>self._pos){var newData=response.substr(self._pos);if(self._charset==='x-user-defined'){var buffer=Buffer.alloc(newData.length);for(var i=0;i<newData.length;i++)buffer[i]=newData.charCodeAt(i)&0xff;self.push(buffer);}else{self.push(newData,self._charset);}self._pos=response.length;}break;case'arraybuffer':if(xhr.readyState!==rStates.DONE||!xhr.response)break;response=xhr.response;self.push(Buffer.from(new Uint8Array(response)));break;case'moz-chunked-arraybuffer':// take whole
response=xhr.response;if(xhr.readyState!==rStates.LOADING||!response)break;self.push(Buffer.from(new Uint8Array(response)));break;case'ms-stream':response=xhr.response;if(xhr.readyState!==rStates.LOADING)break;var reader=new global.MSStreamReader();reader.onprogress=function(){if(reader.result.byteLength>self._pos){self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));self._pos=reader.result.byteLength;}};reader.onload=function(){resetTimers(true);self.push(null);};// reader.onerror = ??? // TODO: this
reader.readAsArrayBuffer(response);break;}// The ms-stream case handles end separately in reader.onload()
if(self._xhr.readyState===rStates.DONE&&self._mode!=='ms-stream'){resetTimers(true);self.push(null);}};}).call(this);}).call(this,require('_process'),typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{},require("buffer").Buffer);},{"./capability":165,"_process":147,"buffer":20,"inherits":112,"readable-stream":182}],168:[function(require,module,exports){'use strict';function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}var codes={};function createErrorType(code,message,Base){if(!Base){Base=Error;}function getMessage(arg1,arg2,arg3){if(typeof message==='string'){return message;}else{return message(arg1,arg2,arg3);}}var NodeError=/*#__PURE__*/function(_Base){_inheritsLoose(NodeError,_Base);function NodeError(arg1,arg2,arg3){return _Base.call(this,getMessage(arg1,arg2,arg3))||this;}return NodeError;}(Base);NodeError.prototype.name=Base.name;NodeError.prototype.code=code;codes[code]=NodeError;}// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected,thing){if(Array.isArray(expected)){var len=expected.length;expected=expected.map(function(i){return String(i);});if(len>2){return"one of ".concat(thing," ").concat(expected.slice(0,len-1).join(', '),", or ")+expected[len-1];}else if(len===2){return"one of ".concat(thing," ").concat(expected[0]," or ").concat(expected[1]);}else{return"of ".concat(thing," ").concat(expected[0]);}}else{return"of ".concat(thing," ").concat(String(expected));}}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str,search,pos){return str.substr(!pos||pos<0?0:+pos,search.length)===search;}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str,search,this_len){if(this_len===undefined||this_len>str.length){this_len=str.length;}return str.substring(this_len-search.length,this_len)===search;}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str,search,start){if(typeof start!=='number'){start=0;}if(start+search.length>str.length){return false;}else{return str.indexOf(search,start)!==-1;}}createErrorType('ERR_INVALID_OPT_VALUE',function(name,value){return'The value "'+value+'" is invalid for option "'+name+'"';},TypeError);createErrorType('ERR_INVALID_ARG_TYPE',function(name,expected,actual){// determiner: 'must be' or 'must not be'
var determiner;if(typeof expected==='string'&&startsWith(expected,'not ')){determiner='must not be';expected=expected.replace(/^not /,'');}else{determiner='must be';}var msg;if(endsWith(name,' argument')){// For cases like 'first argument'
msg="The ".concat(name," ").concat(determiner," ").concat(oneOf(expected,'type'));}else{var type=includes(name,'.')?'property':'argument';msg="The \"".concat(name,"\" ").concat(type," ").concat(determiner," ").concat(oneOf(expected,'type'));}msg+=". Received type ".concat(_typeof(actual));return msg;},TypeError);createErrorType('ERR_STREAM_PUSH_AFTER_EOF','stream.push() after EOF');createErrorType('ERR_METHOD_NOT_IMPLEMENTED',function(name){return'The '+name+' method is not implemented';});createErrorType('ERR_STREAM_PREMATURE_CLOSE','Premature close');createErrorType('ERR_STREAM_DESTROYED',function(name){return'Cannot call '+name+' after a stream was destroyed';});createErrorType('ERR_MULTIPLE_CALLBACK','Callback called multiple times');createErrorType('ERR_STREAM_CANNOT_PIPE','Cannot pipe, not readable');createErrorType('ERR_STREAM_WRITE_AFTER_END','write after end');createErrorType('ERR_STREAM_NULL_VALUES','May not write null values to stream',TypeError);createErrorType('ERR_UNKNOWN_ENCODING',function(arg){return'Unknown encoding: '+arg;},TypeError);createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT','stream.unshift() after end event');module.exports.codes=codes;},{}],169:[function(require,module,exports){(function(process){(function(){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';/*<replacement>*/var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj)keys.push(key);return keys;};/*</replacement>*/module.exports=Duplex;var Readable=require('./_stream_readable');var Writable=require('./_stream_writable');require('inherits')(Duplex,Readable);{// Allow the keys array to be GC'ed.
var keys=objectKeys(Writable.prototype);for(var v=0;v<keys.length;v++){var method=keys[v];if(!Duplex.prototype[method])Duplex.prototype[method]=Writable.prototype[method];}}function Duplex(options){if(!(this instanceof Duplex))return new Duplex(options);Readable.call(this,options);Writable.call(this,options);this.allowHalfOpen=true;if(options){if(options.readable===false)this.readable=false;if(options.writable===false)this.writable=false;if(options.allowHalfOpen===false){this.allowHalfOpen=false;this.once('end',onend);}}}Object.defineProperty(Duplex.prototype,'writableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.highWaterMark;}});Object.defineProperty(Duplex.prototype,'writableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer();}});Object.defineProperty(Duplex.prototype,'writableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.length;}});// the no-half-open enforcer
function onend(){// If the writable side ended, then we're ok.
if(this._writableState.ended)return;// no more data can be written.
// But allow more writes to happen in this tick.
process.nextTick(onEndNT,this);}function onEndNT(self){self.end();}Object.defineProperty(Duplex.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._readableState===undefined||this._writableState===undefined){return false;}return this._readableState.destroyed&&this._writableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(this._readableState===undefined||this._writableState===undefined){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._readableState.destroyed=value;this._writableState.destroyed=value;}});}).call(this);}).call(this,require('_process'));},{"./_stream_readable":171,"./_stream_writable":173,"_process":147,"inherits":112}],170:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';module.exports=PassThrough;var Transform=require('./_stream_transform');require('inherits')(PassThrough,Transform);function PassThrough(options){if(!(this instanceof PassThrough))return new PassThrough(options);Transform.call(this,options);}PassThrough.prototype._transform=function(chunk,encoding,cb){cb(null,chunk);};},{"./_stream_transform":172,"inherits":112}],171:[function(require,module,exports){(function(process,global){(function(){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';module.exports=Readable;/*<replacement>*/var Duplex;/*</replacement>*/Readable.ReadableState=ReadableState;/*<replacement>*/var EE=require('events').EventEmitter;var EElistenerCount=function EElistenerCount(emitter,type){return emitter.listeners(type).length;};/*</replacement>*//*<replacement>*/var Stream=require('./internal/streams/stream');/*</replacement>*/var Buffer=require('buffer').Buffer;var OurUint8Array=(typeof global!=='undefined'?global:typeof window!=='undefined'?window:typeof self!=='undefined'?self:{}).Uint8Array||function(){};function _uint8ArrayToBuffer(chunk){return Buffer.from(chunk);}function _isUint8Array(obj){return Buffer.isBuffer(obj)||obj instanceof OurUint8Array;}/*<replacement>*/var debugUtil=require('util');var debug;if(debugUtil&&debugUtil.debuglog){debug=debugUtil.debuglog('stream');}else{debug=function debug(){};}/*</replacement>*/var BufferList=require('./internal/streams/buffer_list');var destroyImpl=require('./internal/streams/destroy');var _require=require('./internal/streams/state'),getHighWaterMark=_require.getHighWaterMark;var _require$codes=require('../errors').codes,ERR_INVALID_ARG_TYPE=_require$codes.ERR_INVALID_ARG_TYPE,ERR_STREAM_PUSH_AFTER_EOF=_require$codes.ERR_STREAM_PUSH_AFTER_EOF,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_STREAM_UNSHIFT_AFTER_END_EVENT=_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;// Lazy loaded to improve the startup performance.
var StringDecoder;var createReadableStreamAsyncIterator;var from;require('inherits')(Readable,Stream);var errorOrDestroy=destroyImpl.errorOrDestroy;var kProxyEvents=['error','close','destroy','pause','resume'];function prependListener(emitter,event,fn){// Sadly this is not cacheable as some libraries bundle their own
// event emitter implementation with them.
if(typeof emitter.prependListener==='function')return emitter.prependListener(event,fn);// This is a hack to make sure that our error handler is attached before any
// userland ones.  NEVER DO THIS. This is here only because this code needs
// to continue to work with older versions of Node.js that do not include
// the prependListener() method. The goal is to eventually remove this hack.
if(!emitter._events||!emitter._events[event])emitter.on(event,fn);else if(Array.isArray(emitter._events[event]))emitter._events[event].unshift(fn);else emitter._events[event]=[fn,emitter._events[event]];}function ReadableState(options,stream,isDuplex){Duplex=Duplex||require('./_stream_duplex');options=options||{};// Duplex streams are both readable and writable, but share
// the same options object.
// However, some cases require setting options to different
// values for the readable and the writable sides of the duplex stream.
// These options can be provided separately as readableXXX and writableXXX.
if(typeof isDuplex!=='boolean')isDuplex=stream instanceof Duplex;// object stream flag. Used to make read(n) ignore n and to
// make all the buffer merging and length checks go away
this.objectMode=!!options.objectMode;if(isDuplex)this.objectMode=this.objectMode||!!options.readableObjectMode;// the point at which it stops calling _read() to fill the buffer
// Note: 0 is a valid value, means "don't call _read preemptively ever"
this.highWaterMark=getHighWaterMark(this,options,'readableHighWaterMark',isDuplex);// A linked list is used to store data chunks instead of an array because the
// linked list can remove elements from the beginning faster than
// array.shift()
this.buffer=new BufferList();this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.ended=false;this.endEmitted=false;this.reading=false;// a flag to be able to tell if the event 'readable'/'data' is emitted
// immediately, or on a later tick.  We set this to true at first, because
// any actions that shouldn't happen until "later" should generally also
// not happen before the first read call.
this.sync=true;// whenever we return null, then we set a flag to say
// that we're awaiting a 'readable' event emission.
this.needReadable=false;this.emittedReadable=false;this.readableListening=false;this.resumeScheduled=false;this.paused=true;// Should close be emitted on destroy. Defaults to true.
this.emitClose=options.emitClose!==false;// Should .destroy() be called after 'end' (and potentially 'finish')
this.autoDestroy=!!options.autoDestroy;// has it been destroyed
this.destroyed=false;// Crypto is kind of old and crusty.  Historically, its default string
// encoding is 'binary' so we have to make this configurable.
// Everything else in the universe uses 'utf8', though.
this.defaultEncoding=options.defaultEncoding||'utf8';// the number of writers that are awaiting a drain event in .pipe()s
this.awaitDrain=0;// if true, a maybeReadMore has been scheduled
this.readingMore=false;this.decoder=null;this.encoding=null;if(options.encoding){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;this.decoder=new StringDecoder(options.encoding);this.encoding=options.encoding;}}function Readable(options){Duplex=Duplex||require('./_stream_duplex');if(!(this instanceof Readable))return new Readable(options);// Checking for a Stream.Duplex instance is faster here instead of inside
// the ReadableState constructor, at least with V8 6.5
var isDuplex=this instanceof Duplex;this._readableState=new ReadableState(options,this,isDuplex);// legacy
this.readable=true;if(options){if(typeof options.read==='function')this._read=options.read;if(typeof options.destroy==='function')this._destroy=options.destroy;}Stream.call(this);}Object.defineProperty(Readable.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._readableState===undefined){return false;}return this._readableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(!this._readableState){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._readableState.destroyed=value;}});Readable.prototype.destroy=destroyImpl.destroy;Readable.prototype._undestroy=destroyImpl.undestroy;Readable.prototype._destroy=function(err,cb){cb(err);};// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push=function(chunk,encoding){var state=this._readableState;var skipChunkCheck;if(!state.objectMode){if(typeof chunk==='string'){encoding=encoding||state.defaultEncoding;if(encoding!==state.encoding){chunk=Buffer.from(chunk,encoding);encoding='';}skipChunkCheck=true;}}else{skipChunkCheck=true;}return readableAddChunk(this,chunk,encoding,false,skipChunkCheck);};// Unshift should *always* be something directly out of read()
Readable.prototype.unshift=function(chunk){return readableAddChunk(this,chunk,null,true,false);};function readableAddChunk(stream,chunk,encoding,addToFront,skipChunkCheck){debug('readableAddChunk',chunk);var state=stream._readableState;if(chunk===null){state.reading=false;onEofChunk(stream,state);}else{var er;if(!skipChunkCheck)er=chunkInvalid(state,chunk);if(er){errorOrDestroy(stream,er);}else if(state.objectMode||chunk&&chunk.length>0){if(typeof chunk!=='string'&&!state.objectMode&&Object.getPrototypeOf(chunk)!==Buffer.prototype){chunk=_uint8ArrayToBuffer(chunk);}if(addToFront){if(state.endEmitted)errorOrDestroy(stream,new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream,state,chunk,true);}else if(state.ended){errorOrDestroy(stream,new ERR_STREAM_PUSH_AFTER_EOF());}else if(state.destroyed){return false;}else{state.reading=false;if(state.decoder&&!encoding){chunk=state.decoder.write(chunk);if(state.objectMode||chunk.length!==0)addChunk(stream,state,chunk,false);else maybeReadMore(stream,state);}else{addChunk(stream,state,chunk,false);}}}else if(!addToFront){state.reading=false;maybeReadMore(stream,state);}}// We can push more data if we are below the highWaterMark.
// Also, if we have no data yet, we can stand some more bytes.
// This is to work around cases where hwm=0, such as the repl.
return!state.ended&&(state.length<state.highWaterMark||state.length===0);}function addChunk(stream,state,chunk,addToFront){if(state.flowing&&state.length===0&&!state.sync){state.awaitDrain=0;stream.emit('data',chunk);}else{// update the buffer info.
state.length+=state.objectMode?1:chunk.length;if(addToFront)state.buffer.unshift(chunk);else state.buffer.push(chunk);if(state.needReadable)emitReadable(stream);}maybeReadMore(stream,state);}function chunkInvalid(state,chunk){var er;if(!_isUint8Array(chunk)&&typeof chunk!=='string'&&chunk!==undefined&&!state.objectMode){er=new ERR_INVALID_ARG_TYPE('chunk',['string','Buffer','Uint8Array'],chunk);}return er;}Readable.prototype.isPaused=function(){return this._readableState.flowing===false;};// backwards compatibility.
Readable.prototype.setEncoding=function(enc){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;var decoder=new StringDecoder(enc);this._readableState.decoder=decoder;// If setEncoding(null), decoder.encoding equals utf8
this._readableState.encoding=this._readableState.decoder.encoding;// Iterate over current buffer to convert already stored Buffers:
var p=this._readableState.buffer.head;var content='';while(p!==null){content+=decoder.write(p.data);p=p.next;}this._readableState.buffer.clear();if(content!=='')this._readableState.buffer.push(content);this._readableState.length=content.length;return this;};// Don't raise the hwm > 1GB
var MAX_HWM=0x40000000;function computeNewHighWaterMark(n){if(n>=MAX_HWM){// TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
n=MAX_HWM;}else{// Get the next highest power of 2 to prevent increasing hwm excessively in
// tiny amounts
n--;n|=n>>>1;n|=n>>>2;n|=n>>>4;n|=n>>>8;n|=n>>>16;n++;}return n;}// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n,state){if(n<=0||state.length===0&&state.ended)return 0;if(state.objectMode)return 1;if(n!==n){// Only flow one buffer at a time
if(state.flowing&&state.length)return state.buffer.head.data.length;else return state.length;}// If we're asking for more than the current hwm, then raise the hwm.
if(n>state.highWaterMark)state.highWaterMark=computeNewHighWaterMark(n);if(n<=state.length)return n;// Don't have enough
if(!state.ended){state.needReadable=true;return 0;}return state.length;}// you can override either this method, or the async _read(n) below.
Readable.prototype.read=function(n){debug('read',n);n=parseInt(n,10);var state=this._readableState;var nOrig=n;if(n!==0)state.emittedReadable=false;// if we're doing read(0) to trigger a readable event, but we
// already have a bunch of data in the buffer, then just trigger
// the 'readable' event and move on.
if(n===0&&state.needReadable&&((state.highWaterMark!==0?state.length>=state.highWaterMark:state.length>0)||state.ended)){debug('read: emitReadable',state.length,state.ended);if(state.length===0&&state.ended)endReadable(this);else emitReadable(this);return null;}n=howMuchToRead(n,state);// if we've ended, and we're now clear, then finish it up.
if(n===0&&state.ended){if(state.length===0)endReadable(this);return null;}// All the actual chunk generation logic needs to be
// *below* the call to _read.  The reason is that in certain
// synthetic stream cases, such as passthrough streams, _read
// may be a completely synchronous operation which may change
// the state of the read buffer, providing enough data when
// before there was *not* enough.
//
// So, the steps are:
// 1. Figure out what the state of things will be after we do
// a read from the buffer.
//
// 2. If that resulting state will trigger a _read, then call _read.
// Note that this may be asynchronous, or synchronous.  Yes, it is
// deeply ugly to write APIs this way, but that still doesn't mean
// that the Readable class should behave improperly, as streams are
// designed to be sync/async agnostic.
// Take note if the _read call is sync or async (ie, if the read call
// has returned yet), so that we know whether or not it's safe to emit
// 'readable' etc.
//
// 3. Actually pull the requested chunks out of the buffer and return.
// if we need a readable event, then we need to do some reading.
var doRead=state.needReadable;debug('need readable',doRead);// if we currently have less than the highWaterMark, then also read some
if(state.length===0||state.length-n<state.highWaterMark){doRead=true;debug('length less than watermark',doRead);}// however, if we've ended, then there's no point, and if we're already
// reading, then it's unnecessary.
if(state.ended||state.reading){doRead=false;debug('reading or ended',doRead);}else if(doRead){debug('do read');state.reading=true;state.sync=true;// if the length is currently zero, then we *need* a readable event.
if(state.length===0)state.needReadable=true;// call internal read method
this._read(state.highWaterMark);state.sync=false;// If _read pushed data synchronously, then `reading` will be false,
// and we need to re-evaluate how much data we can return to the user.
if(!state.reading)n=howMuchToRead(nOrig,state);}var ret;if(n>0)ret=fromList(n,state);else ret=null;if(ret===null){state.needReadable=state.length<=state.highWaterMark;n=0;}else{state.length-=n;state.awaitDrain=0;}if(state.length===0){// If we have nothing in the buffer, then we want to know
// as soon as we *do* get something into the buffer.
if(!state.ended)state.needReadable=true;// If we tried to read() past the EOF, then emit end on the next tick.
if(nOrig!==n&&state.ended)endReadable(this);}if(ret!==null)this.emit('data',ret);return ret;};function onEofChunk(stream,state){debug('onEofChunk');if(state.ended)return;if(state.decoder){var chunk=state.decoder.end();if(chunk&&chunk.length){state.buffer.push(chunk);state.length+=state.objectMode?1:chunk.length;}}state.ended=true;if(state.sync){// if we are sync, wait until next tick to emit the data.
// Otherwise we risk emitting data in the flow()
// the readable code triggers during a read() call
emitReadable(stream);}else{// emit 'readable' now to make sure it gets picked up.
state.needReadable=false;if(!state.emittedReadable){state.emittedReadable=true;emitReadable_(stream);}}}// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream){var state=stream._readableState;debug('emitReadable',state.needReadable,state.emittedReadable);state.needReadable=false;if(!state.emittedReadable){debug('emitReadable',state.flowing);state.emittedReadable=true;process.nextTick(emitReadable_,stream);}}function emitReadable_(stream){var state=stream._readableState;debug('emitReadable_',state.destroyed,state.length,state.ended);if(!state.destroyed&&(state.length||state.ended)){stream.emit('readable');state.emittedReadable=false;}// The stream needs another readable event if
// 1. It is not flowing, as the flow mechanism will take
//    care of it.
// 2. It is not ended.
// 3. It is below the highWaterMark, so we can schedule
//    another readable later.
state.needReadable=!state.flowing&&!state.ended&&state.length<=state.highWaterMark;flow(stream);}// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream,state){if(!state.readingMore){state.readingMore=true;process.nextTick(maybeReadMore_,stream,state);}}function maybeReadMore_(stream,state){// Attempt to read more data if we should.
//
// The conditions for reading more data are (one of):
// - Not enough data buffered (state.length < state.highWaterMark). The loop
//   is responsible for filling the buffer with enough data if such data
//   is available. If highWaterMark is 0 and we are not in the flowing mode
//   we should _not_ attempt to buffer any extra data. We'll get more data
//   when the stream consumer calls read() instead.
// - No data in the buffer, and the stream is in flowing mode. In this mode
//   the loop below is responsible for ensuring read() is called. Failing to
//   call read here would abort the flow and there's no other mechanism for
//   continuing the flow if the stream consumer has just subscribed to the
//   'data' event.
//
// In addition to the above conditions to keep reading data, the following
// conditions prevent the data from being read:
// - The stream has ended (state.ended).
// - There is already a pending 'read' operation (state.reading). This is a
//   case where the the stream has called the implementation defined _read()
//   method, but they are processing the call asynchronously and have _not_
//   called push() with new data. In this case we skip performing more
//   read()s. The execution ends in this method again after the _read() ends
//   up calling push() with more data.
while(!state.reading&&!state.ended&&(state.length<state.highWaterMark||state.flowing&&state.length===0)){var len=state.length;debug('maybeReadMore read 0');stream.read(0);if(len===state.length)// didn't get any data, stop spinning.
break;}state.readingMore=false;}// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read=function(n){errorOrDestroy(this,new ERR_METHOD_NOT_IMPLEMENTED('_read()'));};Readable.prototype.pipe=function(dest,pipeOpts){var src=this;var state=this._readableState;switch(state.pipesCount){case 0:state.pipes=dest;break;case 1:state.pipes=[state.pipes,dest];break;default:state.pipes.push(dest);break;}state.pipesCount+=1;debug('pipe count=%d opts=%j',state.pipesCount,pipeOpts);var doEnd=(!pipeOpts||pipeOpts.end!==false)&&dest!==process.stdout&&dest!==process.stderr;var endFn=doEnd?onend:unpipe;if(state.endEmitted)process.nextTick(endFn);else src.once('end',endFn);dest.on('unpipe',onunpipe);function onunpipe(readable,unpipeInfo){debug('onunpipe');if(readable===src){if(unpipeInfo&&unpipeInfo.hasUnpiped===false){unpipeInfo.hasUnpiped=true;cleanup();}}}function onend(){debug('onend');dest.end();}// when the dest drains, it reduces the awaitDrain counter
// on the source.  This would be more elegant with a .once()
// handler in flow(), but adding and removing repeatedly is
// too slow.
var ondrain=pipeOnDrain(src);dest.on('drain',ondrain);var cleanedUp=false;function cleanup(){debug('cleanup');// cleanup event handlers once the pipe is broken
dest.removeListener('close',onclose);dest.removeListener('finish',onfinish);dest.removeListener('drain',ondrain);dest.removeListener('error',onerror);dest.removeListener('unpipe',onunpipe);src.removeListener('end',onend);src.removeListener('end',unpipe);src.removeListener('data',ondata);cleanedUp=true;// if the reader is waiting for a drain event from this
// specific writer, then it would cause it to never start
// flowing again.
// So, if this is awaiting a drain, then we just call it now.
// If we don't know, then assume that we are waiting for one.
if(state.awaitDrain&&(!dest._writableState||dest._writableState.needDrain))ondrain();}src.on('data',ondata);function ondata(chunk){debug('ondata');var ret=dest.write(chunk);debug('dest.write',ret);if(ret===false){// If the user unpiped during `dest.write()`, it is possible
// to get stuck in a permanently paused state if that write
// also returned false.
// => Check whether `dest` is still a piping destination.
if((state.pipesCount===1&&state.pipes===dest||state.pipesCount>1&&indexOf(state.pipes,dest)!==-1)&&!cleanedUp){debug('false write response, pause',state.awaitDrain);state.awaitDrain++;}src.pause();}}// if the dest has an error, then stop piping into it.
// however, don't suppress the throwing behavior for this.
function onerror(er){debug('onerror',er);unpipe();dest.removeListener('error',onerror);if(EElistenerCount(dest,'error')===0)errorOrDestroy(dest,er);}// Make sure our error handler is attached before userland ones.
prependListener(dest,'error',onerror);// Both close and finish should trigger unpipe, but only once.
function onclose(){dest.removeListener('finish',onfinish);unpipe();}dest.once('close',onclose);function onfinish(){debug('onfinish');dest.removeListener('close',onclose);unpipe();}dest.once('finish',onfinish);function unpipe(){debug('unpipe');src.unpipe(dest);}// tell the dest that it's being piped to
dest.emit('pipe',src);// start the flow if it hasn't been started already.
if(!state.flowing){debug('pipe resume');src.resume();}return dest;};function pipeOnDrain(src){return function pipeOnDrainFunctionResult(){var state=src._readableState;debug('pipeOnDrain',state.awaitDrain);if(state.awaitDrain)state.awaitDrain--;if(state.awaitDrain===0&&EElistenerCount(src,'data')){state.flowing=true;flow(src);}};}Readable.prototype.unpipe=function(dest){var state=this._readableState;var unpipeInfo={hasUnpiped:false};// if we're not piping anywhere, then do nothing.
if(state.pipesCount===0)return this;// just one destination.  most common case.
if(state.pipesCount===1){// passed in one, but it's not the right one.
if(dest&&dest!==state.pipes)return this;if(!dest)dest=state.pipes;// got a match.
state.pipes=null;state.pipesCount=0;state.flowing=false;if(dest)dest.emit('unpipe',this,unpipeInfo);return this;}// slow case. multiple pipe destinations.
if(!dest){// remove all.
var dests=state.pipes;var len=state.pipesCount;state.pipes=null;state.pipesCount=0;state.flowing=false;for(var i=0;i<len;i++)dests[i].emit('unpipe',this,{hasUnpiped:false});return this;}// try to find the right one.
var index=indexOf(state.pipes,dest);if(index===-1)return this;state.pipes.splice(index,1);state.pipesCount-=1;if(state.pipesCount===1)state.pipes=state.pipes[0];dest.emit('unpipe',this,unpipeInfo);return this;};// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on=function(ev,fn){var res=Stream.prototype.on.call(this,ev,fn);var state=this._readableState;if(ev==='data'){// update readableListening so that resume() may be a no-op
// a few lines down. This is needed to support once('readable').
state.readableListening=this.listenerCount('readable')>0;// Try start flowing on next tick if stream isn't explicitly paused
if(state.flowing!==false)this.resume();}else if(ev==='readable'){if(!state.endEmitted&&!state.readableListening){state.readableListening=state.needReadable=true;state.flowing=false;state.emittedReadable=false;debug('on readable',state.length,state.reading);if(state.length){emitReadable(this);}else if(!state.reading){process.nextTick(nReadingNextTick,this);}}}return res;};Readable.prototype.addListener=Readable.prototype.on;Readable.prototype.removeListener=function(ev,fn){var res=Stream.prototype.removeListener.call(this,ev,fn);if(ev==='readable'){// We need to check if there is someone still listening to
// readable and reset the state. However this needs to happen
// after readable has been emitted but before I/O (nextTick) to
// support once('readable', fn) cycles. This means that calling
// resume within the same tick will have no
// effect.
process.nextTick(updateReadableListening,this);}return res;};Readable.prototype.removeAllListeners=function(ev){var res=Stream.prototype.removeAllListeners.apply(this,arguments);if(ev==='readable'||ev===undefined){// We need to check if there is someone still listening to
// readable and reset the state. However this needs to happen
// after readable has been emitted but before I/O (nextTick) to
// support once('readable', fn) cycles. This means that calling
// resume within the same tick will have no
// effect.
process.nextTick(updateReadableListening,this);}return res;};function updateReadableListening(self){var state=self._readableState;state.readableListening=self.listenerCount('readable')>0;if(state.resumeScheduled&&!state.paused){// flowing needs to be set to true now, otherwise
// the upcoming resume will not flow.
state.flowing=true;// crude way to check if we should resume
}else if(self.listenerCount('data')>0){self.resume();}}function nReadingNextTick(self){debug('readable nexttick read 0');self.read(0);}// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume=function(){var state=this._readableState;if(!state.flowing){debug('resume');// we flow only if there is no one listening
// for readable, but we still have to call
// resume()
state.flowing=!state.readableListening;resume(this,state);}state.paused=false;return this;};function resume(stream,state){if(!state.resumeScheduled){state.resumeScheduled=true;process.nextTick(resume_,stream,state);}}function resume_(stream,state){debug('resume',state.reading);if(!state.reading){stream.read(0);}state.resumeScheduled=false;stream.emit('resume');flow(stream);if(state.flowing&&!state.reading)stream.read(0);}Readable.prototype.pause=function(){debug('call pause flowing=%j',this._readableState.flowing);if(this._readableState.flowing!==false){debug('pause');this._readableState.flowing=false;this.emit('pause');}this._readableState.paused=true;return this;};function flow(stream){var state=stream._readableState;debug('flow',state.flowing);while(state.flowing&&stream.read()!==null);}// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap=function(stream){var _this=this;var state=this._readableState;var paused=false;stream.on('end',function(){debug('wrapped end');if(state.decoder&&!state.ended){var chunk=state.decoder.end();if(chunk&&chunk.length)_this.push(chunk);}_this.push(null);});stream.on('data',function(chunk){debug('wrapped data');if(state.decoder)chunk=state.decoder.write(chunk);// don't skip over falsy values in objectMode
if(state.objectMode&&(chunk===null||chunk===undefined))return;else if(!state.objectMode&&(!chunk||!chunk.length))return;var ret=_this.push(chunk);if(!ret){paused=true;stream.pause();}});// proxy all the other methods.
// important when wrapping filters and duplexes.
for(var i in stream){if(this[i]===undefined&&typeof stream[i]==='function'){this[i]=function methodWrap(method){return function methodWrapReturnFunction(){return stream[method].apply(stream,arguments);};}(i);}}// proxy certain important events.
for(var n=0;n<kProxyEvents.length;n++){stream.on(kProxyEvents[n],this.emit.bind(this,kProxyEvents[n]));}// when we try to consume some more bytes, simply unpause the
// underlying stream.
this._read=function(n){debug('wrapped _read',n);if(paused){paused=false;stream.resume();}};return this;};if(typeof Symbol==='function'){Readable.prototype[Symbol.asyncIterator]=function(){if(createReadableStreamAsyncIterator===undefined){createReadableStreamAsyncIterator=require('./internal/streams/async_iterator');}return createReadableStreamAsyncIterator(this);};}Object.defineProperty(Readable.prototype,'readableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.highWaterMark;}});Object.defineProperty(Readable.prototype,'readableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState&&this._readableState.buffer;}});Object.defineProperty(Readable.prototype,'readableFlowing',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.flowing;},set:function set(state){if(this._readableState){this._readableState.flowing=state;}}});// exposed for testing purposes only.
Readable._fromList=fromList;Object.defineProperty(Readable.prototype,'readableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.length;}});// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n,state){// nothing buffered
if(state.length===0)return null;var ret;if(state.objectMode)ret=state.buffer.shift();else if(!n||n>=state.length){// read it all, truncate the list
if(state.decoder)ret=state.buffer.join('');else if(state.buffer.length===1)ret=state.buffer.first();else ret=state.buffer.concat(state.length);state.buffer.clear();}else{// read part of list
ret=state.buffer.consume(n,state.decoder);}return ret;}function endReadable(stream){var state=stream._readableState;debug('endReadable',state.endEmitted);if(!state.endEmitted){state.ended=true;process.nextTick(endReadableNT,state,stream);}}function endReadableNT(state,stream){debug('endReadableNT',state.endEmitted,state.length);// Check that we didn't get one last unshift.
if(!state.endEmitted&&state.length===0){state.endEmitted=true;stream.readable=false;stream.emit('end');if(state.autoDestroy){// In case of duplex streams we need a way to detect
// if the writable side is ready for autoDestroy as well
var wState=stream._writableState;if(!wState||wState.autoDestroy&&wState.finished){stream.destroy();}}}}if(typeof Symbol==='function'){Readable.from=function(iterable,opts){if(from===undefined){from=require('./internal/streams/from');}return from(Readable,iterable,opts);};}function indexOf(xs,x){for(var i=0,l=xs.length;i<l;i++){if(xs[i]===x)return i;}return-1;}}).call(this);}).call(this,require('_process'),typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"../errors":168,"./_stream_duplex":169,"./internal/streams/async_iterator":174,"./internal/streams/buffer_list":175,"./internal/streams/destroy":176,"./internal/streams/from":178,"./internal/streams/state":180,"./internal/streams/stream":181,"_process":147,"buffer":20,"events":50,"inherits":112,"string_decoder/":183,"util":18}],172:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';module.exports=Transform;var _require$codes=require('../errors').codes,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=_require$codes.ERR_MULTIPLE_CALLBACK,ERR_TRANSFORM_ALREADY_TRANSFORMING=_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,ERR_TRANSFORM_WITH_LENGTH_0=_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;var Duplex=require('./_stream_duplex');require('inherits')(Transform,Duplex);function afterTransform(er,data){var ts=this._transformState;ts.transforming=false;var cb=ts.writecb;if(cb===null){return this.emit('error',new ERR_MULTIPLE_CALLBACK());}ts.writechunk=null;ts.writecb=null;if(data!=null)// single equals check for both `null` and `undefined`
this.push(data);cb(er);var rs=this._readableState;rs.reading=false;if(rs.needReadable||rs.length<rs.highWaterMark){this._read(rs.highWaterMark);}}function Transform(options){if(!(this instanceof Transform))return new Transform(options);Duplex.call(this,options);this._transformState={afterTransform:afterTransform.bind(this),needTransform:false,transforming:false,writecb:null,writechunk:null,writeencoding:null};// start out asking for a readable event once data is transformed.
this._readableState.needReadable=true;// we have implemented the _read method, and done the other things
// that Readable wants before the first _read call, so unset the
// sync guard flag.
this._readableState.sync=false;if(options){if(typeof options.transform==='function')this._transform=options.transform;if(typeof options.flush==='function')this._flush=options.flush;}// When the writable side finishes, then flush out anything remaining.
this.on('prefinish',prefinish);}function prefinish(){var _this=this;if(typeof this._flush==='function'&&!this._readableState.destroyed){this._flush(function(er,data){done(_this,er,data);});}else{done(this,null,null);}}Transform.prototype.push=function(chunk,encoding){this._transformState.needTransform=false;return Duplex.prototype.push.call(this,chunk,encoding);};// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));};Transform.prototype._write=function(chunk,encoding,cb){var ts=this._transformState;ts.writecb=cb;ts.writechunk=chunk;ts.writeencoding=encoding;if(!ts.transforming){var rs=this._readableState;if(ts.needTransform||rs.needReadable||rs.length<rs.highWaterMark)this._read(rs.highWaterMark);}};// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read=function(n){var ts=this._transformState;if(ts.writechunk!==null&&!ts.transforming){ts.transforming=true;this._transform(ts.writechunk,ts.writeencoding,ts.afterTransform);}else{// mark that we need a transform, so that any data that comes in
// will get processed, now that we've asked for it.
ts.needTransform=true;}};Transform.prototype._destroy=function(err,cb){Duplex.prototype._destroy.call(this,err,function(err2){cb(err2);});};function done(stream,er,data){if(er)return stream.emit('error',er);if(data!=null)// single equals check for both `null` and `undefined`
stream.push(data);// TODO(BridgeAR): Write a test for these two error cases
// if there's nothing in the write buffer, then that means
// that nothing more will ever be provided
if(stream._writableState.length)throw new ERR_TRANSFORM_WITH_LENGTH_0();if(stream._transformState.transforming)throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();return stream.push(null);}},{"../errors":168,"./_stream_duplex":169,"inherits":112}],173:[function(require,module,exports){(function(process,global){(function(){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';module.exports=Writable;/* <replacement> */function WriteReq(chunk,encoding,cb){this.chunk=chunk;this.encoding=encoding;this.callback=cb;this.next=null;}// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state){var _this=this;this.next=null;this.entry=null;this.finish=function(){onCorkedFinish(_this,state);};}/* </replacement> *//*<replacement>*/var Duplex;/*</replacement>*/Writable.WritableState=WritableState;/*<replacement>*/var internalUtil={deprecate:require('util-deprecate')};/*</replacement>*//*<replacement>*/var Stream=require('./internal/streams/stream');/*</replacement>*/var Buffer=require('buffer').Buffer;var OurUint8Array=(typeof global!=='undefined'?global:typeof window!=='undefined'?window:typeof self!=='undefined'?self:{}).Uint8Array||function(){};function _uint8ArrayToBuffer(chunk){return Buffer.from(chunk);}function _isUint8Array(obj){return Buffer.isBuffer(obj)||obj instanceof OurUint8Array;}var destroyImpl=require('./internal/streams/destroy');var _require=require('./internal/streams/state'),getHighWaterMark=_require.getHighWaterMark;var _require$codes=require('../errors').codes,ERR_INVALID_ARG_TYPE=_require$codes.ERR_INVALID_ARG_TYPE,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=_require$codes.ERR_MULTIPLE_CALLBACK,ERR_STREAM_CANNOT_PIPE=_require$codes.ERR_STREAM_CANNOT_PIPE,ERR_STREAM_DESTROYED=_require$codes.ERR_STREAM_DESTROYED,ERR_STREAM_NULL_VALUES=_require$codes.ERR_STREAM_NULL_VALUES,ERR_STREAM_WRITE_AFTER_END=_require$codes.ERR_STREAM_WRITE_AFTER_END,ERR_UNKNOWN_ENCODING=_require$codes.ERR_UNKNOWN_ENCODING;var errorOrDestroy=destroyImpl.errorOrDestroy;require('inherits')(Writable,Stream);function nop(){}function WritableState(options,stream,isDuplex){Duplex=Duplex||require('./_stream_duplex');options=options||{};// Duplex streams are both readable and writable, but share
// the same options object.
// However, some cases require setting options to different
// values for the readable and the writable sides of the duplex stream,
// e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
if(typeof isDuplex!=='boolean')isDuplex=stream instanceof Duplex;// object stream flag to indicate whether or not this stream
// contains buffers or objects.
this.objectMode=!!options.objectMode;if(isDuplex)this.objectMode=this.objectMode||!!options.writableObjectMode;// the point at which write() starts returning false
// Note: 0 is a valid value, means that we always return false if
// the entire buffer is not flushed immediately on write()
this.highWaterMark=getHighWaterMark(this,options,'writableHighWaterMark',isDuplex);// if _final has been called
this.finalCalled=false;// drain event flag.
this.needDrain=false;// at the start of calling end()
this.ending=false;// when end() has been called, and returned
this.ended=false;// when 'finish' is emitted
this.finished=false;// has it been destroyed
this.destroyed=false;// should we decode strings into buffers before passing to _write?
// this is here so that some node-core streams can optimize string
// handling at a lower level.
var noDecode=options.decodeStrings===false;this.decodeStrings=!noDecode;// Crypto is kind of old and crusty.  Historically, its default string
// encoding is 'binary' so we have to make this configurable.
// Everything else in the universe uses 'utf8', though.
this.defaultEncoding=options.defaultEncoding||'utf8';// not an actual buffer we keep track of, but a measurement
// of how much we're waiting to get pushed to some underlying
// socket or file.
this.length=0;// a flag to see when we're in the middle of a write.
this.writing=false;// when true all writes will be buffered until .uncork() call
this.corked=0;// a flag to be able to tell if the onwrite cb is called immediately,
// or on a later tick.  We set this to true at first, because any
// actions that shouldn't happen until "later" should generally also
// not happen before the first write call.
this.sync=true;// a flag to know if we're processing previously buffered items, which
// may call the _write() callback in the same tick, so that we don't
// end up in an overlapped onwrite situation.
this.bufferProcessing=false;// the callback that's passed to _write(chunk,cb)
this.onwrite=function(er){onwrite(stream,er);};// the callback that the user supplies to write(chunk,encoding,cb)
this.writecb=null;// the amount that is being written when _write is called.
this.writelen=0;this.bufferedRequest=null;this.lastBufferedRequest=null;// number of pending user-supplied write callbacks
// this must be 0 before 'finish' can be emitted
this.pendingcb=0;// emit prefinish if the only thing we're waiting for is _write cbs
// This is relevant for synchronous Transform streams
this.prefinished=false;// True if the error was already emitted and should not be thrown again
this.errorEmitted=false;// Should close be emitted on destroy. Defaults to true.
this.emitClose=options.emitClose!==false;// Should .destroy() be called after 'finish' (and potentially 'end')
this.autoDestroy=!!options.autoDestroy;// count buffered requests
this.bufferedRequestCount=0;// allocate the first CorkedRequest, there is always
// one allocated and free to use, and we maintain at most two
this.corkedRequestsFree=new CorkedRequest(this);}WritableState.prototype.getBuffer=function getBuffer(){var current=this.bufferedRequest;var out=[];while(current){out.push(current);current=current.next;}return out;};(function(){try{Object.defineProperty(WritableState.prototype,'buffer',{get:internalUtil.deprecate(function writableStateBufferGetter(){return this.getBuffer();},'_writableState.buffer is deprecated. Use _writableState.getBuffer '+'instead.','DEP0003')});}catch(_){}})();// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;if(typeof Symbol==='function'&&Symbol.hasInstance&&typeof Function.prototype[Symbol.hasInstance]==='function'){realHasInstance=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:function value(object){if(realHasInstance.call(this,object))return true;if(this!==Writable)return false;return object&&object._writableState instanceof WritableState;}});}else{realHasInstance=function realHasInstance(object){return object instanceof this;};}function Writable(options){Duplex=Duplex||require('./_stream_duplex');// Writable ctor is applied to Duplexes, too.
// `realHasInstance` is necessary because using plain `instanceof`
// would return false, as no `_writableState` property is attached.
// Trying to use the custom `instanceof` for Writable here will also break the
// Node.js LazyTransform implementation, which has a non-trivial getter for
// `_writableState` that would lead to infinite recursion.
// Checking for a Stream.Duplex instance is faster here instead of inside
// the WritableState constructor, at least with V8 6.5
var isDuplex=this instanceof Duplex;if(!isDuplex&&!realHasInstance.call(Writable,this))return new Writable(options);this._writableState=new WritableState(options,this,isDuplex);// legacy.
this.writable=true;if(options){if(typeof options.write==='function')this._write=options.write;if(typeof options.writev==='function')this._writev=options.writev;if(typeof options.destroy==='function')this._destroy=options.destroy;if(typeof options["final"]==='function')this._final=options["final"];}Stream.call(this);}// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe=function(){errorOrDestroy(this,new ERR_STREAM_CANNOT_PIPE());};function writeAfterEnd(stream,cb){var er=new ERR_STREAM_WRITE_AFTER_END();// TODO: defer error events consistently everywhere, not just the cb
errorOrDestroy(stream,er);process.nextTick(cb,er);}// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream,state,chunk,cb){var er;if(chunk===null){er=new ERR_STREAM_NULL_VALUES();}else if(typeof chunk!=='string'&&!state.objectMode){er=new ERR_INVALID_ARG_TYPE('chunk',['string','Buffer'],chunk);}if(er){errorOrDestroy(stream,er);process.nextTick(cb,er);return false;}return true;}Writable.prototype.write=function(chunk,encoding,cb){var state=this._writableState;var ret=false;var isBuf=!state.objectMode&&_isUint8Array(chunk);if(isBuf&&!Buffer.isBuffer(chunk)){chunk=_uint8ArrayToBuffer(chunk);}if(typeof encoding==='function'){cb=encoding;encoding=null;}if(isBuf)encoding='buffer';else if(!encoding)encoding=state.defaultEncoding;if(typeof cb!=='function')cb=nop;if(state.ending)writeAfterEnd(this,cb);else if(isBuf||validChunk(this,state,chunk,cb)){state.pendingcb++;ret=writeOrBuffer(this,state,isBuf,chunk,encoding,cb);}return ret;};Writable.prototype.cork=function(){this._writableState.corked++;};Writable.prototype.uncork=function(){var state=this._writableState;if(state.corked){state.corked--;if(!state.writing&&!state.corked&&!state.bufferProcessing&&state.bufferedRequest)clearBuffer(this,state);}};Writable.prototype.setDefaultEncoding=function setDefaultEncoding(encoding){// node::ParseEncoding() requires lower case.
if(typeof encoding==='string')encoding=encoding.toLowerCase();if(!(['hex','utf8','utf-8','ascii','binary','base64','ucs2','ucs-2','utf16le','utf-16le','raw'].indexOf((encoding+'').toLowerCase())>-1))throw new ERR_UNKNOWN_ENCODING(encoding);this._writableState.defaultEncoding=encoding;return this;};Object.defineProperty(Writable.prototype,'writableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer();}});function decodeChunk(state,chunk,encoding){if(!state.objectMode&&state.decodeStrings!==false&&typeof chunk==='string'){chunk=Buffer.from(chunk,encoding);}return chunk;}Object.defineProperty(Writable.prototype,'writableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.highWaterMark;}});// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream,state,isBuf,chunk,encoding,cb){if(!isBuf){var newChunk=decodeChunk(state,chunk,encoding);if(chunk!==newChunk){isBuf=true;encoding='buffer';chunk=newChunk;}}var len=state.objectMode?1:chunk.length;state.length+=len;var ret=state.length<state.highWaterMark;// we must ensure that previous needDrain will not be reset to false.
if(!ret)state.needDrain=true;if(state.writing||state.corked){var last=state.lastBufferedRequest;state.lastBufferedRequest={chunk:chunk,encoding:encoding,isBuf:isBuf,callback:cb,next:null};if(last){last.next=state.lastBufferedRequest;}else{state.bufferedRequest=state.lastBufferedRequest;}state.bufferedRequestCount+=1;}else{doWrite(stream,state,false,len,chunk,encoding,cb);}return ret;}function doWrite(stream,state,writev,len,chunk,encoding,cb){state.writelen=len;state.writecb=cb;state.writing=true;state.sync=true;if(state.destroyed)state.onwrite(new ERR_STREAM_DESTROYED('write'));else if(writev)stream._writev(chunk,state.onwrite);else stream._write(chunk,encoding,state.onwrite);state.sync=false;}function onwriteError(stream,state,sync,er,cb){--state.pendingcb;if(sync){// defer the callback if we are being called synchronously
// to avoid piling up things on the stack
process.nextTick(cb,er);// this can emit finish, and it will always happen
// after error
process.nextTick(finishMaybe,stream,state);stream._writableState.errorEmitted=true;errorOrDestroy(stream,er);}else{// the caller expect this to happen before if
// it is async
cb(er);stream._writableState.errorEmitted=true;errorOrDestroy(stream,er);// this can emit finish, but finish must
// always follow error
finishMaybe(stream,state);}}function onwriteStateUpdate(state){state.writing=false;state.writecb=null;state.length-=state.writelen;state.writelen=0;}function onwrite(stream,er){var state=stream._writableState;var sync=state.sync;var cb=state.writecb;if(typeof cb!=='function')throw new ERR_MULTIPLE_CALLBACK();onwriteStateUpdate(state);if(er)onwriteError(stream,state,sync,er,cb);else{// Check if we're actually ready to finish, but don't emit yet
var finished=needFinish(state)||stream.destroyed;if(!finished&&!state.corked&&!state.bufferProcessing&&state.bufferedRequest){clearBuffer(stream,state);}if(sync){process.nextTick(afterWrite,stream,state,finished,cb);}else{afterWrite(stream,state,finished,cb);}}}function afterWrite(stream,state,finished,cb){if(!finished)onwriteDrain(stream,state);state.pendingcb--;cb();finishMaybe(stream,state);}// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream,state){if(state.length===0&&state.needDrain){state.needDrain=false;stream.emit('drain');}}// if there's something in the buffer waiting, then process it
function clearBuffer(stream,state){state.bufferProcessing=true;var entry=state.bufferedRequest;if(stream._writev&&entry&&entry.next){// Fast case, write everything using _writev()
var l=state.bufferedRequestCount;var buffer=new Array(l);var holder=state.corkedRequestsFree;holder.entry=entry;var count=0;var allBuffers=true;while(entry){buffer[count]=entry;if(!entry.isBuf)allBuffers=false;entry=entry.next;count+=1;}buffer.allBuffers=allBuffers;doWrite(stream,state,true,state.length,buffer,'',holder.finish);// doWrite is almost always async, defer these to save a bit of time
// as the hot path ends with doWrite
state.pendingcb++;state.lastBufferedRequest=null;if(holder.next){state.corkedRequestsFree=holder.next;holder.next=null;}else{state.corkedRequestsFree=new CorkedRequest(state);}state.bufferedRequestCount=0;}else{// Slow case, write chunks one-by-one
while(entry){var chunk=entry.chunk;var encoding=entry.encoding;var cb=entry.callback;var len=state.objectMode?1:chunk.length;doWrite(stream,state,false,len,chunk,encoding,cb);entry=entry.next;state.bufferedRequestCount--;// if we didn't call the onwrite immediately, then
// it means that we need to wait until it does.
// also, that means that the chunk and cb are currently
// being processed, so move the buffer counter past them.
if(state.writing){break;}}if(entry===null)state.lastBufferedRequest=null;}state.bufferedRequest=entry;state.bufferProcessing=false;}Writable.prototype._write=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));};Writable.prototype._writev=null;Writable.prototype.end=function(chunk,encoding,cb){var state=this._writableState;if(typeof chunk==='function'){cb=chunk;chunk=null;encoding=null;}else if(typeof encoding==='function'){cb=encoding;encoding=null;}if(chunk!==null&&chunk!==undefined)this.write(chunk,encoding);// .end() fully uncorks
if(state.corked){state.corked=1;this.uncork();}// ignore unnecessary end() calls.
if(!state.ending)endWritable(this,state,cb);return this;};Object.defineProperty(Writable.prototype,'writableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.length;}});function needFinish(state){return state.ending&&state.length===0&&state.bufferedRequest===null&&!state.finished&&!state.writing;}function callFinal(stream,state){stream._final(function(err){state.pendingcb--;if(err){errorOrDestroy(stream,err);}state.prefinished=true;stream.emit('prefinish');finishMaybe(stream,state);});}function prefinish(stream,state){if(!state.prefinished&&!state.finalCalled){if(typeof stream._final==='function'&&!state.destroyed){state.pendingcb++;state.finalCalled=true;process.nextTick(callFinal,stream,state);}else{state.prefinished=true;stream.emit('prefinish');}}}function finishMaybe(stream,state){var need=needFinish(state);if(need){prefinish(stream,state);if(state.pendingcb===0){state.finished=true;stream.emit('finish');if(state.autoDestroy){// In case of duplex streams we need a way to detect
// if the readable side is ready for autoDestroy as well
var rState=stream._readableState;if(!rState||rState.autoDestroy&&rState.endEmitted){stream.destroy();}}}}return need;}function endWritable(stream,state,cb){state.ending=true;finishMaybe(stream,state);if(cb){if(state.finished)process.nextTick(cb);else stream.once('finish',cb);}state.ended=true;stream.writable=false;}function onCorkedFinish(corkReq,state,err){var entry=corkReq.entry;corkReq.entry=null;while(entry){var cb=entry.callback;state.pendingcb--;cb(err);entry=entry.next;}// reuse the free corkReq.
state.corkedRequestsFree.next=corkReq;}Object.defineProperty(Writable.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._writableState===undefined){return false;}return this._writableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(!this._writableState){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._writableState.destroyed=value;}});Writable.prototype.destroy=destroyImpl.destroy;Writable.prototype._undestroy=destroyImpl.undestroy;Writable.prototype._destroy=function(err,cb){cb(err);};}).call(this);}).call(this,require('_process'),typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"../errors":168,"./_stream_duplex":169,"./internal/streams/destroy":176,"./internal/streams/state":180,"./internal/streams/stream":181,"_process":147,"buffer":20,"inherits":112,"util-deprecate":186}],174:[function(require,module,exports){(function(process){(function(){'use strict';var _Object$setPrototypeO;function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return _typeof(key)==="symbol"?key:String(key);}function _toPrimitive(input,hint){if(_typeof(input)!=="object"||input===null)return input;var prim=input[Symbol.toPrimitive];if(prim!==undefined){var res=prim.call(input,hint||"default");if(_typeof(res)!=="object")return res;throw new TypeError("@@toPrimitive must return a primitive value.");}return(hint==="string"?String:Number)(input);}var finished=require('./end-of-stream');var kLastResolve=Symbol('lastResolve');var kLastReject=Symbol('lastReject');var kError=Symbol('error');var kEnded=Symbol('ended');var kLastPromise=Symbol('lastPromise');var kHandlePromise=Symbol('handlePromise');var kStream=Symbol('stream');function createIterResult(value,done){return{value:value,done:done};}function readAndResolve(iter){var resolve=iter[kLastResolve];if(resolve!==null){var data=iter[kStream].read();// we defer if data is null
// we can be expecting either 'end' or
// 'error'
if(data!==null){iter[kLastPromise]=null;iter[kLastResolve]=null;iter[kLastReject]=null;resolve(createIterResult(data,false));}}}function onReadable(iter){// we wait for the next tick, because it might
// emit an error with process.nextTick
process.nextTick(readAndResolve,iter);}function wrapForNext(lastPromise,iter){return function(resolve,reject){lastPromise.then(function(){if(iter[kEnded]){resolve(createIterResult(undefined,true));return;}iter[kHandlePromise](resolve,reject);},reject);};}var AsyncIteratorPrototype=Object.getPrototypeOf(function(){});var ReadableStreamAsyncIteratorPrototype=Object.setPrototypeOf((_Object$setPrototypeO={get stream(){return this[kStream];},next:function next(){var _this=this;// if we have detected an error in the meanwhile
// reject straight away
var error=this[kError];if(error!==null){return Promise.reject(error);}if(this[kEnded]){return Promise.resolve(createIterResult(undefined,true));}if(this[kStream].destroyed){// We need to defer via nextTick because if .destroy(err) is
// called, the error will be emitted via nextTick, and
// we cannot guarantee that there is no error lingering around
// waiting to be emitted.
return new Promise(function(resolve,reject){process.nextTick(function(){if(_this[kError]){reject(_this[kError]);}else{resolve(createIterResult(undefined,true));}});});}// if we have multiple next() calls
// we will wait for the previous Promise to finish
// this logic is optimized to support for await loops,
// where next() is only called once at a time
var lastPromise=this[kLastPromise];var promise;if(lastPromise){promise=new Promise(wrapForNext(lastPromise,this));}else{// fast path needed to support multiple this.push()
// without triggering the next() queue
var data=this[kStream].read();if(data!==null){return Promise.resolve(createIterResult(data,false));}promise=new Promise(this[kHandlePromise]);}this[kLastPromise]=promise;return promise;}},_defineProperty(_Object$setPrototypeO,Symbol.asyncIterator,function(){return this;}),_defineProperty(_Object$setPrototypeO,"return",function _return(){var _this2=this;// destroy(err, cb) is a private API
// we can guarantee we have that here, because we control the
// Readable class this is attached to
return new Promise(function(resolve,reject){_this2[kStream].destroy(null,function(err){if(err){reject(err);return;}resolve(createIterResult(undefined,true));});});}),_Object$setPrototypeO),AsyncIteratorPrototype);var createReadableStreamAsyncIterator=function createReadableStreamAsyncIterator(stream){var _Object$create;var iterator=Object.create(ReadableStreamAsyncIteratorPrototype,(_Object$create={},_defineProperty(_Object$create,kStream,{value:stream,writable:true}),_defineProperty(_Object$create,kLastResolve,{value:null,writable:true}),_defineProperty(_Object$create,kLastReject,{value:null,writable:true}),_defineProperty(_Object$create,kError,{value:null,writable:true}),_defineProperty(_Object$create,kEnded,{value:stream._readableState.endEmitted,writable:true}),_defineProperty(_Object$create,kHandlePromise,{value:function value(resolve,reject){var data=iterator[kStream].read();if(data){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;resolve(createIterResult(data,false));}else{iterator[kLastResolve]=resolve;iterator[kLastReject]=reject;}},writable:true}),_Object$create));iterator[kLastPromise]=null;finished(stream,function(err){if(err&&err.code!=='ERR_STREAM_PREMATURE_CLOSE'){var reject=iterator[kLastReject];// reject if we are waiting for data in the Promise
// returned by next() and store the error
if(reject!==null){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;reject(err);}iterator[kError]=err;return;}var resolve=iterator[kLastResolve];if(resolve!==null){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;resolve(createIterResult(undefined,true));}iterator[kEnded]=true;});stream.on('readable',onReadable.bind(null,iterator));return iterator;};module.exports=createReadableStreamAsyncIterator;}).call(this);}).call(this,require('_process'));},{"./end-of-stream":177,"_process":147}],175:[function(require,module,exports){'use strict';function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,_toPropertyKey(descriptor.key),descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return _typeof(key)==="symbol"?key:String(key);}function _toPrimitive(input,hint){if(_typeof(input)!=="object"||input===null)return input;var prim=input[Symbol.toPrimitive];if(prim!==undefined){var res=prim.call(input,hint||"default");if(_typeof(res)!=="object")return res;throw new TypeError("@@toPrimitive must return a primitive value.");}return(hint==="string"?String:Number)(input);}var _require=require('buffer'),Buffer=_require.Buffer;var _require2=require('util'),inspect=_require2.inspect;var custom=inspect&&inspect.custom||'inspect';function copyBuffer(src,target,offset){Buffer.prototype.copy.call(src,target,offset);}module.exports=/*#__PURE__*/function(){function BufferList(){_classCallCheck(this,BufferList);this.head=null;this.tail=null;this.length=0;}_createClass(BufferList,[{key:"push",value:function push(v){var entry={data:v,next:null};if(this.length>0)this.tail.next=entry;else this.head=entry;this.tail=entry;++this.length;}},{key:"unshift",value:function unshift(v){var entry={data:v,next:this.head};if(this.length===0)this.tail=entry;this.head=entry;++this.length;}},{key:"shift",value:function shift(){if(this.length===0)return;var ret=this.head.data;if(this.length===1)this.head=this.tail=null;else this.head=this.head.next;--this.length;return ret;}},{key:"clear",value:function clear(){this.head=this.tail=null;this.length=0;}},{key:"join",value:function join(s){if(this.length===0)return'';var p=this.head;var ret=''+p.data;while(p=p.next)ret+=s+p.data;return ret;}},{key:"concat",value:function concat(n){if(this.length===0)return Buffer.alloc(0);var ret=Buffer.allocUnsafe(n>>>0);var p=this.head;var i=0;while(p){copyBuffer(p.data,ret,i);i+=p.data.length;p=p.next;}return ret;}// Consumes a specified amount of bytes or characters from the buffered data.
},{key:"consume",value:function consume(n,hasStrings){var ret;if(n<this.head.data.length){// `slice` is the same for buffers and strings.
ret=this.head.data.slice(0,n);this.head.data=this.head.data.slice(n);}else if(n===this.head.data.length){// First chunk is a perfect match.
ret=this.shift();}else{// Result spans more than one buffer.
ret=hasStrings?this._getString(n):this._getBuffer(n);}return ret;}},{key:"first",value:function first(){return this.head.data;}// Consumes a specified amount of characters from the buffered data.
},{key:"_getString",value:function _getString(n){var p=this.head;var c=1;var ret=p.data;n-=ret.length;while(p=p.next){var str=p.data;var nb=n>str.length?str.length:n;if(nb===str.length)ret+=str;else ret+=str.slice(0,n);n-=nb;if(n===0){if(nb===str.length){++c;if(p.next)this.head=p.next;else this.head=this.tail=null;}else{this.head=p;p.data=str.slice(nb);}break;}++c;}this.length-=c;return ret;}// Consumes a specified amount of bytes from the buffered data.
},{key:"_getBuffer",value:function _getBuffer(n){var ret=Buffer.allocUnsafe(n);var p=this.head;var c=1;p.data.copy(ret);n-=p.data.length;while(p=p.next){var buf=p.data;var nb=n>buf.length?buf.length:n;buf.copy(ret,ret.length-n,0,nb);n-=nb;if(n===0){if(nb===buf.length){++c;if(p.next)this.head=p.next;else this.head=this.tail=null;}else{this.head=p;p.data=buf.slice(nb);}break;}++c;}this.length-=c;return ret;}// Make sure the linked list only shows the minimal necessary information.
},{key:custom,value:function value(_,options){return inspect(this,_objectSpread(_objectSpread({},options),{},{// Only inspect one level.
depth:0,// It should not recurse.
customInspect:false}));}}]);return BufferList;}();},{"buffer":20,"util":18}],176:[function(require,module,exports){(function(process){(function(){'use strict';// undocumented cb() API, needed for core, not for public API
function destroy(err,cb){var _this=this;var readableDestroyed=this._readableState&&this._readableState.destroyed;var writableDestroyed=this._writableState&&this._writableState.destroyed;if(readableDestroyed||writableDestroyed){if(cb){cb(err);}else if(err){if(!this._writableState){process.nextTick(emitErrorNT,this,err);}else if(!this._writableState.errorEmitted){this._writableState.errorEmitted=true;process.nextTick(emitErrorNT,this,err);}}return this;}// we set destroyed to true before firing error callbacks in order
// to make it re-entrance safe in case destroy() is called within callbacks
if(this._readableState){this._readableState.destroyed=true;}// if this is a duplex stream mark the writable part as destroyed as well
if(this._writableState){this._writableState.destroyed=true;}this._destroy(err||null,function(err){if(!cb&&err){if(!_this._writableState){process.nextTick(emitErrorAndCloseNT,_this,err);}else if(!_this._writableState.errorEmitted){_this._writableState.errorEmitted=true;process.nextTick(emitErrorAndCloseNT,_this,err);}else{process.nextTick(emitCloseNT,_this);}}else if(cb){process.nextTick(emitCloseNT,_this);cb(err);}else{process.nextTick(emitCloseNT,_this);}});return this;}function emitErrorAndCloseNT(self,err){emitErrorNT(self,err);emitCloseNT(self);}function emitCloseNT(self){if(self._writableState&&!self._writableState.emitClose)return;if(self._readableState&&!self._readableState.emitClose)return;self.emit('close');}function undestroy(){if(this._readableState){this._readableState.destroyed=false;this._readableState.reading=false;this._readableState.ended=false;this._readableState.endEmitted=false;}if(this._writableState){this._writableState.destroyed=false;this._writableState.ended=false;this._writableState.ending=false;this._writableState.finalCalled=false;this._writableState.prefinished=false;this._writableState.finished=false;this._writableState.errorEmitted=false;}}function emitErrorNT(self,err){self.emit('error',err);}function errorOrDestroy(stream,err){// We have tests that rely on errors being emitted
// in the same tick, so changing this is semver major.
// For now when you opt-in to autoDestroy we allow
// the error to be emitted nextTick. In a future
// semver major update we should change the default to this.
var rState=stream._readableState;var wState=stream._writableState;if(rState&&rState.autoDestroy||wState&&wState.autoDestroy)stream.destroy(err);else stream.emit('error',err);}module.exports={destroy:destroy,undestroy:undestroy,errorOrDestroy:errorOrDestroy};}).call(this);}).call(this,require('_process'));},{"_process":147}],177:[function(require,module,exports){// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';var ERR_STREAM_PREMATURE_CLOSE=require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;function once(callback){var called=false;return function(){if(called)return;called=true;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}callback.apply(this,args);};}function noop(){}function isRequest(stream){return stream.setHeader&&typeof stream.abort==='function';}function eos(stream,opts,callback){if(typeof opts==='function')return eos(stream,null,opts);if(!opts)opts={};callback=once(callback||noop);var readable=opts.readable||opts.readable!==false&&stream.readable;var writable=opts.writable||opts.writable!==false&&stream.writable;var onlegacyfinish=function onlegacyfinish(){if(!stream.writable)onfinish();};var writableEnded=stream._writableState&&stream._writableState.finished;var onfinish=function onfinish(){writable=false;writableEnded=true;if(!readable)callback.call(stream);};var readableEnded=stream._readableState&&stream._readableState.endEmitted;var onend=function onend(){readable=false;readableEnded=true;if(!writable)callback.call(stream);};var onerror=function onerror(err){callback.call(stream,err);};var onclose=function onclose(){var err;if(readable&&!readableEnded){if(!stream._readableState||!stream._readableState.ended)err=new ERR_STREAM_PREMATURE_CLOSE();return callback.call(stream,err);}if(writable&&!writableEnded){if(!stream._writableState||!stream._writableState.ended)err=new ERR_STREAM_PREMATURE_CLOSE();return callback.call(stream,err);}};var onrequest=function onrequest(){stream.req.on('finish',onfinish);};if(isRequest(stream)){stream.on('complete',onfinish);stream.on('abort',onclose);if(stream.req)onrequest();else stream.on('request',onrequest);}else if(writable&&!stream._writableState){// legacy streams
stream.on('end',onlegacyfinish);stream.on('close',onlegacyfinish);}stream.on('end',onend);stream.on('finish',onfinish);if(opts.error!==false)stream.on('error',onerror);stream.on('close',onclose);return function(){stream.removeListener('complete',onfinish);stream.removeListener('abort',onclose);stream.removeListener('request',onrequest);if(stream.req)stream.req.removeListener('finish',onfinish);stream.removeListener('end',onlegacyfinish);stream.removeListener('close',onlegacyfinish);stream.removeListener('finish',onfinish);stream.removeListener('end',onend);stream.removeListener('error',onerror);stream.removeListener('close',onclose);};}module.exports=eos;},{"../../../errors":168}],178:[function(require,module,exports){module.exports=function(){throw new Error('Readable.from is not available in the browser');};},{}],179:[function(require,module,exports){// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';var eos;function once(callback){var called=false;return function(){if(called)return;called=true;callback.apply(void 0,arguments);};}var _require$codes=require('../../../errors').codes,ERR_MISSING_ARGS=_require$codes.ERR_MISSING_ARGS,ERR_STREAM_DESTROYED=_require$codes.ERR_STREAM_DESTROYED;function noop(err){// Rethrow the error if it exists to avoid swallowing it
if(err)throw err;}function isRequest(stream){return stream.setHeader&&typeof stream.abort==='function';}function destroyer(stream,reading,writing,callback){callback=once(callback);var closed=false;stream.on('close',function(){closed=true;});if(eos===undefined)eos=require('./end-of-stream');eos(stream,{readable:reading,writable:writing},function(err){if(err)return callback(err);closed=true;callback();});var destroyed=false;return function(err){if(closed)return;if(destroyed)return;destroyed=true;// request.destroy just do .end - .abort is what we want
if(isRequest(stream))return stream.abort();if(typeof stream.destroy==='function')return stream.destroy();callback(err||new ERR_STREAM_DESTROYED('pipe'));};}function call(fn){fn();}function pipe(from,to){return from.pipe(to);}function popCallback(streams){if(!streams.length)return noop;if(typeof streams[streams.length-1]!=='function')return noop;return streams.pop();}function pipeline(){for(var _len=arguments.length,streams=new Array(_len),_key=0;_key<_len;_key++){streams[_key]=arguments[_key];}var callback=popCallback(streams);if(Array.isArray(streams[0]))streams=streams[0];if(streams.length<2){throw new ERR_MISSING_ARGS('streams');}var error;var destroys=streams.map(function(stream,i){var reading=i<streams.length-1;var writing=i>0;return destroyer(stream,reading,writing,function(err){if(!error)error=err;if(err)destroys.forEach(call);if(reading)return;destroys.forEach(call);callback(error);});});return streams.reduce(pipe);}module.exports=pipeline;},{"../../../errors":168,"./end-of-stream":177}],180:[function(require,module,exports){'use strict';var ERR_INVALID_OPT_VALUE=require('../../../errors').codes.ERR_INVALID_OPT_VALUE;function highWaterMarkFrom(options,isDuplex,duplexKey){return options.highWaterMark!=null?options.highWaterMark:isDuplex?options[duplexKey]:null;}function getHighWaterMark(state,options,duplexKey,isDuplex){var hwm=highWaterMarkFrom(options,isDuplex,duplexKey);if(hwm!=null){if(!(isFinite(hwm)&&Math.floor(hwm)===hwm)||hwm<0){var name=isDuplex?duplexKey:'highWaterMark';throw new ERR_INVALID_OPT_VALUE(name,hwm);}return Math.floor(hwm);}// Default value
return state.objectMode?16:16*1024;}module.exports={getHighWaterMark:getHighWaterMark};},{"../../../errors":168}],181:[function(require,module,exports){module.exports=require('events').EventEmitter;},{"events":50}],182:[function(require,module,exports){exports=module.exports=require('./lib/_stream_readable.js');exports.Stream=exports;exports.Readable=exports;exports.Writable=require('./lib/_stream_writable.js');exports.Duplex=require('./lib/_stream_duplex.js');exports.Transform=require('./lib/_stream_transform.js');exports.PassThrough=require('./lib/_stream_passthrough.js');exports.finished=require('./lib/internal/streams/end-of-stream.js');exports.pipeline=require('./lib/internal/streams/pipeline.js');},{"./lib/_stream_duplex.js":169,"./lib/_stream_passthrough.js":170,"./lib/_stream_readable.js":171,"./lib/_stream_transform.js":172,"./lib/_stream_writable.js":173,"./lib/internal/streams/end-of-stream.js":177,"./lib/internal/streams/pipeline.js":179}],183:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';/*<replacement>*/var Buffer=require('safe-buffer').Buffer;/*</replacement>*/var isEncoding=Buffer.isEncoding||function(encoding){encoding=''+encoding;switch(encoding&&encoding.toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':case'raw':return true;default:return false;}};function _normalizeEncoding(enc){if(!enc)return'utf8';var retried;while(true){switch(enc){case'utf8':case'utf-8':return'utf8';case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return'utf16le';case'latin1':case'binary':return'latin1';case'base64':case'ascii':case'hex':return enc;default:if(retried)return;// undefined
enc=(''+enc).toLowerCase();retried=true;}}};// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc){var nenc=_normalizeEncoding(enc);if(typeof nenc!=='string'&&(Buffer.isEncoding===isEncoding||!isEncoding(enc)))throw new Error('Unknown encoding: '+enc);return nenc||enc;}// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder=StringDecoder;function StringDecoder(encoding){this.encoding=normalizeEncoding(encoding);var nb;switch(this.encoding){case'utf16le':this.text=utf16Text;this.end=utf16End;nb=4;break;case'utf8':this.fillLast=utf8FillLast;nb=4;break;case'base64':this.text=base64Text;this.end=base64End;nb=3;break;default:this.write=simpleWrite;this.end=simpleEnd;return;}this.lastNeed=0;this.lastTotal=0;this.lastChar=Buffer.allocUnsafe(nb);}StringDecoder.prototype.write=function(buf){if(buf.length===0)return'';var r;var i;if(this.lastNeed){r=this.fillLast(buf);if(r===undefined)return'';i=this.lastNeed;this.lastNeed=0;}else{i=0;}if(i<buf.length)return r?r+this.text(buf,i):this.text(buf,i);return r||'';};StringDecoder.prototype.end=utf8End;// Returns only complete characters in a Buffer
StringDecoder.prototype.text=utf8Text;// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast=function(buf){if(this.lastNeed<=buf.length){buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,buf.length);this.lastNeed-=buf.length;};// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(_byte){if(_byte<=0x7F)return 0;else if(_byte>>5===0x06)return 2;else if(_byte>>4===0x0E)return 3;else if(_byte>>3===0x1E)return 4;return _byte>>6===0x02?-1:-2;}// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self,buf,i){var j=buf.length-1;if(j<i)return 0;var nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-1;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-2;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0){if(nb===2)nb=0;else self.lastNeed=nb-3;}return nb;}return 0;}// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self,buf,p){if((buf[0]&0xC0)!==0x80){self.lastNeed=0;return"\uFFFD";}if(self.lastNeed>1&&buf.length>1){if((buf[1]&0xC0)!==0x80){self.lastNeed=1;return"\uFFFD";}if(self.lastNeed>2&&buf.length>2){if((buf[2]&0xC0)!==0x80){self.lastNeed=2;return"\uFFFD";}}}}// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf){var p=this.lastTotal-this.lastNeed;var r=utf8CheckExtraBytes(this,buf,p);if(r!==undefined)return r;if(this.lastNeed<=buf.length){buf.copy(this.lastChar,p,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,p,0,buf.length);this.lastNeed-=buf.length;}// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf,i){var total=utf8CheckIncomplete(this,buf,i);if(!this.lastNeed)return buf.toString('utf8',i);this.lastTotal=total;var end=buf.length-(total-this.lastNeed);buf.copy(this.lastChar,0,end);return buf.toString('utf8',i,end);}// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+"\uFFFD";return r;}// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf,i){if((buf.length-i)%2===0){var r=buf.toString('utf16le',i);if(r){var c=r.charCodeAt(r.length-1);if(c>=0xD800&&c<=0xDBFF){this.lastNeed=2;this.lastTotal=4;this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];return r.slice(0,-1);}}return r;}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=buf[buf.length-1];return buf.toString('utf16le',i,buf.length-1);}// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed){var end=this.lastTotal-this.lastNeed;return r+this.lastChar.toString('utf16le',0,end);}return r;}function base64Text(buf,i){var n=(buf.length-i)%3;if(n===0)return buf.toString('base64',i);this.lastNeed=3-n;this.lastTotal=3;if(n===1){this.lastChar[0]=buf[buf.length-1];}else{this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];}return buf.toString('base64',i,buf.length-n);}function base64End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+this.lastChar.toString('base64',0,3-this.lastNeed);return r;}// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf){return buf.toString(this.encoding);}function simpleEnd(buf){return buf&&buf.length?this.write(buf):'';}},{"safe-buffer":157}],184:[function(require,module,exports){(function(setImmediate,clearImmediate){(function(){var nextTick=require('process/browser.js').nextTick;var apply=Function.prototype.apply;var slice=Array.prototype.slice;var immediateIds={};var nextImmediateId=0;// DOM APIs, for completeness
exports.setTimeout=function(){return new Timeout(apply.call(setTimeout,window,arguments),clearTimeout);};exports.setInterval=function(){return new Timeout(apply.call(setInterval,window,arguments),clearInterval);};exports.clearTimeout=exports.clearInterval=function(timeout){timeout.close();};function Timeout(id,clearFn){this._id=id;this._clearFn=clearFn;}Timeout.prototype.unref=Timeout.prototype.ref=function(){};Timeout.prototype.close=function(){this._clearFn.call(window,this._id);};// Does not start the time, just sets up the members needed.
exports.enroll=function(item,msecs){clearTimeout(item._idleTimeoutId);item._idleTimeout=msecs;};exports.unenroll=function(item){clearTimeout(item._idleTimeoutId);item._idleTimeout=-1;};exports._unrefActive=exports.active=function(item){clearTimeout(item._idleTimeoutId);var msecs=item._idleTimeout;if(msecs>=0){item._idleTimeoutId=setTimeout(function onTimeout(){if(item._onTimeout)item._onTimeout();},msecs);}};// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate=typeof setImmediate==="function"?setImmediate:function(fn){var id=nextImmediateId++;var args=arguments.length<2?false:slice.call(arguments,1);immediateIds[id]=true;nextTick(function onNextTick(){if(immediateIds[id]){// fn.call() is faster so we optimize for the common use-case
// @see http://jsperf.com/call-apply-segu
if(args){fn.apply(null,args);}else{fn.call(null);}// Prevent ids from leaking
exports.clearImmediate(id);}});return id;};exports.clearImmediate=typeof clearImmediate==="function"?clearImmediate:function(id){delete immediateIds[id];};}).call(this);}).call(this,require("timers").setImmediate,require("timers").clearImmediate);},{"process/browser.js":147,"timers":184}],185:[function(require,module,exports){/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */'use strict';var punycode=require('punycode/');function Url(){this.protocol=null;this.slashes=null;this.auth=null;this.host=null;this.port=null;this.hostname=null;this.hash=null;this.search=null;this.query=null;this.pathname=null;this.path=null;this.href=null;}// Reference: RFC 3986, RFC 1808, RFC 2396
/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,// Special case for a simple path URL
simplePathPattern=/^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,/*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */delims=['<','>','"','`',' ','\r','\n','\t'],// RFC 2396: characters not allowed for various reasons.
unwise=['{','}','|','\\','^','`'].concat(delims),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape=['\''].concat(unwise),/*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */nonHostChars=['%','/','?',';','#'].concat(autoEscape),hostEndingChars=['/','?','#'],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol={javascript:true,'javascript:':true},// protocols that never have a hostname.
hostlessProtocol={javascript:true,'javascript:':true},// protocols that always contain a // bit.
slashedProtocol={http:true,https:true,ftp:true,gopher:true,file:true,'http:':true,'https:':true,'ftp:':true,'gopher:':true,'file:':true},querystring=require('qs');function urlParse(url,parseQueryString,slashesDenoteHost){if(url&&_typeof(url)==='object'&&url instanceof Url){return url;}var u=new Url();u.parse(url,parseQueryString,slashesDenoteHost);return u;}Url.prototype.parse=function(url,parseQueryString,slashesDenoteHost){if(typeof url!=='string'){throw new TypeError("Parameter 'url' must be a string, not "+_typeof(url));}/*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */var queryIndex=url.indexOf('?'),splitter=queryIndex!==-1&&queryIndex<url.indexOf('#')?'?':'#',uSplit=url.split(splitter),slashRegex=/\\/g;uSplit[0]=uSplit[0].replace(slashRegex,'/');url=uSplit.join(splitter);var rest=url;/*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */rest=rest.trim();if(!slashesDenoteHost&&url.split('#').length===1){// Try fast path regexp
var simplePath=simplePathPattern.exec(rest);if(simplePath){this.path=rest;this.href=rest;this.pathname=simplePath[1];if(simplePath[2]){this.search=simplePath[2];if(parseQueryString){this.query=querystring.parse(this.search.substr(1));}else{this.query=this.search.substr(1);}}else if(parseQueryString){this.search='';this.query={};}return this;}}var proto=protocolPattern.exec(rest);if(proto){proto=proto[0];var lowerProto=proto.toLowerCase();this.protocol=lowerProto;rest=rest.substr(proto.length);}/*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */if(slashesDenoteHost||proto||rest.match(/^\/\/[^@/]+@[^@/]+/)){var slashes=rest.substr(0,2)==='//';if(slashes&&!(proto&&hostlessProtocol[proto])){rest=rest.substr(2);this.slashes=true;}}if(!hostlessProtocol[proto]&&(slashes||proto&&!slashedProtocol[proto])){/*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     *//*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */// find the first instance of any hostEndingChars
var hostEnd=-1;for(var i=0;i<hostEndingChars.length;i++){var hec=rest.indexOf(hostEndingChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd)){hostEnd=hec;}}/*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */var auth,atSign;if(hostEnd===-1){// atSign can be anywhere.
atSign=rest.lastIndexOf('@');}else{/*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */atSign=rest.lastIndexOf('@',hostEnd);}/*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */if(atSign!==-1){auth=rest.slice(0,atSign);rest=rest.slice(atSign+1);this.auth=decodeURIComponent(auth);}// the host is the remaining to the left of the first non-host char
hostEnd=-1;for(var i=0;i<nonHostChars.length;i++){var hec=rest.indexOf(nonHostChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd)){hostEnd=hec;}}// if we still have not hit it, then the entire thing is a host.
if(hostEnd===-1){hostEnd=rest.length;}this.host=rest.slice(0,hostEnd);rest=rest.slice(hostEnd);// pull out port.
this.parseHost();/*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */this.hostname=this.hostname||'';/*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */var ipv6Hostname=this.hostname[0]==='['&&this.hostname[this.hostname.length-1]===']';// validate a little.
if(!ipv6Hostname){var hostparts=this.hostname.split(/\./);for(var i=0,l=hostparts.length;i<l;i++){var part=hostparts[i];if(!part){continue;}if(!part.match(hostnamePartPattern)){var newpart='';for(var j=0,k=part.length;j<k;j++){if(part.charCodeAt(j)>127){/*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */newpart+='x';}else{newpart+=part[j];}}// we test again with ASCII char only
if(!newpart.match(hostnamePartPattern)){var validParts=hostparts.slice(0,i);var notHost=hostparts.slice(i+1);var bit=part.match(hostnamePartStart);if(bit){validParts.push(bit[1]);notHost.unshift(bit[2]);}if(notHost.length){rest='/'+notHost.join('.')+rest;}this.hostname=validParts.join('.');break;}}}}if(this.hostname.length>hostnameMaxLen){this.hostname='';}else{// hostnames are always lower case.
this.hostname=this.hostname.toLowerCase();}if(!ipv6Hostname){/*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */this.hostname=punycode.toASCII(this.hostname);}var p=this.port?':'+this.port:'';var h=this.hostname||'';this.host=h+p;this.href+=this.host;/*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */if(ipv6Hostname){this.hostname=this.hostname.substr(1,this.hostname.length-2);if(rest[0]!=='/'){rest='/'+rest;}}}/*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */if(!unsafeProtocol[lowerProto]){/*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */for(var i=0,l=autoEscape.length;i<l;i++){var ae=autoEscape[i];if(rest.indexOf(ae)===-1){continue;}var esc=encodeURIComponent(ae);if(esc===ae){esc=escape(ae);}rest=rest.split(ae).join(esc);}}// chop off from the tail first.
var hash=rest.indexOf('#');if(hash!==-1){// got a fragment string.
this.hash=rest.substr(hash);rest=rest.slice(0,hash);}var qm=rest.indexOf('?');if(qm!==-1){this.search=rest.substr(qm);this.query=rest.substr(qm+1);if(parseQueryString){this.query=querystring.parse(this.query);}rest=rest.slice(0,qm);}else if(parseQueryString){// no query string, but parseQueryString still requested
this.search='';this.query={};}if(rest){this.pathname=rest;}if(slashedProtocol[lowerProto]&&this.hostname&&!this.pathname){this.pathname='/';}// to support http.request
if(this.pathname||this.search){var p=this.pathname||'';var s=this.search||'';this.path=p+s;}// finally, reconstruct the href based on what has been validated.
this.href=this.format();return this;};// format a parsed object into a url string
function urlFormat(obj){/*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */if(typeof obj==='string'){obj=urlParse(obj);}if(!(obj instanceof Url)){return Url.prototype.format.call(obj);}return obj.format();}Url.prototype.format=function(){var auth=this.auth||'';if(auth){auth=encodeURIComponent(auth);auth=auth.replace(/%3A/i,':');auth+='@';}var protocol=this.protocol||'',pathname=this.pathname||'',hash=this.hash||'',host=false,query='';if(this.host){host=auth+this.host;}else if(this.hostname){host=auth+(this.hostname.indexOf(':')===-1?this.hostname:'['+this.hostname+']');if(this.port){host+=':'+this.port;}}if(this.query&&_typeof(this.query)==='object'&&Object.keys(this.query).length){query=querystring.stringify(this.query,{arrayFormat:'repeat',addQueryPrefix:false});}var search=this.search||query&&'?'+query||'';if(protocol&&protocol.substr(-1)!==':'){protocol+=':';}/*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */if(this.slashes||(!protocol||slashedProtocol[protocol])&&host!==false){host='//'+(host||'');if(pathname&&pathname.charAt(0)!=='/'){pathname='/'+pathname;}}else if(!host){host='';}if(hash&&hash.charAt(0)!=='#'){hash='#'+hash;}if(search&&search.charAt(0)!=='?'){search='?'+search;}pathname=pathname.replace(/[?#]/g,function(match){return encodeURIComponent(match);});search=search.replace('#','%23');return protocol+host+pathname+search+hash;};function urlResolve(source,relative){return urlParse(source,false,true).resolve(relative);}Url.prototype.resolve=function(relative){return this.resolveObject(urlParse(relative,false,true)).format();};function urlResolveObject(source,relative){if(!source){return relative;}return urlParse(source,false,true).resolveObject(relative);}Url.prototype.resolveObject=function(relative){if(typeof relative==='string'){var rel=new Url();rel.parse(relative,false,true);relative=rel;}var result=new Url();var tkeys=Object.keys(this);for(var tk=0;tk<tkeys.length;tk++){var tkey=tkeys[tk];result[tkey]=this[tkey];}/*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */result.hash=relative.hash;// if the relative url is empty, then there's nothing left to do here.
if(relative.href===''){result.href=result.format();return result;}// hrefs like //foo/bar always cut to the protocol.
if(relative.slashes&&!relative.protocol){// take everything except the protocol from relative
var rkeys=Object.keys(relative);for(var rk=0;rk<rkeys.length;rk++){var rkey=rkeys[rk];if(rkey!=='protocol'){result[rkey]=relative[rkey];}}// urlParse appends trailing / to urls like http://www.example.com
if(slashedProtocol[result.protocol]&&result.hostname&&!result.pathname){result.pathname='/';result.path=result.pathname;}result.href=result.format();return result;}if(relative.protocol&&relative.protocol!==result.protocol){/*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */if(!slashedProtocol[relative.protocol]){var keys=Object.keys(relative);for(var v=0;v<keys.length;v++){var k=keys[v];result[k]=relative[k];}result.href=result.format();return result;}result.protocol=relative.protocol;if(!relative.host&&!hostlessProtocol[relative.protocol]){var relPath=(relative.pathname||'').split('/');while(relPath.length&&!(relative.host=relPath.shift())){}if(!relative.host){relative.host='';}if(!relative.hostname){relative.hostname='';}if(relPath[0]!==''){relPath.unshift('');}if(relPath.length<2){relPath.unshift('');}result.pathname=relPath.join('/');}else{result.pathname=relative.pathname;}result.search=relative.search;result.query=relative.query;result.host=relative.host||'';result.auth=relative.auth;result.hostname=relative.hostname||relative.host;result.port=relative.port;// to support http.request
if(result.pathname||result.search){var p=result.pathname||'';var s=result.search||'';result.path=p+s;}result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;}var isSourceAbs=result.pathname&&result.pathname.charAt(0)==='/',isRelAbs=relative.host||relative.pathname&&relative.pathname.charAt(0)==='/',mustEndAbs=isRelAbs||isSourceAbs||result.host&&relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&&result.pathname.split('/')||[],relPath=relative.pathname&&relative.pathname.split('/')||[],psychotic=result.protocol&&!slashedProtocol[result.protocol];/*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */if(psychotic){result.hostname='';result.port=null;if(result.host){if(srcPath[0]===''){srcPath[0]=result.host;}else{srcPath.unshift(result.host);}}result.host='';if(relative.protocol){relative.hostname=null;relative.port=null;if(relative.host){if(relPath[0]===''){relPath[0]=relative.host;}else{relPath.unshift(relative.host);}}relative.host=null;}mustEndAbs=mustEndAbs&&(relPath[0]===''||srcPath[0]==='');}if(isRelAbs){// it's absolute.
result.host=relative.host||relative.host===''?relative.host:result.host;result.hostname=relative.hostname||relative.hostname===''?relative.hostname:result.hostname;result.search=relative.search;result.query=relative.query;srcPath=relPath;// fall through to the dot-handling below.
}else if(relPath.length){/*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */if(!srcPath){srcPath=[];}srcPath.pop();srcPath=srcPath.concat(relPath);result.search=relative.search;result.query=relative.query;}else if(relative.search!=null){/*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */if(psychotic){result.host=srcPath.shift();result.hostname=result.host;/*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.hostname=authInHost.shift();result.host=result.hostname;}}result.search=relative.search;result.query=relative.query;// to support http.request
if(result.pathname!==null||result.search!==null){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.href=result.format();return result;}if(!srcPath.length){/*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */result.pathname=null;// to support http.request
if(result.search){result.path='/'+result.search;}else{result.path=null;}result.href=result.format();return result;}/*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */var last=srcPath.slice(-1)[0];var hasTrailingSlash=(result.host||relative.host||srcPath.length>1)&&(last==='.'||last==='..')||last==='';/*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */var up=0;for(var i=srcPath.length;i>=0;i--){last=srcPath[i];if(last==='.'){srcPath.splice(i,1);}else if(last==='..'){srcPath.splice(i,1);up++;}else if(up){srcPath.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(!mustEndAbs&&!removeAllDots){for(;up--;up){srcPath.unshift('..');}}if(mustEndAbs&&srcPath[0]!==''&&(!srcPath[0]||srcPath[0].charAt(0)!=='/')){srcPath.unshift('');}if(hasTrailingSlash&&srcPath.join('/').substr(-1)!=='/'){srcPath.push('');}var isAbsolute=srcPath[0]===''||srcPath[0]&&srcPath[0].charAt(0)==='/';// put the host back
if(psychotic){result.hostname=isAbsolute?'':srcPath.length?srcPath.shift():'';result.host=result.hostname;/*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.hostname=authInHost.shift();result.host=result.hostname;}}mustEndAbs=mustEndAbs||result.host&&srcPath.length;if(mustEndAbs&&!isAbsolute){srcPath.unshift('');}if(srcPath.length>0){result.pathname=srcPath.join('/');}else{result.pathname=null;result.path=null;}// to support request.http
if(result.pathname!==null||result.search!==null){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.auth=relative.auth||result.auth;result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;};Url.prototype.parseHost=function(){var host=this.host;var port=portPattern.exec(host);if(port){port=port[0];if(port!==':'){this.port=port.substr(1);}host=host.substr(0,host.length-port.length);}if(host){this.hostname=host;}};exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;},{"punycode/":148,"qs":150}],186:[function(require,module,exports){(function(global){(function(){/**
 * Module exports.
 */module.exports=deprecate;/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */function deprecate(fn,msg){if(config('noDeprecation')){return fn;}var warned=false;function deprecated(){if(!warned){if(config('throwDeprecation')){throw new Error(msg);}else if(config('traceDeprecation')){console.trace(msg);}else{console.warn(msg);}warned=true;}return fn.apply(this,arguments);}return deprecated;}/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */function config(name){// accessing global.localStorage can trigger a DOMException in sandboxed iframes
try{if(!global.localStorage)return false;}catch(_){return false;}var val=global.localStorage[name];if(null==val)return false;return String(val).toLowerCase()==='true';}}).call(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],187:[function(require,module,exports){// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports=wrappy;function wrappy(fn,cb){if(fn&&cb)return wrappy(fn)(cb);if(typeof fn!=='function')throw new TypeError('need wrapper function');Object.keys(fn).forEach(function(k){wrapper[k]=fn[k];});return wrapper;function wrapper(){var args=new Array(arguments.length);for(var i=0;i<args.length;i++){args[i]=arguments[i];}var ret=fn.apply(this,args);var cb=args[args.length-1];if(typeof ret==='function'&&ret!==cb){Object.keys(cb).forEach(function(k){ret[k]=cb[k];});}return ret;}}},{}],188:[function(require,module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){var target={};for(var i=0;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;}},{}],189:[function(require,module,exports){module.exports={"name":"pict","version":"1.0.233","description":"Pict browser library.","main":"source/Pict.js","scripts":{"start":"node source/Pict.js","test":"npx mocha -u tdd -R spec","tests":"npx mocha -u tdd --exit -R spec --grep","coverage":"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec","build":"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-image:local","docker-dev-run":"docker run -it -d --name pict-dev -p 37447:8080 -p 19506:8086 -v \"$PWD/.config:/home/coder/.config\"  -v \"$PWD:/home/coder/pict\" -u \"$(id -u):$(id -g)\" -e \"DOCKER_USER=$USER\" pict-image:local","docker-dev-shell":"docker exec -it pict-dev /bin/bash","lint":"eslint source/**/*.js test/**/*.js","types":"tsc -p ."},"types":"types/source/Pict.d.ts","mocha":{"diff":true,"extension":["js"],"package":"./package.json","reporter":"spec","slow":"75","timeout":"5000","ui":"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},"repository":{"type":"git","url":"git+https://stevenvelozo@github.com/stevenvelozo/pict.git"},"author":"steven velozo <steven@velozo.com>","license":"MIT","bugs":{"url":"https://github.com/stevenvelozo/pict/issues"},"homepage":"https://github.com/stevenvelozo/pict#readme","devDependencies":{"@eslint/js":"^9.20.0","@types/jquery":"^3.5.32","eslint":"^9.20.1","globals":"^15.15.0","quackage":"^1.0.38"},"dependencies":{"cachetrax":"^1.0.4","fable":"^3.0.148","pict-application":"^1.0.24","pict-provider":"^1.0.3","pict-template":"^1.0.10","pict-view":"^1.0.59","typescript":"^5.7.3"}};},{}],190:[function(require,module,exports){// This assumes Pict has been required in the browser. Delcare these as globals so linter can do its job.
/* global Pict, _Pict: writeable *//**
 * Simple function to load a pict Application
 *
 * @param {import('pict-application')} [pPictApplication] - The pict application to load.
 * @param {number} [pLogNoisiness] - The log noisiness level.
 */module.exports=function(pPictApplication,pLogNoisiness){var tmpLogNoisiness=typeof pLogNoisiness=='undefined'?0:pLogNoisiness;// Set up a basal pict on the window object
if(pPictApplication&&_typeof(pPictApplication['default_configuration'])==='object'&&'pict_configuration'in pPictApplication['default_configuration']){window._Pict=new Pict(pPictApplication['default_configuration'].pict_configuration);}else{window._Pict=new Pict();}window._Pict.LogNoisiness=tmpLogNoisiness;var tmpApplicationHash='DefaultApplication';var tmpDefaultConfiguration={};if('default_configuration'in pPictApplication){tmpDefaultConfiguration=pPictApplication.default_configuration;if('Hash'in tmpDefaultConfiguration&&typeof tmpDefaultConfiguration.Hash==='string'){tmpApplicationHash=tmpDefaultConfiguration.Hash;}}_Pict.log.info("Loading the pict application [".concat(tmpApplicationHash,"] and associated views."));_Pict.addApplication(tmpApplicationHash,tmpDefaultConfiguration,pPictApplication);_Pict.PictApplication.initializeAsync(function(pError){if(pError){console.log('Error initializing the pict application: '+pError);}_Pict.log.info('Loading the Application and associated views.');});};},{}],191:[function(require,module,exports){/**
 * Provide a safe on document ready function (without needing a framework like jquery)
 *
 * @param {function} fCallback - The function to call when the document is ready
 */module.exports=function(fCallback){if(!document){console.log('No document object found; no initialization happening.');return;}// In case the document is already rendered
if(document.readyState!='loading')fCallback();// Modern browsers have event listener capabilities
else if(document.addEventListener)document.addEventListener('DOMContentLoaded',function(){fCallback();});//@ts-ignore IE <= 8 and ... other abominations
else document.attachEvent('onreadystatechange',function(){if(document.readyState=='complete')fCallback();});};},{}],192:[function(require,module,exports){var libFableServiceBase=require('fable').ServiceProviderBase;var defaultConfiguration={// This is the address for the <script /> tag that contains the CSS.
CSSElementAddress:'#PICT-CSS'};var PictCSS=/*#__PURE__*/function(_libFableServiceBase18){function PictCSS(pFable,pOptions,pServiceHash){var _this68;_classCallCheck2(this,PictCSS);_this68=_callSuper(this,PictCSS,[pFable,pOptions,pServiceHash]);/** @type {any} */_this68.options;/** @type {{ ContentAssignment: import('./Pict-Content-Assignment') }} */_this68.services;// No merging of options necessary
if(typeof _this68.options.CSSElementAddress==='undefined'){_this68.options.CSSElementAddress=defaultConfiguration.CSSElementAddress;}_this68.inlineCSSMap={};return _this68;}// Add a CSS fragment to the CSS map (each view can have its own CSS fragment)
// Hash is shared across all views, so if 10 views all load the "My-Table-View" fragment, it will only be loaded once.
_inherits(PictCSS,_libFableServiceBase18);return _createClass2(PictCSS,[{key:"addCSS",value:function addCSS(pHash,pContent,pPriority,pProvider){var tmpPriority=typeof pPriority!=='undefined'?pPriority:1000;var tmpProvidor=typeof pProvider==='string'?pProvider:'Unknown';this.inlineCSSMap[pHash]={Hash:pHash,Content:pContent,Provider:tmpProvidor,Priority:tmpPriority};}},{key:"removeCSS",value:function removeCSS(pHash){delete this.inlineCSSMap[pHash];}},{key:"generateCSS",value:function generateCSS(){var _this69=this;var tmpCSS='';var tmpCSSHashes=Object.keys(this.inlineCSSMap);// Sort the hashes by Priority
tmpCSSHashes.sort(function(a,b){return _this69.inlineCSSMap[a].Priority-_this69.inlineCSSMap[b].Priority;});for(var i=0;i<tmpCSSHashes.length;i++){var tmpCSSFragment=this.inlineCSSMap[tmpCSSHashes[i]];var tmpCSSComment=tmpCSSFragment.Hash;if(tmpCSSFragment.Hash!=tmpCSSFragment.Provider){tmpCSSComment="".concat(tmpCSSComment," from ").concat(tmpCSSFragment.Provider);}tmpCSS+="/* ".concat(tmpCSSComment," */\n").concat(tmpCSSFragment.Content,"\n");}return tmpCSS;}// Inject the CSS into the magic DOM element for it
},{key:"injectCSS",value:function injectCSS(){this.services.ContentAssignment.assignContent(this.options.CSSElementAddress,this.generateCSS());}}]);}(libFableServiceBase);module.exports=PictCSS;},{"fable":68}],193:[function(require,module,exports){var libFableServiceBase=require('fable').ServiceProviderBase;/**
 * Class for moving content around in the DOM.
 */var PictContentAssignment=/*#__PURE__*/function(_libFableServiceBase19){/**
	 * @param {import('fable')} pFable - The Fable library instance.
	 * @param {any} [pOptions] - The options for the service.
	 * @param {string} [pServiceHash] - The hash of services.
	 */function PictContentAssignment(pFable,pOptions,pServiceHash){var _this70;_classCallCheck2(this,PictContentAssignment);_this70=_callSuper(this,PictContentAssignment,[pFable,pOptions,pServiceHash]);/** @type {any} */_this70.log;_this70.serviceType='PictContentAssignment';// Check to see if we are running in a browser
_this70.inBrowser=false;_this70.hasDocument=false;if((typeof window==="undefined"?"undefined":_typeof(window))=='object'){_this70.inBrowser=true;// Now check that the browser has a document object
if(typeof window.document!='undefined'&&typeof window.document.querySelectorAll=='function'){_this70.hasDocument=true;}}// If we're in a browser, check to see if jQuery is available.
_this70.hasJquery=false;_this70.jQuery=false;if(_this70.inBrowser&&typeof window.jQuery!=='undefined'){_this70.hasJquery=true;}/**
		 * Set this to override the default mechanism for setting the content of a DOM element.
		 *
		 * @type {Function}
		 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
		 * @param {string} pContent - The content to set.
		 */_this70.customAssignFunction=null;/**
		 * Set this to override the default mechanism for prepend content to a DOM element.
		 *
		 * @type {Function}
		 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
		 * @param {string} pContent - The content to prepend.
		 */_this70.customPrependFunction=null;/**
		 * Set this to override the default mechanism for appending content to a DOM element.
		 *
		 * @type {Function}
		 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
		 * @param {string} pContent - The content to append.
		 */_this70.customAppendFunction=null;/**
		 * Set this to override the default mechanism for reading content from the DOM.
		 *
		 * @type {Function}
		 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
		 * @return {string} - The content of the element.
		 */_this70.customReadFunction=null;/**
		 * Set this to override the default mechanism for getting elements.
		 *
		 * @type {Function}
		 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
		 * @return {Array<any>} - The matched elements.
		 */_this70.customGetElementFunction=null;// API Consumers can also craft their own attribute read function
_this70.customReadAttributeFunction=null;// API Consumers can also craft their own attribute set function
_this70.customSetAttributeFunction=null;// API Consumers can also craft their own attribute remove function
_this70.customRemoveAttributeFunction=null;// API Consumers can also craft their own class read function
_this70.customReadClassFunction=null;// API Consumers can also craft their own class set function
_this70.customSetClassFunction=null;// API Consumers can also craft their own class remove function
_this70.customRemoveClassFunction=null;return _this70;}/**
	 * Get an element from the DOM.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @return {Array<any>} - The matched elements.
	 */_inherits(PictContentAssignment,_libFableServiceBase19);return _createClass2(PictContentAssignment,[{key:"getElement",value:function getElement(pAddress){if(this.customGetElementFunction){return this.customGetElementFunction(pAddress);}else if(this.hasJquery){var tmpElements=window.jQuery(pAddress);if(tmpElements.length==0){return[];}// TODO: This isn't the most efficient method, but it is the most compatible.
var tmpElementSet=[];for(var i=0;i<tmpElements.length;i++){tmpElementSet.push(tmpElements[i]);}return tmpElementSet;}else if(this.inBrowser&&this.hasDocument){// convert from NodeList to Array for consistent return type
var _tmpElements=window.document.querySelectorAll(pAddress);var _tmpElementSet=[];for(var _i56=0;_i56<_tmpElements.length;_i56++){_tmpElementSet.push(_tmpElements[_i56]);}return _tmpElementSet;}else{// Just log it out for now
this.log.trace("PICT Content GET ELEMENT for [".concat(pAddress,"] will return empty because none of the browser methods are available"));return[];}}/**
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string|boolean} pContent - The content to assign.
	 * @return {void}
	 */},{key:"assignContent",value:function assignContent(pAddress,pContent){if(this.customAssignFunction){return this.customAssignFunction(pAddress,pContent);}else if(this.hasJquery){// Get the element(s)
//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElementSet=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);for(var i=0;i<tmpTargetElementSet.length;i++){var tmpElement=tmpTargetElementSet[i];switch(tmpElement.tagName){case'INPUT':if(tmpElement instanceof HTMLInputElement&&tmpElement.type=='checkbox'){tmpElement.checked=Boolean(pContent);}/* falls through */case'SELECT':case'TEXTAREA':if(tmpElement instanceof HTMLInputElement||tmpElement instanceof HTMLSelectElement||tmpElement instanceof HTMLTextAreaElement){tmpElement.value=String(pContent);}break;case'SCRIPT':if(tmpElement instanceof HTMLScriptElement){tmpElement.text=String(pContent);}break;default:tmpElement.innerHTML=String(pContent);}}}else if(this.inBrowser&&this.hasDocument){// Get the element(s)
var _tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var _i57=0;_i57<_tmpTargetElementSet.length;_i57++){var _tmpElement=_tmpTargetElementSet[_i57];switch(_tmpTargetElementSet[_i57].tagName){case'INPUT':if(_tmpElement instanceof HTMLInputElement&&_tmpElement.type=='checkbox'){_tmpElement.checked=Boolean(pContent);}/* falls through */case'SELECT':case'TEXTAREA':if(_tmpElement instanceof HTMLInputElement||_tmpElement instanceof HTMLSelectElement||_tmpElement instanceof HTMLTextAreaElement){_tmpElement.value=String(pContent);}break;case'SCRIPT':if(_tmpElement instanceof HTMLScriptElement){_tmpElement.text=String(pContent);}break;default:_tmpElement.innerHTML=String(pContent);}}}else{// Just log it out for now
this.log.trace("PICT Content ASSIGN to [".concat(pAddress,"]:"),pContent);}}/**
	 * Append content to an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pContent - The content to append.
	 */},{key:"appendContent",value:function appendContent(pAddress,pContent){if(this.customAppendFunction){return this.customAppendFunction(pAddress,pContent);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.append(pContent);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){tmpTargetElementSet[i].insertAdjacentHTML("beforeend",pContent);}}else{// Just log it out for now -- nothing browser in our mix.
this.log.trace("PICT Content APPEND to [".concat(pAddress,"]:"),pContent);}}/**
	 * Prepend content to an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pContent - The content to prepend.
	 */},{key:"prependContent",value:function prependContent(pAddress,pContent){if(this.customAppendFunction){return this.customPrependFunction(pAddress,pContent);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.prepend(pContent);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){tmpTargetElementSet[i].insertAdjacentHTML("afterbegin",pContent);}}else{// Just log it out for now -- nothing browser in our mix.
this.log.trace("PICT Content PREPEND in [".concat(pAddress,"]:"),pContent);}}/**
	 * Project content into a destination address based on a render method -- as the views do.
	 * Valid render methods are:
	 * - append: Append the content to the destination address.
	 * - prepend: Prepend the content to the destination address.
	 * - append_once: Append the content to the destination address only if it doesn't already exist in the test address.
	 * - replace: Replace the content of the destination address with the new content.
	 * @param {string} pRenderMethod
	 * @param {string} pDestinationAddress
	 * @param {string} pContent
	 * @param {string} pTestAddress
	 * @returns Result of the content assignment.
	 */},{key:"projectContent",value:function projectContent(pRenderMethod,pDestinationAddress,pContent,pTestAddress){// Assign the content to the destination address
switch(pRenderMethod){case'append':return this.appendContent(pDestinationAddress,pContent);case'prepend':return this.prependContent(pDestinationAddress,pContent);case'append_once':{// Try to find the content in either the test address or the destination address
var tmpTestAddress=typeof pTestAddress=='string'?pTestAddress:pDestinationAddress;var tmpExistingContent=this.getElement(tmpTestAddress);if(tmpExistingContent.length<1){return this.appendContent(pDestinationAddress,pContent);}break;}case'replace':// TODO: Should this be the default?
/* falls through */default:return this.assignContent(pDestinationAddress,pContent);}}/**
	 * Read content from an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 *
	 * TODO: return {boolean|string|number|string[]} - The content of the element.
	 * @return {string|boolean} - The content of the element.
	 */},{key:"readContent",value:function readContent(pAddress){if(this.customReadFunction){return this.customReadFunction(pAddress);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);switch(tmpTargetElement.prop('tagName')){case'INPUT':if(tmpTargetElement.attr('type')=='checkbox'){return tmpTargetElement.prop('checked');}/* falls through */case'SELECT':case'TEXTAREA':{//FIXME: masking types to simplify the expressed return value, for now
/** @type {any} */var value=tmpTargetElement.val();return value;}case'SCRIPT':return tmpTargetElement.text();default:return tmpTargetElement.html();}}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];if(tmpTargetElementSet.length<1){return null;}else if(tmpTargetElementSet.length==1){var tmpElement=tmpTargetElementSet[0];switch(tmpElement.tagName){case'INPUT':if(tmpElement instanceof HTMLInputElement&&tmpElement.type=='checkbox'){return tmpElement.checked;}/* falls through */case'SELECT':case'TEXTAREA':if(tmpElement instanceof HTMLInputElement||tmpElement instanceof HTMLSelectElement||tmpElement instanceof HTMLTextAreaElement){return tmpElement.value;}/* falls through */case'SCRIPT':if(tmpElement instanceof HTMLScriptElement){return tmpElement.text;}/* falls through */default:return tmpElement.innerHTML;}}}else{// Just log it out for now -- nothing browser in our mix.
this.log.trace("PICT Content READ from [".concat(pAddress,"]..."));return'';}}/**
	 * Add a class to an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string|string[]} pClass - The class to add.
	 */},{key:"addClass",value:function addClass(pAddress,pClass){if(this.customSetClassFunction){return this.customSetClassFunction(pAddress,pClass);}else if(this.hasJquery){// Get the element
//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.addClass(pClass);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){if(Array.isArray(pClass)){var _iterator=_createForOfIteratorHelper(pClass),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var tmpClass=_step.value;tmpTargetElementSet[i].classList.add(tmpClass);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{tmpTargetElementSet[i].classList.add(pClass);}}}else{this.log.trace("PICT Content ADDCLASS to [".concat(pAddress,"]:"),pClass);}}/**
	 * Remove a class from an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string|string[]} pClass - The class to remove.
	 */},{key:"removeClass",value:function removeClass(pAddress,pClass){if(this.customRemoveClassFunction){return this.customRemoveClassFunction(pAddress,pClass);}else if(this.hasJquery){// Get the element
//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.removeClass(pClass);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){if(Array.isArray(pClass)){var _iterator2=_createForOfIteratorHelper(pClass),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var tmpClass=_step2.value;tmpTargetElementSet[i].classList.remove(tmpClass);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}else{tmpTargetElementSet[i].classList.remove(pClass);}}}else{this.log.trace("PICT Content REMOVECLASS from [".concat(pAddress,"]:"),pClass);}}/**
	 * Read an attribute from an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pAttribute - The attribute name to read.
	 */},{key:"readAttribute",value:function readAttribute(pAddress,pAttribute){if(this.customReadAttributeFunction){return this.customReadAttributeFunction(pAddress,pAttribute);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);return tmpTargetElement.attr(pAttribute);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){tmpTargetElementSet[i].getAttribute(pAttribute);}return tmpTargetElementSet;}else{this.log.trace("PICT Content READATTRIBUTE from [".concat(pAddress,"]:"),pAttribute);}}/**
	 * Set an attribute on an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pAttribute - The attribute name to set.
	 * @param {string} pValue - The value to set.
	 */},{key:"setAttribute",value:function setAttribute(pAddress,pAttribute,pValue){if(this.customSetAttributeFunction){return this.customSetAttributeFunction(pAddress,pAttribute,pValue);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.attr(pAttribute,pValue);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){tmpTargetElementSet[i].setAttribute(pAttribute,pValue);}}else{this.log.trace("PICT Content SETATTRIBUTE for [".concat(pAddress,"] ATTRIBUTE [").concat(pAttribute,"]:"),pValue);}}/**
	 * Remove an attribute from an element.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pAttribute - The attribute name to remove.
	 */},{key:"removeAttribute",value:function removeAttribute(pAddress,pAttribute){if(this.customRemoveAttributeFunction){return this.customRemoveAttributeFunction(pAddress,pAttribute);}else if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);tmpTargetElement.removeAttr(pAttribute);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){tmpTargetElementSet[i].removeAttribute(pAttribute);}}else{this.log.trace("PICT Content REMOVEATTRIBUTE for [".concat(pAddress,"] ATTRIBUTE [").concat(pAttribute,"]"));}}/**
	 * Check if an element has a class.
	 *
	 * @param {string|HTMLElement} pAddress - The address of the element (a CSS selector), or the element itself.
	 * @param {string} pClass - The class to check for.
	 *
	 * @return {boolean} - Whether the element has the class. If multiple elements are matched, returns true if any have the class.
	 */},{key:"hasClass",value:function hasClass(pAddress,pClass){if(this.customReadClassFunction){return this.customReadClassFunction(pAddress,pClass);}if(this.hasJquery){//FIXME: this is silly, but it makes the type system happy - it picks a different overload for each case
var tmpTargetElement=typeof pAddress==='string'?window.jQuery(pAddress):window.jQuery(pAddress);return tmpTargetElement.hasClass(pClass);}else if(this.inBrowser&&this.hasDocument){var tmpTargetElementSet=typeof pAddress==='string'?window.document.querySelectorAll(pAddress):[pAddress];for(var i=0;i<tmpTargetElementSet.length;i++){if(tmpTargetElementSet[i].classList.contains(pClass)){return true;}}return false;}else{this.log.trace("PICT Content HASCLASS for [".concat(pAddress,"] CLASS [").concat(pClass,"]:"));return false;}}}]);}(libFableServiceBase);module.exports=PictContentAssignment;},{"fable":68}],194:[function(require,module,exports){var libFableServiceBase=require('fable').ServiceProviderBase;var PictDataProvider=/*#__PURE__*/function(_libFableServiceBase20){function PictDataProvider(pFable,pOptions,pServiceHash){var _this71;_classCallCheck2(this,PictDataProvider);_this71=_callSuper(this,PictDataProvider,[pFable,pOptions,pServiceHash]);/** @type {import('fable') & import('pict')} */_this71.fable;_this71.serviceType='PictDataProvider';return _this71;}/**
	 * @param {string} pAddress - The address of the data to retrieve
	 * @param {object} [pData] - (optional) The record to provide to the address resolver
	 */_inherits(PictDataProvider,_libFableServiceBase20);return _createClass2(PictDataProvider,[{key:"getDataByAddress",value:function getDataByAddress(pAddress,pData){var tmpData=typeof pData==='undefined'?{}:pData;return this.fable.manifest.getValueByHash({AppData:this.fable.AppData,Bundle:this.fable.Bundle,Record:tmpData},pAddress);}}]);}(libFableServiceBase);module.exports=PictDataProvider;},{"fable":68}],195:[function(require,module,exports){var libFableServiceBase=require('fable').ServiceProviderBase;var PictMeadowEntityProvider=/*#__PURE__*/function(_libFableServiceBase21){function PictMeadowEntityProvider(pFable,pOptions,pServiceHash){var _this72;_classCallCheck2(this,PictMeadowEntityProvider);_this72=_callSuper(this,PictMeadowEntityProvider,[pFable,pOptions,pServiceHash]);/** @type {any} */_this72.options;/** @type {import('pict') & { settings: any }} */_this72.fable;_this72.serviceType='PictMeadowProvider';if(_this72.fable.settings.PictDefaultURLPrefix){_this72.options.urlPrefix=_this72.fable.settings.PictDefaultURLPrefix;}else if(!_this72.options.urlPrefix){_this72.options.urlPrefix='/1.0/';}if(_this72.fable.settings.PictDefaultDownloadBatchSize){_this72.options.downloadBatchSize=_this72.fable.settings.PictDefaultDownloadBatchSize;}else if(!_this72.options.downloadBatchSize){_this72.options.downloadBatchSize=100;}//@ts-ignore - FIXME - remove once we have fable types
_this72.restClient=_this72.fable.instantiateServiceProviderWithoutRegistration('RestClient');_this72.cache={};_this72.prepareRequestOptions=function(pOptions){return pOptions;};return _this72;}_inherits(PictMeadowEntityProvider,_libFableServiceBase21);return _createClass2(PictMeadowEntityProvider,[{key:"initializeCache",value:function initializeCache(pEntity){// This should not be happening as often as it's happening.
if(!(pEntity in this.cache)){//@ts-ignore - FIXME - remove once we have fable types
this.cache[pEntity]=this.fable.instantiateServiceProviderWithoutRegistration('ObjectCache');// TODO: Make this a configuration?
// For now cache for 30 seconds.
this.cache[pEntity].maxAge=30000;this.cache[pEntity].maxLength=10000;this.fable.Bundle[pEntity]=this.cache[pEntity].RecordMap;}}},{key:"getEntity",value:function getEntity(pEntity,pIDRecord,fCallback){this.initializeCache(pEntity);// Discard anything from the cache that has expired or is over size.
this.cache[pEntity].prune(function(){var _this73=this;var tmpPossibleRecord=this.cache[pEntity].read(pIDRecord);if(tmpPossibleRecord){return fCallback(null,tmpPossibleRecord);}var tmpOptions={url:"".concat(this.options.urlPrefix).concat(pEntity,"/").concat(pIDRecord)};tmpOptions=this.prepareRequestOptions(tmpOptions);return this.restClient.getJSON(tmpOptions,function(pError,pResponse,pBody){if(pBody){_this73.cache[pEntity].put(pBody,pIDRecord);}return fCallback(pError,pBody);});}.bind(this));}},{key:"getEntitySetPage",value:function getEntitySetPage(pEntity,pMeadowFilterExpression,pRecordStartCursor,pRecordCount,fCallback){var tmpURL="".concat(this.options.urlPrefix).concat(pEntity,"s/FilteredTo/").concat(pMeadowFilterExpression,"/").concat(pRecordStartCursor,"/").concat(pRecordCount);return this.restClient.getJSON(tmpURL,function(pDownloadError,pDownloadResponse,pDownloadBody){return fCallback(pDownloadError,pDownloadBody);}.bind(this));}},{key:"getEntitySetRecordCount",value:function getEntitySetRecordCount(pEntity,pMeadowFilterExpression,fCallback){var tmpURL="".concat(this.options.urlPrefix).concat(pEntity,"s/Count/FilteredTo/").concat(pMeadowFilterExpression);return this.restClient.getJSON(tmpURL,function(pError,pResponse,pBody){if(pError){this.log.error("Error getting entity count of [".concat(pEntity,"] filtered to [").concat(pMeadowFilterExpression,"] from url [").concat(tmpURL,"]: ").concat(pError));return fCallback(pError);}var tmpRecordCount=0;if(pBody.Count){tmpRecordCount=pBody.Count;}return fCallback(pError,tmpRecordCount);}.bind(this));}},{key:"getEntitySet",value:function getEntitySet(pEntity,pMeadowFilterExpression,fCallback){// TODO: Should we test for too many record IDs here by string length in pMeadowFilterExpression?
//       FBL~ID${pDestinationEntity}~INN~${tmpIDRecordsCommaSeparated}
//       If the list is mega-long we can parse it and break it into chunks.
this.initializeCache(pEntity);// Discard anything from the cache that has expired or is over size.
this.cache[pEntity].prune(function(){var _this74=this;return this.getEntitySetRecordCount(pEntity,pMeadowFilterExpression,function(pRecordCountError,pRecordCount){if(pRecordCountError){return fCallback(pRecordCountError);}var tmpRecordCount=pRecordCount;if(isNaN(pRecordCount)){_this74.log.error("Entity count did not return a number for [".concat(pEntity,"] filtered to [").concat(pMeadowFilterExpression,"]... something is fatally wrong from the server accessed in getEntitySet call."));return fCallback(new Error('Entity count did not return a number in getEntitySet.'));}var tmpDownloadURIFragments=[];var tmpDownloadBatchSize=_this74.options.downloadBatchSize;for(var i=0;i<tmpRecordCount/tmpDownloadBatchSize;i++){// Generate each of the URI fragments to download
tmpDownloadURIFragments.push("".concat(_this74.options.urlPrefix).concat(pEntity,"s/FilteredTo/").concat(pMeadowFilterExpression,"/").concat(i*tmpDownloadBatchSize,"/").concat(tmpDownloadBatchSize));}var tmpEntitySet=[];// Now run these in series (it's possible to parallelize the requests but they would not be in server order)
_this74.fable.Utility.eachLimit(tmpDownloadURIFragments,1,function(pURIFragment,fDownloadCallback){_this74.restClient.getJSON(pURIFragment,function(pDownloadError,pDownloadResponse,pDownloadBody){tmpEntitySet=tmpEntitySet.concat(pDownloadBody);// Should we be caching each record?
return fDownloadCallback(pDownloadError);});},function(pFullDownloadError){return fCallback(pFullDownloadError,tmpEntitySet);});});}.bind(this));}}]);}(libFableServiceBase);module.exports=PictMeadowEntityProvider;},{"fable":68}],196:[function(require,module,exports){var libFableServiceBase=require('fable').ServiceProviderBase;var PictTemplateProvider=/*#__PURE__*/function(_libFableServiceBase22){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProvider(pFable,pOptions,pServiceHash){var _this75;_classCallCheck2(this,PictTemplateProvider);_this75=_callSuper(this,PictTemplateProvider,[pFable,pOptions,pServiceHash]);/** @type {any} */_this75.log;/** @type {string} */_this75.UUID;/** @type {string} */_this75.Hash;_this75.serviceType='PictTemplateProvider';_this75.templates={};_this75.templateSources={};// Default templates are stored by prefix.
// The longest prefix match is used.
// Case sensitive.
_this75.defaultTemplates=[];/**
		 * @type {(hash?: string) => { template: string, source: string }?} loadTemplateFunction - The function to load a template
		 */_this75.loadTemplateFunction=function(){return null;};return _this75;}/**
	 * Add a template to the provider.
	 *
	 * @param {String} pTemplateHash - The hash of the template
	 * @param {String} pTemplate - The template
	 * @param {String} [pTemplateSource] - (optional) The source of the template
	 */_inherits(PictTemplateProvider,_libFableServiceBase22);return _createClass2(PictTemplateProvider,[{key:"addTemplate",value:function addTemplate(pTemplateHash,pTemplate,pTemplateSource){this.templates[pTemplateHash]=pTemplate;if(typeof pTemplateSource=='string'){this.templateSources[pTemplateHash]=pTemplateSource;}else{this.templateSources[pTemplateHash]="Direct addTemplate('".concat(pTemplateHash,"') function load into PictTemplateProvider [").concat(this.UUID,"]::[").concat(this.Hash,"]");}}/**
	 * Add a default template to the provider.
	 *
	 * @param {String} pPrefix - The prefix of the template identifier.
	 * @param {String} pPostfix - The postfix of the template identifier.
	 * @param {String} pTemplate - The template
	 * @param {String} [pSource] - (optional) The source of the template
	 */},{key:"addDefaultTemplate",value:function addDefaultTemplate(pPrefix,pPostfix,pTemplate,pSource){var tmpSource=typeof pSource=='string'?pSource:"Direct addDefaultTemplate('".concat(pPrefix,"','").concat(pPostfix,"',..) function load into PictTemplateProvider [").concat(this.UUID,"]::[").concat(this.Hash,"]");var tmpDefaultTemplate={prefix:pPrefix,postfix:pPostfix,template:pTemplate,source:tmpSource};if(typeof pTemplate!='string'){this.log.error('PictTemplateProvider.addDefaultTemplate: pTemplate is not a string.');}this.defaultTemplates.push(tmpDefaultTemplate);}/**
	 * Attempt to populate a template to a default template if it matches a given hash.
	 *
	 * Default templates are managed by postfix and prefix.  The use case is things like titles, headers, list
	 * wrappers, rows, etc.
	 *
	 * So we might have a default template for a list wrapper and it should expect "-ListWrap" as the postfix.
	 * And we might have a default template for a list row and it should expect "-ListRow" as the postfix.
	 * The list might have a "-ListTitle", or we might have shared titles and it would just be "-Title".
	 *
	 * The idea is to allow fallbacks on defaults.
	 *
	 * @param {String} pTemplateHash - The hash of the template
	 * @return {string} - The template, or false if not found
	 */},{key:"checkDefaultTemplateHash",value:function checkDefaultTemplateHash(pTemplateHash){for(var i=0;i<this.defaultTemplates.length;i++){if(pTemplateHash.indexOf(this.defaultTemplates[i].postfix)==pTemplateHash.length-this.defaultTemplates[i].postfix.length&&pTemplateHash.indexOf(this.defaultTemplates[i].prefix)==0){this.templates[pTemplateHash]=this.defaultTemplates[i].template;this.templateSources[pTemplateHash]="Auto created in checkDefaultTemplateHash('".concat(pTemplateHash,"') function by PictTemplateProvider [").concat(this.UUID,"]::[").concat(this.Hash,"] from [").concat(this.defaultTemplates[i].prefix,"]...[").concat(this.defaultTemplates[i].postfix,"]");return this.templates[pTemplateHash];}}return null;}/**
	 * Get a template by hash.
	 *
	 * @param {String} pTemplateHash - The hash of the template
	 * @return {String} - The template, or false if not found
	 */},{key:"getTemplate",value:function getTemplate(pTemplateHash){// TODO: Optimize this.
// If the template doesn't exist, try to load it with the loading function
if(!(pTemplateHash in this.templates)){this.loadTemplate(pTemplateHash);}// If the loading function fails, try to load it from the default templates
if(!(pTemplateHash in this.templates)){this.checkDefaultTemplateHash(pTemplateHash);}if(pTemplateHash in this.templates){return this.templates[pTemplateHash];}return null;}/**
	 * Load a template by hash.
	 *
	 * @param {String} pTemplateHash - The hash of the template
	 */},{key:"loadTemplate",value:function loadTemplate(pTemplateHash){var tmpTemplate=this.loadTemplateFunction(pTemplateHash);if(tmpTemplate){this.templates[pTemplateHash]=tmpTemplate.template;this.templateSources[pTemplateHash]="Loaded in loadTemplate('".concat(pTemplateHash,"') function by PictTemplateProvider [").concat(this.UUID,"]::[").concat(this.Hash,"] from [").concat(tmpTemplate.source,"]");}return tmpTemplate;}}]);}(libFableServiceBase);module.exports=PictTemplateProvider;},{"fable":68}],197:[function(require,module,exports){/**
* @author <steven@velozo.com>
*//**
 * @typedef {{
 *    UUID: string,
 *    settings: any,
 *    fable: Fable,
 *    servicesMap: any,
 *    addAndInstantiateServiceType: (hash: string, prototype: any) => any,
 *    addServiceType: (hash: string, prototype: any) => any,
 *    instantiateServiceProvider: (hash: string, options?: any, prototype?: any) => any,
 *    instantiateServiceProviderFromPrototype: (pServiceType: string, pOptions?: any, pCustomServiceHash?: string, pServicePrototype?: any) => any,
 *    getUUID: () => string,
 *    Utility:
 *    {
 *	      extend: (pObject: any, ...pExtension: any[]) => any,
 *	      eachLimit: (pArray: any[], pLimit: number, pIterator: (pRecord: any, fRecordCallback: () => void) => void, fCallback: (pError: any) => void) => void,
 *    },
 *    MetaTemplate: any,
 * }} Fable
 *//** @type {{ new(...args: any[]): Fable }} */var libFable=require('fable');var libPackage=require('../package.json');var PictTemplateProvider=require('./Pict-Template-Provider.js');var PictContentAssignment=require('./Pict-Content-Assignment.js');var PictDataProvider=require('./Pict-DataProvider.js');var PictCSS=require('./Pict-CSS.js');var PictMeadowEntityProvider=require('./Pict-Meadow-EntityProvider.js');/**
 * Pict management object.
 */var Pict=/*#__PURE__*/function(_libFable){/**
	 * @param {Object<String, any>} pSettings - The settings for the Pict instance.
	 */function Pict(pSettings){var _this76;_classCallCheck2(this,Pict);_this76=_callSuper(this,Pict,[pSettings]);/** @type {any} */_this76.settings;_this76.isBrowser=new Function("try {return (this===window);} catch(pError) {return false;}");/** @type {Object} */_this76._PackageFable=_this76._Package;_this76._Package=libPackage;_this76.browserAddress='window._Pict';if('BrowserAddress'in _this76.settings){_this76.browserAddress=_this76.settings.BrowserAddress;}_this76.children=[];/** @type {import('pict-application')} */_this76.PictApplication=null;// shim types from fable until we export types properly
/** @type {any} */_this76.log;/**
		 * The templateProvider provides a basic key->template mapping with default fallback capabilities
		 *
		 * @type {PictTemplateProvider}
		 */_this76.TemplateProvider=null;_this76.addAndInstantiateServiceType('TemplateProvider',PictTemplateProvider);/**
		 * The meadow entity provider.
		 *
		 * @type {PictMeadowEntityProvider}
		 */_this76.EntityProvider=null;_this76.addAndInstantiateServiceType('EntityProvider',PictMeadowEntityProvider);/**
		 * The data provider.
		 *
		 * @type {PictDataProvider}
		 */_this76.DataProvider=null;_this76.addAndInstantiateServiceType('DataProvider',PictDataProvider);/**
		 * The content assignment module.
		 *
		 * @type {PictContentAssignment}
		 */_this76.ContentAssignment=null;_this76.addAndInstantiateServiceType('ContentAssignment',PictContentAssignment);/**
		 * The CSS module.
		 *
		 * @type {PictCSS}
		 * @public
		 */_this76.CSSMap=null;_this76.addAndInstantiateServiceType('CSSMap',PictCSS);_this76.addServiceType('PictTemplate',require('pict-template'));_this76.instantiateServiceProvider('MetaTemplate');_this76.instantiateServiceProvider('DataGeneration');_this76.manifest=_this76.instantiateServiceProvider('Manifest');_this76.AppData={};if('DefaultAppData'in _this76.fable.settings){_this76.AppData=_this76.fable.settings.DefaultAppData;}_this76.Bundle={};// Log noisness goes from 0 - 5, where 5 is show me everything.
_this76.LogNoisiness=0;// Although we have log noisiness, sometimes we need control flow without all the other noise for hard to diagnose interpreters.
_this76.LogControlFlow=false;// And an easy way to be introspective about data at various locations
_this76.LogControlFlowWatchAddressList=[];// Load manifest sets
if(_this76.settings.Manifests){_this76.loadManifestSet(_this76.settings.Manifests);}_this76._DefaultPictTemplatesInitialized=false;_this76.initializePictTemplateEngine();_this76.addServiceType('PictView',require('pict-view'));_this76.addServiceType('PictProvider',require('pict-provider'));_this76.addServiceType('PictApplication',require('pict-application'));// Expose the named views directly, through a convenience accessor
_this76.providers=_this76.servicesMap.PictProvider;_this76.views=_this76.servicesMap.PictView;return _this76;}/**
	 * Load manifests in as Hashed services
	 *
	 * @param {Object<String, String>} pManifestSet - The manifest set to load.
	 */_inherits(Pict,_libFable);return _createClass2(Pict,[{key:"loadManifestSet",value:function loadManifestSet(pManifestSet){if(_typeof(pManifestSet)!='object'){this.log.warn("PICT [".concat(this.UUID,"] could not load Manifest Set; pManifestSet was not an object."));return;}var tmpManifestKeys=Object.keys(pManifestSet);if(tmpManifestKeys.length>0){for(var i=0;i<tmpManifestKeys.length;i++){// Load each manifest
var tmpManifestKey=tmpManifestKeys[i];this.instantiateServiceProvider('Manifest',pManifestSet[tmpManifestKey],tmpManifestKey);}}}/**
	 * Add a template expression to the template engine from the PictTemplate service.
	 *
	 * @template {new (...args: any[]) => any} T
	 * @param {T} pTemplatePrototype - The prototype class for the template expression
	 *
	 * @return {InstanceType<T>} the service instance, or null if the prototype was invalid
	 */},{key:"addTemplate",value:function addTemplate(pTemplatePrototype){if(typeof pTemplatePrototype!='function'){this.log.warn("PICT [".concat(this.UUID,"] could not add Template; pTemplatePrototype was not a class it was ").concat(_typeof(pTemplatePrototype),"."));return null;}var tmpTemplateHash=pTemplatePrototype['template_hash'];if(this.LogNoisiness>1){this.log.info("PICT-ControlFlow addTemplate [".concat(tmpTemplateHash,"]"));}return this.instantiateServiceProviderFromPrototype('PictTemplate',{},tmpTemplateHash,pTemplatePrototype);}/**
	 * Just passing an options will construct one for us.
	 * Passing a hash will set the hash.
	 * Passing a prototype will use that!
	 *
	 * @template {new (...args: any[]) => any} [T=typeof import('pict-view')]
	 * @param {String} pViewHash - The hash of the view.
	 * @param {Object<String, any>} [pOptions] - The options for the view.
	 * @param {T} [pViewPrototype] - The prototype for the view.
	 *
	 * @return {InstanceType<T>} The view instance.
	 */},{key:"addView",value:function addView(pViewHash,pOptions,pViewPrototype){var tmpOptions=_typeof(pOptions)=='object'?pOptions:{};var tmpViewHash=typeof pViewHash=='string'?pViewHash:this.fable.getUUID();// This is here to change how the value is managed by webpack
var tmpViewPrototype=pViewPrototype;if(this.LogControlFlow){if(this.LogNoisiness>1){this.log.info("PICT-ControlFlow addView [".concat(tmpViewHash,"]:"),{Options:tmpOptions});}else{this.log.info("PICT-ControlFlow addView [".concat(tmpViewHash,"]"));}}if(tmpViewPrototype){// If the prototype has a default_configuration, it will be merged with options.
var tmpDefaultViewConfiguration=tmpViewPrototype['default_configuration'];if(tmpDefaultViewConfiguration){tmpOptions=this.fable.Utility.extend({},JSON.parse(JSON.stringify(tmpDefaultViewConfiguration)),tmpOptions);}return this.instantiateServiceProviderFromPrototype('PictView',tmpOptions,tmpViewHash,tmpViewPrototype);}else{return this.instantiateServiceProvider('PictView',tmpOptions,tmpViewHash);}}/**
	 * Add a provider unless one already exists, then return that one.
	 *
	 * Just passing an options will construct one for us.
	 * Passing a hash will set the hash.
	 * Passing a prototype will use that!
	 *
	 * @param {String} pProviderHash - The hash of the provider.
	 * @param {Object<String, any>} [pOptions] - The options for the provider.
	 * @param {any} [pProviderPrototype] - The prototype for the provider.
	 *
	 * FIXME: refer to PictProvider here once it has a type definition
	 *
	 * @return {any} The provider instance.
	 */},{key:"addProviderSingleton",value:function addProviderSingleton(pProviderHash,pOptions,pProviderPrototype){if(pProviderHash in this.providers){return this.providers[pProviderHash];}return this.addProvider(pProviderHash,pOptions,pProviderPrototype);}/**
	 * Just passing an options will construct one for us.
	 * Passing a hash will set the hash.
	 * Passing a prototype will use that!
	 *
	 * @param {String} pProviderHash - The hash of the provider.
	 * @param {Object<String, any>} [pOptions] - The options for the provider.
	 * @param {any} [pProviderPrototype] - The prototype for the provider.
	 *
	 * FIXME: refer to PictProvider here once it has a type definition
	 *
	 * @return {any} The provider instance.
	 */},{key:"addProvider",value:function addProvider(pProviderHash,pOptions,pProviderPrototype){var tmpOptions=_typeof(pOptions)=='object'?pOptions:{};var tmpProviderHash=typeof pProviderHash=='string'?pProviderHash:this.fable.getUUID();if(this.LogControlFlow){if(this.LogNoisiness>1){this.log.info("PICT-ControlFlow addProvider [".concat(tmpProviderHash,"]:"),{Options:tmpOptions});}else{this.log.info("PICT-ControlFlow addProvider [".concat(tmpProviderHash,"]"));}}if(typeof pProviderPrototype!='undefined'){// If the prototype has a default_configuration, it will be merged with options.
if('default_configuration'in pProviderPrototype){tmpOptions=this.fable.Utility.extend({},pProviderPrototype.default_configuration,tmpOptions);}return this.instantiateServiceProviderFromPrototype('PictProvider',tmpOptions,tmpProviderHash,pProviderPrototype);}else{return this.instantiateServiceProvider('PictProvider',tmpOptions,tmpProviderHash);}}/**
	 * Just passing an options will construct one for us.
	 * Passing a hash will set the hash.
	 * Passing a prototype will use that!
	 *
	 * @param {String} pApplicationHash - The hash of the application.
	 * @param {Object} [pOptions] - The options for the application.
	 * @param {any} [pApplicationPrototype] - The prototype for the application.
	 *
	 * FIXME: refer to PictApplication here once it has a type definition
	 *
	 * @return {any} The application instance.
	 */},{key:"addApplication",value:function addApplication(pApplicationHash,pOptions,pApplicationPrototype){var tmpOptions=_typeof(pOptions)=='object'?pOptions:{};var tmpApplicationHash=typeof pApplicationHash=='string'?pApplicationHash:this.fable.getUUID();if(this.LogControlFlow){if(this.LogNoisiness>1){this.log.info("PICT-ControlFlow addApplication [".concat(tmpApplicationHash,"]:"),{Options:tmpOptions});}else{this.log.info("PICT-ControlFlow addApplication [".concat(tmpApplicationHash,"]"));}}if(typeof pApplicationPrototype!='undefined'){// If the prototype has a default_configuration, it will be merged with options.
if('default_configuration'in pApplicationPrototype){tmpOptions=this.fable.Utility.extend({},pApplicationPrototype.default_configuration,tmpOptions);}return this.instantiateServiceProviderFromPrototype('PictApplication',tmpOptions,tmpApplicationHash,pApplicationPrototype);}else{return this.instantiateServiceProvider('PictApplication',tmpOptions,tmpApplicationHash);}}/**
	 * Attach the default template engine renderers.
	 *
	 * @private
	 */},{key:"initializePictTemplateEngine",value:function initializePictTemplateEngine(){if(!this._DefaultPictTemplatesInitialized){// Just looking up data in the application state template expression
//{~Data:AppData.Some.Value.to.Render~}
//{~D:AppData.Some.Value.to.Render~}
this.addTemplate(require("./templates/Pict-Template-Data.js"));// HTML Comment Start and End based on truthiness ... if the value is false, the comment shows up.
// {~HtmlCommentStart:Some.Address~} gives you "<!--"
// {~HCS:Some.Address~} gives you "<!--"
this.addTemplate(require("./templates/data/Pict-Template-HtmlCommentStart.js"));// {~HtmlCommentEnd:Some.Address~} gives you "-->"
// {~HCE:Some.Address~} gives you "-->"
this.addTemplate(require("./templates/data/Pict-Template-HtmlCommentEnd.js"));// Know the in-browser reference for Pict when appropriate
this.addTemplate(require("./templates/Pict-Template-Self.js"));// Look up an entity template expression
// {~Entity:Book^AppData.Some.Address.IDBook^Render-Book-Template~}
// {~E:Book^AppData.Some.Address.IDBook^Render-Book-Template~}
// ...meaning GET BOOK with IDBook FROM AppData.Some.Address.IDBook and render it to Render-Book-Template
this.addTemplate(require("./templates/Pict-Template-Entity.js"));// Child Template Expressions
// {~T:Template:AddressOfData~}
this.addTemplate(require("./templates/Pict-Template-Template.js"));// {~TS:Template:AddressOfDataSet~}
this.addTemplate(require("./templates/Pict-Template-TemplateSet.js"));// {~TVS:Template:AddressOfDataSet~}
this.addTemplate(require("./templates/Pict-Template-TemplateValueSet.js"));this.addTemplate(require("./templates/Pict-Template-TemplateFromMap.js"));this.addTemplate(require("./templates/Pict-Template-TemplateSetFromMap.js"));// Logical Branching Template Expressions
// {~TemplateIf:Template:AddressOfData:AppData.Some.Address.IDBook^OPERATOR^AppData.Some.Address2.IDBook~}
// {~TIf:Template:AddressOfData:AppData.Some.Address.IDBook^OPERATOR^AppData.Some.Address2.IDBook~}
this.addTemplate(require("./templates/logic/Pict-Template-TemplateIf.js"));// {~TemplateIfAbsolute:Template:AddressOfData:AppData.Some.Address.IDBook^OPERATOR^Absolute_Value~}
// {~TIfAbs:Template:AddressOfData:AppData.Some.Address.IDBook^OPERATOR^Absolute_Value~}
this.addTemplate(require("./templates/logic/Pict-Template-TemplateIfAbsolute.js"));// {~NotEmpty:AppData.Some.Address^Absolute Value~}
this.addTemplate(require("./templates/logic/Pict-Template-NotEmpty.js"));// Data Manipulation Templates
this.addTemplate(require("./templates/data/Pict-Template-DataJson.js"));this.addTemplate(require("./templates/data/Pict-Template-PascalCaseIdentifier.js"));this.addTemplate(require("./templates/data/Pict-Template-DateOnlyFormat.js"));this.addTemplate(require("./templates/data/Pict-Template-DateOnlyYMD.js"));this.addTemplate(require("./templates/data/Pict-Template-DateTimeFormat.js"));this.addTemplate(require("./templates/data/Pict-Template-DateTimeYMD.js"));this.addTemplate(require("./templates/data/Pict-Template-Digits.js"));this.addTemplate(require("./templates/data/Pict-Template-Dollars.js"));this.addTemplate(require("./templates/data/Pict-Template-Join.js"));this.addTemplate(require("./templates/data/Pict-Template-JoinUnique.js"));this.addTemplate(require("./templates/data/Pict-Template-PluckJoinUnique.js"));// Data Generation Templates
this.addTemplate(require("./templates/data-generation/Pict-Template-RandomNumber.js"));this.addTemplate(require("./templates/data-generation/Pict-Template-RandomNumberString.js"));// Debugging Templates
this.addTemplate(require("./templates/debugging/Pict-Template-Breakpoint.js"));this.addTemplate(require("./templates/debugging/Pict-Template-LogStatement.js"));this.addTemplate(require("./templates/debugging/Pict-Template-LogValue.js"));this.addTemplate(require("./templates/debugging/Pict-Template-LogValueTree.js"));this.addTemplate(require("./templates/debugging/Pict-Template-DataValueTree.js"));this._DefaultPictTemplatesInitialized=true;}}/**
	 * Read a value from a nested object using a dot notation string.
	 *
	 * @param {string} pAddress - The address to resolve
	 * @param {any} pRecord - The record to resolve
	 * @param {Array<any>} [pContextArray] - The context array to resolve
	 *
	 * @return {any} The value at the given address, or undefined
	 */},{key:"resolveStateFromAddress",value:function resolveStateFromAddress(pAddress,pRecord,pContextArray){var tmpContextArray=Array.isArray(pContextArray)?pContextArray:[this];return this.manifest.getValueByHash({Pict:this,AppData:this.AppData,Bundle:this.Bundle,Context:tmpContextArray,Record:pRecord},pAddress);}/**
	 * Parse a template.
	 *
	 * @param {String} pTemplateString - The template string to parse
	 * @param {Object} pData - The data to use in the template
	 * @param {Function} [fCallback] - The callback to call when the template is parsed
	 * @param {Array<any>} [pContextArray] - The context array to use in the template
	 *
	 * @return {String?} The parsed template string, or undefined if a callback was provided
	 */},{key:"parseTemplate",value:function parseTemplate(pTemplateString,pData,fCallback,pContextArray){var _this77=this;var tmpData=_typeof(pData)==='object'?pData:{};var tmpContextArray=Array.isArray(pContextArray)?pContextArray:[this];var tmpParseUUID;if(this.LogControlFlow){tmpParseUUID=this.fable.getUUID();this.log.info("PICT-ControlFlow parseTemplate ".concat(tmpParseUUID," [").concat(pTemplateString.substring(0,50).replace('\n','\\n'),"...").concat(pTemplateString.length,"] (fCallback: ").concat(_typeof(fCallback),") with data size [").concat(JSON.stringify(tmpData).length,"]"));if(this.LogNoisiness>1){this.log.info("PICT-ControlFlow parseTemplate ".concat(tmpParseUUID," template:\n").concat(pTemplateString));}if(this.LogControlFlowWatchAddressList.length>0){for(var i=0;i<this.LogControlFlowWatchAddressList.length;i++){this.log.info("PICT-ControlFlow parseTemplate ".concat(tmpParseUUID," Watch Value: [").concat(this.LogControlFlowWatchAddressList[i],"]=>[").concat(this.resolveStateFromAddress(this.LogControlFlowWatchAddressList[i],tmpData),"]"));}}}if(typeof fCallback==='function'){this.MetaTemplate.parseString(pTemplateString,tmpData,function(pError,pParsedTemplate){if(_this77.LogControlFlow&&_this77.LogNoisiness>1){_this77.log.info("PICT-ControlFlow parseTemplate ".concat(tmpParseUUID," Template Async Return Value:\n").concat(pParsedTemplate));}return fCallback(pError,pParsedTemplate);},tmpContextArray);}else{var tmpResult=this.MetaTemplate.parseString(pTemplateString,tmpData,null,tmpContextArray);if(this.LogControlFlow&&this.LogNoisiness>1){this.log.info("PICT-ControlFlow parseTemplate ".concat(tmpParseUUID," Template Return Value:\n").concat(tmpResult));}return tmpResult;}}/**
	 * Parse a template by hash.
	 *
	 * @param {String} pTemplateHash - The hash of the template to parse
	 * @param {Object} pData - The data to use in the template
	 * @param {Function} [fCallback] - The callback to call when the template is parsed
	 * @param {Array<any>} [pContextArray] - The context array to use in the template
	 *
	 * @return {String?} The parsed template string, or undefined if a callback was provided
	 */},{key:"parseTemplateByHash",value:function parseTemplateByHash(pTemplateHash,pData,fCallback,pContextArray){var tmpTemplateString=this.TemplateProvider.getTemplate(pTemplateHash);// TODO: Unsure if returning empty is always the right behavior -- if it isn't we will use config to set the behavior
if(!tmpTemplateString){tmpTemplateString='';}return this.parseTemplate(tmpTemplateString,pData,fCallback,pContextArray);}/**
	 * Parse a template set.
	 *
	 * @param {String} pTemplateString - The template string to parse
	 * @param {Array<any>|Object} pDataSet - The data set to use in the template
	 * @param {Function} [fCallback] - The callback to call when the template set is parsed
	 * @param {Array<any>} [pContextArray] - The context array to use in the template
	 *
	 * @return {String?} The parsed template string, or undefined if a callback was provided
	 */},{key:"parseTemplateSet",value:function parseTemplateSet(pTemplateString,pDataSet,fCallback,pContextArray){var _this78=this;// TODO: This will need streaming -- for now janky old string append does the trick
var tmpValue='';if(typeof fCallback=='function'){if(Array.isArray(pDataSet)||_typeof(pDataSet)=='object'){this.Utility.eachLimit(pDataSet,1,function(pRecord,fRecordTemplateCallback){return _this78.parseTemplate(pTemplateString,pRecord,function(pError,pTemplateResult){tmpValue+=pTemplateResult;return fRecordTemplateCallback();});},function(pError){return fCallback(pError,tmpValue);});}else{return fCallback(Error('Pict: Template Set: pDataSet is not an array or object.'),'');}}else{if(Array.isArray(pDataSet)||_typeof(pDataSet)=='object'){if(Array.isArray(pDataSet)){for(var i=0;i<pDataSet.length;i++){tmpValue+=this.parseTemplate(pTemplateString,pDataSet[i],null,pContextArray);}}else{var tmpKeys=Object.keys(pDataSet);for(var _i58=0;_i58<tmpKeys.length;_i58++){tmpValue+=this.parseTemplate(pTemplateString,pDataSet[tmpKeys[_i58]],null,pContextArray);}}return tmpValue;}else{return'';}}}/**
	 * Parse a template set by hash.
	 *
	 * @param {String} pTemplateHash - The hash of the template to parse
	 * @param {Array<any>|Object} pDataSet - The data set to use in the template
	 * @param {Function} [fCallback] - The callback to call when the template is parsed
	 * @param {Array<any>} [pContextArray] - The context array to use in the template
	 *
	 * @return {String?} The parsed template string, or undefined if a callback was provided
	 */},{key:"parseTemplateSetByHash",value:function parseTemplateSetByHash(pTemplateHash,pDataSet,fCallback,pContextArray){var tmpTemplateString=this.TemplateProvider.getTemplate(pTemplateHash);// TODO: Unsure if returning empty is always the right behavior -- if it isn't we will use config to set the behavior
if(!tmpTemplateString){tmpTemplateString='';}return this.parseTemplateSet(tmpTemplateString,pDataSet,fCallback,pContextArray);}}]);}(libFable);;module.exports=Pict;module.exports.PictApplicationClass=require('pict-application');module.exports.PictViewClass=require('pict-view');module.exports.PictProviderClass=require('pict-provider');module.exports.PictTemplateClass=require('pict-template');module.exports.EnvironmentLog=require('./environments/Pict-Environment-Log.js');module.exports.EnvironmentObject=require('./environments/Pict-Environment-Object.js');// This is to help understand the type of enivironement we're executing in
module.exports.isBrowser=new Function("try {return (this===window);} catch(pError) {return false;}");module.exports.safeOnDocumentReady=require("./Pict-Browser-SafeOnDocumentReady.js");module.exports.safeLoadPictApplication=require("./Pict-Browser-SafeLoad.js");},{"../package.json":189,"./Pict-Browser-SafeLoad.js":190,"./Pict-Browser-SafeOnDocumentReady.js":191,"./Pict-CSS.js":192,"./Pict-Content-Assignment.js":193,"./Pict-DataProvider.js":194,"./Pict-Meadow-EntityProvider.js":195,"./Pict-Template-Provider.js":196,"./environments/Pict-Environment-Log.js":198,"./environments/Pict-Environment-Object.js":199,"./templates/Pict-Template-Data.js":200,"./templates/Pict-Template-Entity.js":201,"./templates/Pict-Template-Self.js":202,"./templates/Pict-Template-Template.js":203,"./templates/Pict-Template-TemplateFromMap.js":204,"./templates/Pict-Template-TemplateSet.js":205,"./templates/Pict-Template-TemplateSetFromMap.js":206,"./templates/Pict-Template-TemplateValueSet.js":207,"./templates/data-generation/Pict-Template-RandomNumber.js":208,"./templates/data-generation/Pict-Template-RandomNumberString.js":209,"./templates/data/Pict-Template-DataJson.js":210,"./templates/data/Pict-Template-DateOnlyFormat.js":211,"./templates/data/Pict-Template-DateOnlyYMD.js":212,"./templates/data/Pict-Template-DateTimeFormat.js":213,"./templates/data/Pict-Template-DateTimeYMD.js":214,"./templates/data/Pict-Template-Digits.js":215,"./templates/data/Pict-Template-Dollars.js":216,"./templates/data/Pict-Template-HtmlCommentEnd.js":217,"./templates/data/Pict-Template-HtmlCommentStart.js":218,"./templates/data/Pict-Template-Join.js":219,"./templates/data/Pict-Template-JoinUnique.js":220,"./templates/data/Pict-Template-PascalCaseIdentifier.js":221,"./templates/data/Pict-Template-PluckJoinUnique.js":222,"./templates/debugging/Pict-Template-Breakpoint.js":223,"./templates/debugging/Pict-Template-DataValueTree.js":224,"./templates/debugging/Pict-Template-LogStatement.js":225,"./templates/debugging/Pict-Template-LogValue.js":226,"./templates/debugging/Pict-Template-LogValueTree.js":227,"./templates/logic/Pict-Template-NotEmpty.js":228,"./templates/logic/Pict-Template-TemplateIf.js":230,"./templates/logic/Pict-Template-TemplateIfAbsolute.js":231,"fable":68,"pict-application":137,"pict-provider":139,"pict-template":141,"pict-view":143}],198:[function(require,module,exports){/**
* Pict browser shim loader
* @author <steven@velozo.com>
*
* This was born after writing about 10 views and copying basically the same
* mock environment read/write functions into the test harnesses.  It allows
* mocks or other types of communications back-and-forth to be configured
* as an environment for views and applications.
*
* To use this:
*
* 1. Construct a pict object in your favorite fashion:
*        let _Pict = new libPict({...Environment})
* 2. Require this; it's exported as a static subobject of the pict library,
*    so you can do:
*        const libPictEnvironmentLog = require('pict').EnvironmentLog;
* 3. Create an object that is your custom read data.  Any key that is requested
*    but missing will return empty.
*        const tmpContentMap = { '#SomeElement': 'SomeValue' };
* 4. Pass your pict through this to get the custom functions mapped into the ContentAssignment service:
*        let tmpMockEnvironment = new libPictEnvironmentLog(_Pict, tmpContentMap);
* 5. Now you can use your pict as normal, and it will log all of the read/write events out and keep a log of when they occurred.
*/var PictEnvironmentLog=/*#__PURE__*/function(){/**
	 * @typedef {import('../Pict')} Pict
	 *//**
	 * @param {Pict} pPict - The pict object to attach the custom read/write functions to.
	 * @param {Object<String, any>} pContentMap - The content map to use for custom reads.
	 */function PictEnvironmentLog(pPict,pContentMap){_classCallCheck2(this,PictEnvironmentLog);this.contentMap=_typeof(pContentMap)=='object'?pContentMap:{};this.pict=pPict;// If this is set to false, we won't keep an array-based log of every read, assignment, append or get.
this.truncateContentLength=256;this.storeEventLog=true;// Where to store each event type
this.eventLog={};this.eventLog.GetElement=[];this.eventLog.Read=[];this.eventLog.Prepend=[];this.eventLog.Append=[];this.eventLog.Assign=[];this.pict.ContentAssignment.customGetElementFunction=this.customGetElementFunction.bind(this);this.pict.ContentAssignment.customReadFunction=this.customReadFunction.bind(this);this.pict.ContentAssignment.customAppendFunction=this.customAppendFunction.bind(this);this.pict.ContentAssignment.customPrependFunction=this.customPrependFunction.bind(this);this.pict.ContentAssignment.customAssignFunction=this.customAssignFunction.bind(this);this.pict.ContentAssignment.customReadAttributeFunction=this.customReadAttributeFunction.bind(this);this.pict.ContentAssignment.customSetAttributeFunction=this.customSetAttributeFunction.bind(this);}/**
	 * Create an event log entry.
	 *
	 * @param {string} pAddress - The address of the event.
	 * @param {string} [pContent] - The content of the event.
	 */return _createClass2(PictEnvironmentLog,[{key:"createEventLogEntry",value:function createEventLogEntry(pAddress,pContent){var tmpContent=typeof pContent=='undefined'?'':pContent;return{TimeStamp:this.pict.log.getTimeStamp(),Hash:pAddress,Content:tmpContent};}/**
	 * Custom GetElement function.
	 *
	 * @param {string} pAddress - The address of the element.
	 */},{key:"customGetElementFunction",value:function customGetElementFunction(pAddress){if(this.storeEventLog)this.eventLog.GetElement.push(this.createEventLogEntry(pAddress));this.pict.log.info("Mocking an GET of Address -> [".concat(pAddress,"]"));return'';}/**
	 * Custom Read function.
	 *
	 * @param {string} pAddress - The address of the element.
	 */},{key:"customReadFunction",value:function customReadFunction(pAddress){if(this.storeEventLog)this.eventLog.Read.push(this.createEventLogEntry(pAddress));this.pict.log.info("Mocking an READ from Address -> [".concat(pAddress,"]"));if(pAddress in this.contentMap){// The data is in the content map!
return this.contentMap[pAddress];}this.pict.log.warn("Mock read from Address ".concat(pAddress," did not find a value in the content map."));return'';}/**
	 * Custom Append function.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @param {string} pContent - The content to append.
	 */},{key:"customAppendFunction",value:function customAppendFunction(pAddress,pContent){if(this.storeEventLog)this.eventLog.Append.push(this.createEventLogEntry(pAddress,pContent));if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an APPEND to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an APPEND to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}/**
	 * Custom Prepend function.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @param {string} pContent - The content to prepend.
	 */},{key:"customPrependFunction",value:function customPrependFunction(pAddress,pContent){if(this.storeEventLog)this.eventLog.Prepend.push(this.createEventLogEntry(pAddress,pContent));if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an PREPEND to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an PREPEND to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}/**
	 * Custom Assign function.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @param {string} pContent - The content to assign.
	 */},{key:"customAssignFunction",value:function customAssignFunction(pAddress,pContent){if(this.storeEventLog)this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pContent));if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an ASSIGN to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an ASSIGN to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}/**
	 * Custom Read Attribute function.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @param {string} pAttribute - The attribute to read.
	 */},{key:"customReadAttributeFunction",value:function customReadAttributeFunction(pAddress,pAttribute){this.pict.log.info("Mocking an READ ATTRIBUTE from Address -> [".concat(pAddress,"]"),{Attribute:pAttribute});return'';}/**
	 * Custom Set Attribute function.
	 *
	 * @param {string} pAddress - The address of the element.
	 * @param {string} pAttribute - The attribute to set.
	 */},{key:"customSetAttributeFunction",value:function customSetAttributeFunction(pAddress,pAttribute,pContent){if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an SET ATTRIBUTE to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Attribute:pAttribute,Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an SET ATTRIBUTE to Address -> [".concat(pAddress,"]"),{Attribute:pAttribute,Content:pContent});}return'';}}]);}();module.exports=PictEnvironmentLog;},{}],199:[function(require,module,exports){/**
* Pict browser shim loader with Object statefulness for the environement
* @author <steven@velozo.com>
*
* This was born after writing about 10 views and copying basically the same
* mock environment read/write functions into the test harnesses.  It allows
* mocks or other types of communications back-and-forth to be configured
* as an environment for views and applications.
*
* To use this:
*
* 1. Construct a pict object in your favorite fashion:
*        let _Pict = new libPict({...Environment})
* 2. Require this; it's exported as a static subobject of the pict library,
*    so you can do:
*        const libPictEnvironmentLog = require('pict').EnvironmentLog;
* 3. Create an object that is your custom read data.  Any key that is requested
*    but missing will return empty.
*        const tmpContentMap = { '#SomeElement': 'SomeValue' };
* 4. Pass your pict through this to get the custom functions mapped into the ContentAssignment service:
*        let tmpMockEnvironment = new libPictEnvironmentLog(_Pict, tmpContentMap);
* 5. Now you can use your pict as normal, and it will log all of the read/write events out and keep a log of when they occurred.
*/var PictEnvironmentObject=/*#__PURE__*/function(){/**
	 * @typedef {import('../Pict')} Pict
	 *//**
	 * @param {Pict} pPict - The pict object to attach the custom read/write functions to.q
	 * @param {Object<String, any>} pContentMap - The content map to use for custom reads.
	 */function PictEnvironmentObject(pPict,pContentMap){_classCallCheck2(this,PictEnvironmentObject);this.contentMap=_typeof(pContentMap)=='object'?pContentMap:{};this.contentMap._ATTRIBUTE_MAP={};this.contentMap._CLASS_MAP={};this.pict=pPict;// If this is set to false, we won't keep an array-based log of every read, assignment, append or get.
this.truncateContentLength=256;this.storeEventLog=true;// Where to store each event type
this.eventLog={};this.eventLog.GetElement=[];this.eventLog.Read=[];this.eventLog.Prepend=[];this.eventLog.Append=[];this.eventLog.Assign=[];this.eventLog.ReadAttribute=[];this.eventLog.SetAttribute=[];this.eventLog.RemoveAttribute=[];this.eventLog.ReadClass=[];this.eventLog.SetClass=[];this.eventLog.RemoveClass=[];this.pict.ContentAssignment.customGetElementFunction=this.customGetElementFunction.bind(this);this.pict.ContentAssignment.customReadFunction=this.customReadFunction.bind(this);this.pict.ContentAssignment.customAppendFunction=this.customAppendFunction.bind(this);this.pict.ContentAssignment.customPrependFunction=this.customPrependFunction.bind(this);this.pict.ContentAssignment.customAssignFunction=this.customAssignFunction.bind(this);this.pict.ContentAssignment.customReadAttributeFunction=this.customReadAttributeFunction.bind(this);this.pict.ContentAssignment.customSetAttributeFunction=this.customSetAttributeFunction.bind(this);this.pict.ContentAssignment.customRemoveAttributeFunction=this.customRemoveAttributeFunction.bind(this);this.pict.ContentAssignment.customReadClassFunction=this.customReadClassFunction.bind(this);this.pict.ContentAssignment.customSetClassFunction=this.customSetClassFunction.bind(this);this.pict.ContentAssignment.customRemoveClassFunction=this.customRemoveClassFunction.bind(this);}return _createClass2(PictEnvironmentObject,[{key:"createEventLogEntry",value:function createEventLogEntry(pAddress,pContent){var tmpContent=typeof pContent=='undefined'?'':pContent;return{TimeStamp:this.pict.log.getTimeStamp(),Hash:pAddress,Content:tmpContent};}},{key:"customGetElementFunction",value:function customGetElementFunction(pAddress){if(this.storeEventLog){this.eventLog.GetElement.push(this.createEventLogEntry(pAddress));}this.pict.log.info("Mocking an GET of Address -> [".concat(pAddress,"]"));return'';}},{key:"customReadFunction",value:function customReadFunction(pAddress){if(this.storeEventLog){this.eventLog.Read.push(this.createEventLogEntry(pAddress));}this.pict.log.info("Mocking an READ from Address -> [".concat(pAddress,"]"));if(pAddress in this.contentMap){// The data is in the content map!
return this.contentMap[pAddress];}this.pict.log.warn("Mock read from Address ".concat(pAddress," did not find a value in the content map."));return'';}},{key:"customAppendFunction",value:function customAppendFunction(pAddress,pContent){this.contentMap[pAddress]=typeof this.contentMap[pAddress]=='undefined'?pContent:this.contentMap[pAddress]+pContent;if(this.storeEventLog){this.eventLog.Append.push(this.createEventLogEntry(pAddress,pContent));}if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an APPEND to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an APPEND to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}},{key:"customPrependFunction",value:function customPrependFunction(pAddress,pContent){this.contentMap[pAddress]=typeof this.contentMap[pAddress]=='undefined'?pContent:pContent+this.contentMap[pAddress];if(this.storeEventLog){this.eventLog.Prepend.push(this.createEventLogEntry(pAddress,pContent));}if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an PREPEND to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an PREPEND to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}},{key:"customAssignFunction",value:function customAssignFunction(pAddress,pContent){this.contentMap[pAddress]=pContent;if(this.storeEventLog){this.eventLog.Prepend.push(this.createEventLogEntry(pAddress,pContent));}if(pContent.length>this.truncateContentLength){this.pict.log.info("Mocking an ASSIGN to Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an ASSIGN to Address -> [".concat(pAddress,"]"),{Content:pContent});}return'';}},{key:"initializeAttributeMapLocation",value:function initializeAttributeMapLocation(pAddress,pAttribute){if(!(pAddress in this.contentMap._ATTRIBUTE_MAP)){this.contentMap._ATTRIBUTE_MAP[pAddress]={};}if(!(pAttribute in this.contentMap._ATTRIBUTE_MAP[pAddress])){this.contentMap._ATTRIBUTE_MAP[pAddress][pAttribute]=false;}}},{key:"initializeClassMapLocation",value:function initializeClassMapLocation(pAddress){if(!(pAddress in this.contentMap._CLASS_MAP)){this.contentMap._CLASS_MAP[pAddress]=[];}}},{key:"customReadAttributeFunction",value:function customReadAttributeFunction(pAddress,pAttribute){this.initializeAttributeMapLocation(pAddress,pAttribute);var tmpContent=this.contentMap._ATTRIBUTE_MAP[pAddress][pAttribute];if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pAttribute));}if(tmpContent.length>this.truncateContentLength){this.pict.log.info("Mocking an ATTRIBUTE READ for Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:tmpContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an ATTRIBUTE READ for Address -> [".concat(pAddress,"]::[").concat(pAttribute,"]"),{Content:tmpContent});}return tmpContent;}},{key:"customSetAttributeFunction",value:function customSetAttributeFunction(pAddress,pAttribute,pValue){this.initializeAttributeMapLocation(pAddress,pAttribute);this.contentMap._ATTRIBUTE_MAP[pAddress][pAttribute]=pValue;if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pAttribute));}if(pValue.length>this.truncateContentLength){this.pict.log.info("Mocking an ATTRIBUTE SET for Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:pValue.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an ATTRIBUTE SET for Address -> [".concat(pAddress,"]::[").concat(pAttribute,"]"),{Content:pValue});}return pValue;}},{key:"customRemoveAttributeFunction",value:function customRemoveAttributeFunction(pAddress,pAttribute){this.initializeAttributeMapLocation(pAddress,pAttribute);var tmpContent=this.contentMap._ATTRIBUTE_MAP[pAddress][pAttribute];if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pAttribute));}if(tmpContent.length>this.truncateContentLength){this.pict.log.info("Mocking an ATTRIBUTE REMOVE for Address -> [".concat(pAddress,"] (log truncated to first ").concat(this.truncateContentLength," characters)"),{Content:tmpContent.substring(0,this.truncateContentLength)});}else{this.pict.log.info("Mocking an ATTRIBUTE REMOVE for Address -> [".concat(pAddress,"]::[").concat(pAttribute,"]"),{Content:tmpContent});}delete this.contentMap._ATTRIBUTE_MAP[pAddress][pAttribute];return true;}},{key:"customReadClassFunction",value:function customReadClassFunction(pAddress,pClass){this.initializeClassMapLocation(pAddress);var tmpContent=this.contentMap._CLASS_MAP[pAddress].indexOf(pClass)>-1;if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pClass));}this.pict.log.info("Mocking an CLASS READ for Address -> [".concat(pAddress,"]::[").concat(pClass,"]"),{Content:tmpContent});return tmpContent;}},{key:"customSetClassFunction",value:function customSetClassFunction(pAddress,pClass){this.initializeClassMapLocation(pAddress);var tmpContent=this.contentMap._CLASS_MAP[pAddress];if(this.contentMap._CLASS_MAP[pAddress].indexOf(pClass)==-1){this.contentMap._CLASS_MAP[pAddress].push(pClass);}if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pClass));}this.pict.log.info("Mocking an CLASS SET for Address -> [".concat(pAddress,"]::[").concat(pClass,"]"),{Content:tmpContent.join(' ')});return tmpContent;}},{key:"customRemoveClassFunction",value:function customRemoveClassFunction(pAddress,pClass){this.initializeClassMapLocation(pAddress);var tmpContent=this.contentMap._CLASS_MAP[pAddress];this.contentMap._CLASS_MAP[pAddress].splice(pClass);if(this.storeEventLog){this.eventLog.Assign.push(this.createEventLogEntry(pAddress,pClass));}this.pict.log.info("Mocking an CLASS REMOVE for Address -> [".concat(pAddress,"]::[").concat(pClass,"]"),{Content:tmpContent.join(' ')});return tmpContent;}}]);}();module.exports=PictEnvironmentObject;},{}],200:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderData=/*#__PURE__*/function(_libPictTemplate){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderData(pFable,pOptions,pServiceHash){var _this79;_classCallCheck2(this,PictTemplateProviderData);_this79=_callSuper(this,PictTemplateProviderData,[pFable,pOptions,pServiceHash]);/** @type {any} */_this79.log;_this79.addPattern('{~Data:','~}');_this79.addPattern('{~D:','~}');return _this79;}_inherits(PictTemplateProviderData,_libPictTemplate);return _createClass2(PictTemplateProviderData,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpRecord=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpRecord);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"]"));}var tmpValue='';if(tmpHash!=null){tmpValue=this.resolveStateFromAddress(tmpHash,tmpRecord,pContextArray);}if(tmpValue==null||tmpValue=='undefined'||typeof tmpValue=='undefined'){return'';}return tmpValue;}}]);}(libPictTemplate);module.exports=PictTemplateProviderData;},{"pict-template":141}],201:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderEntity=/*#__PURE__*/function(_libPictTemplate2){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderEntity(pFable,pOptions,pServiceHash){var _this80;_classCallCheck2(this,PictTemplateProviderEntity);_this80=_callSuper(this,PictTemplateProviderEntity,[pFable,pOptions,pServiceHash]);/** @type {any} */_this80.log;_this80.addPattern('{~E:','~}');_this80.addPattern('{~Entity:','~}');return _this80;}/**
	 * Render a template expression, returning a string with the resulting content.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 *
	 * @return {string} The rendered template
	 */_inherits(PictTemplateProviderEntity,_libPictTemplate2);return _createClass2(PictTemplateProviderEntity,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){// TODO: Better messaging
this.log.error("Pict: Entity Render [".concat(pTemplateHash,"]: Render called in a non-asynchronous fashion.  This should not happen."));return'';}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fEntityRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fEntityRender]::[".concat(tmpHash,"]"));}var tmpEntity=false;/** @type {string|number} */var tmpEntityID='';var tmpEntityTemplate=false;// This expression requires 2 parts -- a third is optional, and, if present, is the template to render to.
var tmpAddressParts=tmpHash.split('^');if(tmpAddressParts.length<2){this.log.warn("Pict: Entity Render: Entity or entity ID not resolved for [".concat(tmpHash,"]"));return tmpCallback(Error("Pict: Entity Render: Entity or entity ID not resolved for [".concat(tmpHash,"]")),'');}tmpEntity=tmpAddressParts[0].trim();tmpEntityID=tmpAddressParts[1].trim();tmpEntityTemplate=tmpAddressParts[2].trim();if(!isNaN(Number(tmpEntityID))){try{tmpEntityID=parseInt(String(tmpEntityID));}catch(_unused){this.log.warn("Pict: Entity Render: Could not parse entity ID.");tmpEntityID=0;}}else{// This is an address, so we need to get the value at the address
tmpEntityID=this.resolveStateFromAddress(String(tmpEntityID),tmpData,pContextArray);}// No Entity or EntityID
if(!tmpEntity||!tmpEntityID){this.log.warn("Pict: Entity Render: Entity or entity ID not resolved for [".concat(tmpHash,"]  Entity: ").concat(tmpEntity," ID: ").concat(tmpEntityID));return tmpCallback(Error("Pict: Entity Render: Entity or entity ID not resolved for [".concat(tmpHash,"]  Entity: ").concat(tmpEntity," ID: ").concat(tmpEntityID)),'');}if(this.pict.LogNoisiness>3){this.log.trace("Pict: Entity Render: Entity [".concat(tmpEntity,"] with ID [").concat(tmpEntityID,"] as template [").concat(tmpEntityTemplate,"] from [").concat(tmpHash,"]"));}// Now try to get the entity
this.pict.EntityProvider.getEntity(tmpEntity,tmpEntityID,function(pError,pRecord){if(pError){this.log.error("Pict: Entity Render: Error getting entity [".concat(tmpEntity,"] with ID [").concat(tmpEntityID,"] for [").concat(tmpHash,"]: ").concat(pError),pError);return tmpCallback(pError,'');}// Now render the template
if(tmpEntityTemplate){return this.pict.parseTemplateByHash(tmpEntityTemplate,pRecord,tmpCallback,pContextArray);}else{return tmpCallback(null,'');}}.bind(this));}}]);}(libPictTemplate);module.exports=PictTemplateProviderEntity;},{"pict-template":141}],202:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderSelf=/*#__PURE__*/function(_libPictTemplate3){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderSelf(pFable,pOptions,pServiceHash){var _this81;_classCallCheck2(this,PictTemplateProviderSelf);_this81=_callSuper(this,PictTemplateProviderSelf,[pFable,pOptions,pServiceHash]);_this81.addPattern('{~Pict','~}');_this81.addPattern('{~P','~}');_this81.addPattern('{~p','~}');return _this81;}/**
	 * Render a template expression, returning a string with the resulting content.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 *
	 * @return {string} The rendered template
	 */_inherits(PictTemplateProviderSelf,_libPictTemplate3);return _createClass2(PictTemplateProviderSelf,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){return this.pict.browserAddress;}}]);}(libPictTemplate);module.exports=PictTemplateProviderSelf;},{"pict-template":141}],203:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplate=/*#__PURE__*/function(_libPictTemplate4){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplate(pFable,pOptions,pServiceHash){var _this82;_classCallCheck2(this,PictTemplateProviderTemplate);_this82=_callSuper(this,PictTemplateProviderTemplate,[pFable,pOptions,pServiceHash]);/** @type {any} */_this82.log;_this82.addPattern('{~Template:','~}');_this82.addPattern('{~T:','~}');return _this82;}_inherits(PictTemplateProviderTemplate,_libPictTemplate4);return _createClass2(PictTemplateProviderTemplate,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;// This is just a simple 2 part hash (the entity and the ID)
var tmpHashTemplateSeparator=tmpHash.indexOf(':');tmpTemplateHash=tmpHash.substring(0,tmpHashTemplateSeparator);if(tmpHashTemplateSeparator>-1){tmpAddressOfData=tmpHash.substring(tmpHashTemplateSeparator+1);}else{tmpTemplateHash=tmpHash;}// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]");}if(!tmpAddressOfData){// No address was provided, just render the template with what this template has.
return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),null,pContextArray);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateRenderAsync]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateRenderAsync]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;// This is just a simple 2 part hash (the entity and the ID)
var tmpHashTemplateSeparator=tmpHash.indexOf(':');tmpTemplateHash=tmpHash.substring(0,tmpHashTemplateSeparator);if(tmpHashTemplateSeparator>-1){tmpAddressOfData=tmpHash.substring(tmpHashTemplateSeparator+1);}else{tmpTemplateHash=tmpHash;}// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render Async: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render Async: TemplateHash not resolved for [".concat(tmpHash,"]");}if(!tmpAddressOfData){// No address was provided, just render the template with what this template has.
// The async portion of this is a mind bender because of how entry can happen dynamically from templates
return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplate;},{"pict-template":141}],204:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplateFromMap=/*#__PURE__*/function(_libPictTemplate5){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateFromMap(pFable,pOptions,pServiceHash){var _this83;_classCallCheck2(this,PictTemplateProviderTemplateFromMap);_this83=_callSuper(this,PictTemplateProviderTemplateFromMap,[pFable,pOptions,pServiceHash]);/** @type {any} */_this83.log;_this83.addPattern('{~TFM:','~}');_this83.addPattern('{~TemplateFromMap:','~}');return _this83;}_inherits(PictTemplateProviderTemplateFromMap,_libPictTemplate5);return _createClass2(PictTemplateProviderTemplateFromMap,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRender]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfMap;var tmpAddressOfKey;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<3){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return'';}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfMap=tmpTemplateHashPart[1];tmpAddressOfKey=tmpTemplateHashPart[2];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMap Render: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return'';}// Now resolve the data
var tmpMap=this.resolveStateFromAddress(tmpAddressOfMap,tmpData,pContextArray);var tmpKey=this.resolveStateFromAddress(tmpAddressOfKey,tmpData,pContextArray);if(!tmpMap){this.log.warn("Pict: TemplateFromMap Render: Map not resolved for [".concat(tmpHash,"]"));return'';}tmpData=tmpMap[tmpKey];if(!tmpData){// No address was provided, just render the TemplateFromMap with what this TemplateFromMap has.
return this.pict.parseTemplateByHash(tmpTemplateFromMapHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateFromMapHash,tmpData,null,pContextArray);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfMap;var tmpAddressOfKey;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<3){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return fCallback(null,'');}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfMap=tmpTemplateHashPart[1];tmpAddressOfKey=tmpTemplateHashPart[2];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMap Render Async: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}// Now resolve the data
var tmpMap=this.resolveStateFromAddress(tmpAddressOfMap,tmpData,pContextArray);var tmpKey=this.resolveStateFromAddress(tmpAddressOfKey,tmpData,pContextArray);if(!tmpMap){this.log.warn("Pict: TemplateFromMap Render: Map not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}tmpData=tmpMap[tmpKey];if(!tmpData){// No address was provided, just render the TemplateFromMap with what this TemplateFromMap has.
// The async portion of this is a mind bender because of how entry can happen dynamically from TemplateFromMaps
return this.pict.parseTemplateByHash(tmpTemplateFromMapHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateFromMapHash,tmpData,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplateFromMap;},{"pict-template":141}],205:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplateSet=/*#__PURE__*/function(_libPictTemplate6){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateSet(pFable,pOptions,pServiceHash){var _this84;_classCallCheck2(this,PictTemplateProviderTemplateSet);_this84=_callSuper(this,PictTemplateProviderTemplateSet,[pFable,pOptions,pServiceHash]);/** @type {any} */_this84.log;_this84.addPattern('{~TemplateSet:','~}');_this84.addPattern('{~TS:','~}');return _this84;}_inherits(PictTemplateProviderTemplateSet,_libPictTemplate6);return _createClass2(PictTemplateProviderTemplateSet,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateSetRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateSetRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;// This is just a simple 2 part hash (the entity and the ID)
var tmpHashTemplateSeparator=tmpHash.indexOf(':');tmpTemplateHash=tmpHash.substring(0,tmpHashTemplateSeparator);if(tmpHashTemplateSeparator>-1){tmpAddressOfData=tmpHash.substring(tmpHashTemplateSeparator+1);}else{tmpTemplateHash=tmpHash;}// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]");}if(!tmpAddressOfData){// No address was provided, just render the template with what this template has.
return this.pict.parseTemplateSetByHash(tmpTemplateHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),null,pContextArray);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateSetRenderAsync]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateSetRenderAsync]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfData;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<2){this.log.trace("PICT TemplateFromMap [fTemplateRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return fCallback(null,'');}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfData=tmpTemplateHashPart[1];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMap Render Async: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}// Now resolve the data
tmpData=this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray);if(!tmpData){// No address was provided, just render the template with what this template has.
// The async portion of this is a mind bender because of how entry can happen dynamically from templates
return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,tmpData,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplateSet;},{"pict-template":141}],206:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplateSetFromMap=/*#__PURE__*/function(_libPictTemplate7){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateSetFromMap(pFable,pOptions,pServiceHash){var _this85;_classCallCheck2(this,PictTemplateProviderTemplateSetFromMap);_this85=_callSuper(this,PictTemplateProviderTemplateSetFromMap,[pFable,pOptions,pServiceHash]);/** @type {any} */_this85.log;_this85.addPattern('{~TSFM:','~}');_this85.addPattern('{~TemplateSetFromMap:','~}');return _this85;}_inherits(PictTemplateProviderTemplateSetFromMap,_libPictTemplate7);return _createClass2(PictTemplateProviderTemplateSetFromMap,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT TemplateFromMap [fTemplateFromMapSetRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT TemplateFromMap [fTemplateFromMapSetRender]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfMap;var tmpAddressOfKey;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<3){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return'';}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfMap=tmpTemplateHashPart[1];tmpAddressOfKey=tmpTemplateHashPart[2];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMap Render Async: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return'';}// Now resolve the data
var tmpMap=this.resolveStateFromAddress(tmpAddressOfMap,tmpData,pContextArray);var tmpKey=this.resolveStateFromAddress(tmpAddressOfKey,tmpData,pContextArray);if(!tmpMap){this.log.warn("Pict: TemplateFromMap Render: Map not resolved for [".concat(tmpHash,"]"));return'';}tmpData=tmpMap[tmpKey];if(!tmpData){// No address was provided, just render the TemplateFromMap with what this TemplateFromMap has.
return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,tmpData,null,pContextArray);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT TemplateFromMap [fTemplateFromMapSetRenderAsync]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT TemplateFromMap [fTemplateFromMapSetRenderAsync]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfMap;var tmpAddressOfKey;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<3){this.log.trace("PICT TemplateFromMap [fTemplateFromMapRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return fCallback(null,'');}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfMap=tmpTemplateHashPart[1];tmpAddressOfKey=tmpTemplateHashPart[2];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMapSet Render Async: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}// Now resolve the data
var tmpMap=this.resolveStateFromAddress(tmpAddressOfMap,tmpData,pContextArray);var tmpKey=this.resolveStateFromAddress(tmpAddressOfKey,tmpData,pContextArray);if(!tmpMap){this.log.warn("Pict: TemplateFromMapSet Render: Map not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}tmpData=tmpMap[tmpKey];if(!tmpData){// No address was provided, just render the TemplateFromMap with what this TemplateFromMap has.
// The async portion of this is a mind bender because of how entry can happen dynamically from TemplateFromMaps
return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,tmpData,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplateSetFromMap;},{"pict-template":141}],207:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplateValueSet=/*#__PURE__*/function(_libPictTemplate8){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateValueSet(pFable,pOptions,pServiceHash){var _this86;_classCallCheck2(this,PictTemplateProviderTemplateValueSet);_this86=_callSuper(this,PictTemplateProviderTemplateValueSet,[pFable,pOptions,pServiceHash]);/** @type {any} */_this86.log;_this86.addPattern('{~TemplateValueSet:','~}');_this86.addPattern('{~TVS:','~}');return _this86;}_inherits(PictTemplateProviderTemplateValueSet,_libPictTemplate8);return _createClass2(PictTemplateProviderTemplateValueSet,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateValueSetRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateValueSetRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;// This is just a simple 2 part hash (the entity and the ID)
var tmpHashTemplateSeparator=tmpHash.indexOf(':');tmpTemplateHash=tmpHash.substring(0,tmpHashTemplateSeparator);if(tmpHashTemplateSeparator>-1){tmpAddressOfData=tmpHash.substring(tmpHashTemplateSeparator+1);}else{tmpTemplateHash=tmpHash;}// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]");}tmpData=this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray);var tmpDataValueSet=[];if(Array.isArray(tmpData)){for(var i=0;i<tmpData.length;i++){tmpDataValueSet.push({Value:tmpData[i],Key:i});}}else if(_typeof(tmpData)==='object'){var tmpValueKeys=Object.keys(tmpData);for(var _i59=0;_i59<tmpValueKeys.length;_i59++){tmpDataValueSet.push({Value:tmpData[tmpValueKeys[_i59]],Key:tmpValueKeys[_i59]});}}else{tmpDataValueSet.push({Value:tmpData});}tmpData=tmpDataValueSet;if(!tmpData){// No address was provided, just render the template with what this template has.
return this.pict.parseTemplateSetByHash(tmpTemplateHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateHash,tmpData,null,pContextArray);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateValueSetRenderAsync]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateValueSetRenderAsync]::[".concat(tmpHash,"]"));}var tmpTemplateFromMapHash;var tmpAddressOfData;// This is a 3 part hash with the map address and the key address both
var tmpTemplateHashPart=tmpHash.split(':');if(tmpTemplateHashPart.length<2){this.log.trace("PICT TemplateFromMap [fTemplateRenderAsync]::[".concat(tmpHash,"] failed because there were not three stanzas in the expression [").concat(pTemplateHash,"]"));return fCallback(null,'');}tmpTemplateFromMapHash=tmpTemplateHashPart[0];tmpAddressOfData=tmpTemplateHashPart[1];// No TemplateFromMap hash
if(!tmpTemplateFromMapHash){this.log.warn("Pict: TemplateFromMap Render Async: TemplateFromMapHash not resolved for [".concat(tmpHash,"]"));return fCallback(null,'');}// Now resolve the data
tmpData=this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray);var tmpDataValueSet=[];if(Array.isArray(tmpData)){for(var i=0;i<tmpData.length;i++){tmpDataValueSet.push({Value:tmpData[i],Key:i});}}else if(_typeof(tmpData)==='object'){var tmpValueKeys=Object.keys(tmpData);for(var _i60=0;_i60<tmpValueKeys.length;_i60++){tmpDataValueSet.push({Value:tmpData[tmpValueKeys[_i60]],Key:tmpData[tmpValueKeys[_i60]]});}}else{tmpDataValueSet.push({Value:tmpData});}tmpData=tmpDataValueSet;if(!tmpData){// No address was provided, just render the template with what this template has.
// The async portion of this is a mind bender because of how entry can happen dynamically from templates
return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateSetByHash(tmpTemplateFromMapHash,tmpData,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplateValueSet;},{"pict-template":141}],208:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderRandomNumber=/*#__PURE__*/function(_libPictTemplate9){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderRandomNumber(pFable,pOptions,pServiceHash){var _this87;_classCallCheck2(this,PictTemplateProviderRandomNumber);_this87=_callSuper(this,PictTemplateProviderRandomNumber,[pFable,pOptions,pServiceHash]);/** @type {any} */_this87.log;_this87.addPattern('{~RandomNumber:','~}');_this87.addPattern('{~RN:','~}');return _this87;}_inherits(PictTemplateProviderRandomNumber,_libPictTemplate9);return _createClass2(PictTemplateProviderRandomNumber,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fRandomNumber]::[".concat(tmpHash,"]"));}var tmpMinimumNumber=0;var tmpMaxNumber=9999999;if(tmpHash.length>0){var tmpHashParts=tmpHash.split(',');if(tmpHashParts.length>0){try{tmpMinimumNumber=parseInt(tmpHashParts[0]);}catch(_unused2){tmpMinimumNumber=0;}}if(tmpHashParts.length>1){try{tmpMaxNumber=parseInt(tmpHashParts[1]);}catch(_unused3){tmpMaxNumber=9999999;}}}return this.fable.DataGeneration.randomIntegerBetween(tmpMinimumNumber,tmpMaxNumber);}}]);}(libPictTemplate);module.exports=PictTemplateProviderRandomNumber;},{"pict-template":141}],209:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderRandomNumberString=/*#__PURE__*/function(_libPictTemplate10){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderRandomNumberString(pFable,pOptions,pServiceHash){var _this88;_classCallCheck2(this,PictTemplateProviderRandomNumberString);_this88=_callSuper(this,PictTemplateProviderRandomNumberString,[pFable,pOptions,pServiceHash]);/** @type {any} */_this88.log;_this88.addPattern('{~RandomNumberString:','~}');_this88.addPattern('{~RNS:','~}');return _this88;}_inherits(PictTemplateProviderRandomNumberString,_libPictTemplate10);return _createClass2(PictTemplateProviderRandomNumberString,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fRandomNumberString]::[".concat(tmpHash,"]"));}var tmpStringLength=4;var tmpMaxNumber=9999;if(tmpHash.length>0){var tmpHashParts=tmpHash.split(',');if(tmpHashParts.length>0){try{tmpStringLength=parseInt(tmpHashParts[0]);}catch(_unused4){tmpStringLength=4;}}if(tmpHashParts.length>1){try{tmpMaxNumber=parseInt(tmpHashParts[1]);}catch(_unused5){tmpMaxNumber=9999;}}}return this.fable.DataGeneration.randomNumericString(tmpStringLength,tmpMaxNumber);}}]);}(libPictTemplate);module.exports=PictTemplateProviderRandomNumberString;},{"pict-template":141}],210:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDollars=/*#__PURE__*/function(_libPictTemplate11){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDollars(pFable,pOptions,pServiceHash){var _this89;_classCallCheck2(this,PictTemplateProviderDollars);_this89=_callSuper(this,PictTemplateProviderDollars,[pFable,pOptions,pServiceHash]);/** @type {any} */_this89.log;_this89.addPattern('{~DataJson:','~}');_this89.addPattern('{~DJ:','~}');return _this89;}_inherits(PictTemplateProviderDollars,_libPictTemplate11);return _createClass2(PictTemplateProviderDollars,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDataJson]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDataJson]::[".concat(tmpHash,"]"));}var tmpDataToStringify=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);if(!tmpDataToStringify){tmpDataToStringify=pRecord;}return JSON.stringify(tmpDataToStringify);}}]);}(libPictTemplate);module.exports=PictTemplateProviderDollars;},{"pict-template":141}],211:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDateOnlyFormat=/*#__PURE__*/function(_libPictTemplate12){/**
	 * @param {import('fable')} pFable - The Fable Framework instance
	 * @param {any} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDateOnlyFormat(pFable,pOptions,pServiceHash){var _this90;_classCallCheck2(this,PictTemplateProviderDateOnlyFormat);_this90=_callSuper(this,PictTemplateProviderDateOnlyFormat,[pFable,pOptions,pServiceHash]);/** @type {any} */_this90.options;/** @type {any} */_this90.log;_this90.addPattern('{~DateOnlyFormat:','~}');return _this90;}_inherits(PictTemplateProviderDateOnlyFormat,_libPictTemplate12);return _createClass2(PictTemplateProviderDateOnlyFormat,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpDateValueSet=tmpHash.split('^');if(tmpDateValueSet.length<2){this.log.error("PICT Template [fDateOnlyFormat]::[".concat(tmpHash,"] did not have a valid format string and date."));return'';}var tmpDateValue=this.resolveStateFromAddress(tmpDateValueSet[0],tmpData,pContextArray);if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDateOnlyFormat]::[".concat(tmpHash,"] with data:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDateOnlyFormat]::[".concat(tmpHash,"]"));}// TODO: Modularize this
var tmpDayJS=this.fable.Dates.dayJS.utc(tmpDateValue).tz('UTC');return tmpDayJS.format(tmpDateValueSet[1]);}}]);}(libPictTemplate);module.exports=PictTemplateProviderDateOnlyFormat;/*
# DEAR DEAD CODE DIARY:

```javascript

```
*/},{"pict-template":141}],212:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDateOnlyYMD=/*#__PURE__*/function(_libPictTemplate13){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDateOnlyYMD(pFable,pOptions,pServiceHash){var _this91;_classCallCheck2(this,PictTemplateProviderDateOnlyYMD);_this91=_callSuper(this,PictTemplateProviderDateOnlyYMD,[pFable,pOptions,pServiceHash]);/** @type {any} */_this91.options;/** @type {any} */_this91.log;_this91.addPattern('{~DateOnlyYMD:','~}');return _this91;}/**
	 * Render a template expression, returning a string with the resulting content.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 *
	 * @return {string} The rendered template
	 */_inherits(PictTemplateProviderDateOnlyYMD,_libPictTemplate13);return _createClass2(PictTemplateProviderDateOnlyYMD,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpDateValue=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDateTimeYMD]::[".concat(tmpHash,"] with data:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDateTimeYMD]::[".concat(tmpHash,"]"));}// TODO: Modularize this
var tmpDayJS=this.fable.Dates.dayJS.utc(tmpDateValue).tz('UTC');//FIXME: this is kind of wacked out; -62167219200000 is the unix ms timestamp for 0000-01-01 00:00:00 UTC
//       not even sure showing negative is right; showing the era is probably better (BCE vs CE)
var prefix=tmpDayJS.valueOf()<-62167219200000?'-':'';return prefix+tmpDayJS.format('YYYY-MM-DD');}}]);}(libPictTemplate);module.exports=PictTemplateProviderDateOnlyYMD;},{"pict-template":141}],213:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDateTimeFormat=/*#__PURE__*/function(_libPictTemplate14){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDateTimeFormat(pFable,pOptions,pServiceHash){var _this92;_classCallCheck2(this,PictTemplateProviderDateTimeFormat);_this92=_callSuper(this,PictTemplateProviderDateTimeFormat,[pFable,pOptions,pServiceHash]);/** @type {any} */_this92.options;/** @type {any} */_this92.log;_this92.addPattern('{~DateTimeFormat:','~}');_this92.addPattern('{~DateFormat:','~}');// for backwards compatibility
return _this92;}_inherits(PictTemplateProviderDateTimeFormat,_libPictTemplate14);return _createClass2(PictTemplateProviderDateTimeFormat,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpDateValueSet=tmpHash.split('^');if(tmpDateValueSet.length<2){this.log.error("PICT Template [fDateTimeFormat]::[".concat(tmpHash,"] did not have a valid format string and date."));return'';}var tmpDateValue=this.resolveStateFromAddress(tmpDateValueSet[0],tmpData,pContextArray);if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDateTimeFormat]::[".concat(tmpHash,"] with data:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDateTimeFormat]::[".concat(tmpHash,"]"));}// TODO: Modularize this
var tmpDayJS=this.fable.Dates.dayJS.utc(tmpDateValue);try{// Try to cast the day to be a specific timezone if one is set for the app
if(this.options.Timezone){tmpDayJS=tmpDayJS.tz(this.options.Timezone);}else{try{tmpDayJS=tmpDayJS.tz(this.fable.Dates.dayJS.tz.guess());}catch(pError){this.log.error("Error guessing dayJS guess() function; dates may be formatted to GMT by default. (".concat(pError.message||pError,")"));}}}catch(_unused6){//this.log.error(`Error casting date passed timezone using tz .. casting to the browser guess which is [${this.fable.Dates.dayJS.tz.guess()}].`);
// Day.js will try to guess the user's timezone for us
try{tmpDayJS=tmpDayJS.tz(this.fable.Dates.dayJS.tz.guess());}catch(pError){this.log.error("Error guessing dayJS guess() function; dates may be formatted to GMT by default. (".concat(pError.message||pError,")"));}}return tmpDayJS.format(tmpDateValueSet[1]);}}]);}(libPictTemplate);module.exports=PictTemplateProviderDateTimeFormat;/*
# DEAR DEAD CODE DIARY:

```javascript

```
*/},{"pict-template":141}],214:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDateTimeYMD=/*#__PURE__*/function(_libPictTemplate15){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDateTimeYMD(pFable,pOptions,pServiceHash){var _this93;_classCallCheck2(this,PictTemplateProviderDateTimeYMD);_this93=_callSuper(this,PictTemplateProviderDateTimeYMD,[pFable,pOptions,pServiceHash]);/** @type {any} */_this93.options;/** @type {any} */_this93.log;_this93.addPattern('{~DateTimeYMD:','~}');_this93.addPattern('{~DateYMD:','~}');// for backwards compatibility
return _this93;}/**
	 * Render a template expression, returning a string with the resulting content.
	 *
	 * @param {string} pTemplateHash - The hash contents of the template (what's between the template start and stop tags)
	 * @param {any} pRecord - The json object to be used as the Record for the template render
	 * @param {Array<any>} pContextArray - An array of context objects accessible from the template; safe to leave empty
	 *
	 * @return {string} The rendered template
	 */_inherits(PictTemplateProviderDateTimeYMD,_libPictTemplate15);return _createClass2(PictTemplateProviderDateTimeYMD,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpDateValue=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDateTimeYMD]::[".concat(tmpHash,"] with data:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDateTimeYMD]::[".concat(tmpHash,"]"));}// TODO: Modularize this
var tmpDayJS=this.fable.Dates.dayJS.utc(tmpDateValue);try{// Try to cast the day to be a specific timezone if one is set for the app
if(this.options.Timezone){tmpDayJS=tmpDayJS.tz(this.options.Timezone);}else{try{tmpDayJS=tmpDayJS.tz(this.fable.Dates.dayJS.tz.guess());}catch(pError){this.log.error("Error guessing dayJS guess() function; dates may be formatted to GMT by default. (".concat(pError.message||pError,")"));}}}catch(_unused7){//this.log.error(`Error casting timezone using tz .. casting to the browser guess which is [${this.fable.Dates.dayJS.tz.guess()}].`);
// Day.js will try to guess the user's timezone for us
try{tmpDayJS=tmpDayJS.tz(this.fable.Dates.dayJS.tz.guess());}catch(pError){this.log.error("Error guessing dayJS guess() function; dates may be formatted to GMT by default. (".concat(pError.message||pError,")"));}}return tmpDayJS.format('YYYY-MM-DD');}}]);}(libPictTemplate);module.exports=PictTemplateProviderDateTimeYMD;},{"pict-template":141}],215:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDigits=/*#__PURE__*/function(_libPictTemplate16){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDigits(pFable,pOptions,pServiceHash){var _this94;_classCallCheck2(this,PictTemplateProviderDigits);_this94=_callSuper(this,PictTemplateProviderDigits,[pFable,pOptions,pServiceHash]);/** @type {any} */_this94.options;/** @type {any} */_this94.log;_this94.addPattern('{~Digits:','~}');return _this94;}_inherits(PictTemplateProviderDigits,_libPictTemplate16);return _createClass2(PictTemplateProviderDigits,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDigits]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDigits]::[".concat(tmpHash,"]"));}var tmpColumnData=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);return this.fable.DataFormat.formatterAddCommasToNumber(this.fable.DataFormat.formatterRoundNumber(tmpColumnData,2));}}]);}(libPictTemplate);module.exports=PictTemplateProviderDigits;},{"pict-template":141}],216:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDollars=/*#__PURE__*/function(_libPictTemplate17){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDollars(pFable,pOptions,pServiceHash){var _this95;_classCallCheck2(this,PictTemplateProviderDollars);_this95=_callSuper(this,PictTemplateProviderDollars,[pFable,pOptions,pServiceHash]);/** @type {any} */_this95.options;/** @type {any} */_this95.log;_this95.addPattern('{~Dollars:','~}');return _this95;}_inherits(PictTemplateProviderDollars,_libPictTemplate17);return _createClass2(PictTemplateProviderDollars,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDollars]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDollars]::[".concat(tmpHash,"]"));}var tmpColumnData=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);return this.fable.DataFormat.formatterDollars(tmpColumnData);}}]);}(libPictTemplate);module.exports=PictTemplateProviderDollars;},{"pict-template":141}],217:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderData=/*#__PURE__*/function(_libPictTemplate18){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderData(pFable,pOptions,pServiceHash){var _this96;_classCallCheck2(this,PictTemplateProviderData);_this96=_callSuper(this,PictTemplateProviderData,[pFable,pOptions,pServiceHash]);/** @type {any} */_this96.log;_this96.addPattern('{~HtmlCommentEnd:','~}');_this96.addPattern('{~HCE:','~}');return _this96;}_inherits(PictTemplateProviderData,_libPictTemplate18);return _createClass2(PictTemplateProviderData,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpRecord=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpRecord);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"]"));}var tmpValue=false;if(tmpHash!=null){tmpValue=this.resolveStateFromAddress(tmpHash,tmpRecord,pContextArray);}if(!tmpValue){return' -->';}return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderData;},{"pict-template":141}],218:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderData=/*#__PURE__*/function(_libPictTemplate19){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderData(pFable,pOptions,pServiceHash){var _this97;_classCallCheck2(this,PictTemplateProviderData);_this97=_callSuper(this,PictTemplateProviderData,[pFable,pOptions,pServiceHash]);/** @type {any} */_this97.log;_this97.addPattern('{~HtmlCommentStart:','~}');_this97.addPattern('{~HCS:','~}');return _this97;}_inherits(PictTemplateProviderData,_libPictTemplate19);return _createClass2(PictTemplateProviderData,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpRecord=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpRecord);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fDataRender]::[".concat(tmpHash,"]"));}var tmpValue=false;if(tmpHash!=null){tmpValue=this.resolveStateFromAddress(tmpHash,tmpRecord,pContextArray);}if(!tmpValue){return'<!-- ';}return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderData;},{"pict-template":141}],219:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderJoin=/*#__PURE__*/function(_libPictTemplate20){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderJoin(pFable,pOptions,pServiceHash){var _this98;_classCallCheck2(this,PictTemplateProviderJoin);_this98=_callSuper(this,PictTemplateProviderJoin,[pFable,pOptions,pServiceHash]);/** @type {any} */_this98.options;/** @type {any} */_this98.log;_this98.addPattern('{~Join:','~}');_this98.addPattern('{~J:','~}');return _this98;}_inherits(PictTemplateProviderJoin,_libPictTemplate20);return _createClass2(PictTemplateProviderJoin,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash;var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Join [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Join [fDataRender]::[".concat(tmpHash,"]"));}var tmpDataAddresses=tmpHash.split('^');if(tmpDataAddresses.length<2){return'';}// Get the separator string
var tmpSeparator=tmpDataAddresses.shift();var tmpValueList=[];for(var i=0;i<tmpDataAddresses.length;i++){var tmpValueSet=this.resolveStateFromAddress(tmpDataAddresses[i],tmpData,pContextArray);if(tmpValueSet&&Array.isArray(tmpValueSet)){for(var j=0;j<tmpValueSet.length;j++){tmpValueList.push(tmpValueSet[j]);}}else if(tmpValueSet){tmpValueList.push(tmpValueSet);}}return tmpValueList.join(tmpSeparator);}}]);}(libPictTemplate);module.exports=PictTemplateProviderJoin;},{"pict-template":141}],220:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderJoinUnique=/*#__PURE__*/function(_libPictTemplate21){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderJoinUnique(pFable,pOptions,pServiceHash){var _this99;_classCallCheck2(this,PictTemplateProviderJoinUnique);_this99=_callSuper(this,PictTemplateProviderJoinUnique,[pFable,pOptions,pServiceHash]);/** @type {any} */_this99.options;/** @type {any} */_this99.log;_this99.addPattern('{~JoinUnique:','~}');_this99.addPattern('{~JU:','~}');return _this99;}_inherits(PictTemplateProviderJoinUnique,_libPictTemplate21);return _createClass2(PictTemplateProviderJoinUnique,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash;var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Join Unique [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Join Unique [fDataRender]::[".concat(tmpHash,"]"));}var tmpDataAddresses=tmpHash.split('^');if(tmpDataAddresses.length<2){return'';}// Get the separator string
var tmpSeparator=tmpDataAddresses.shift();var tmpValueList=[];var tmpValueMap={};for(var i=0;i<tmpDataAddresses.length;i++){var tmpValueSet=this.resolveStateFromAddress(tmpDataAddresses[i],tmpData,pContextArray);if(tmpValueSet&&Array.isArray(tmpValueSet)){for(var j=0;j<tmpValueSet.length;j++){if(!(tmpValueSet[j]in tmpValueMap)){tmpValueMap[tmpValueSet[j]]=true;tmpValueList.push(tmpValueSet[j]);}}}else if(tmpValueSet){if(!(tmpValueSet in tmpValueMap)){tmpValueMap[tmpValueSet]=true;tmpValueList.push(tmpValueSet);}}}return tmpValueList.join(tmpSeparator);}}]);}(libPictTemplate);module.exports=PictTemplateProviderJoinUnique;},{"pict-template":141}],221:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderPascalCaseIdentifier=/*#__PURE__*/function(_libPictTemplate22){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderPascalCaseIdentifier(pFable,pOptions,pServiceHash){var _this100;_classCallCheck2(this,PictTemplateProviderPascalCaseIdentifier);_this100=_callSuper(this,PictTemplateProviderPascalCaseIdentifier,[pFable,pOptions,pServiceHash]);/** @type {any} */_this100.options;/** @type {any} */_this100.log;_this100.addPattern('{~PascalCaseIdentifier:','~}');return _this100;}_inherits(PictTemplateProviderPascalCaseIdentifier,_libPictTemplate22);return _createClass2(PictTemplateProviderPascalCaseIdentifier,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fPascalCaseIdentifier]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Template [fPascalCaseIdentifier]::[".concat(tmpHash,"]"));}var tmpValue=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);if(tmpValue==null||tmpValue=='undefined'||typeof tmpValue=='undefined'){return'';}return this.pict.DataFormat.cleanNonAlphaCharacters(this.pict.DataFormat.capitalizeEachWord(tmpValue));}}]);}(libPictTemplate);module.exports=PictTemplateProviderPascalCaseIdentifier;/*
# DEAR DEAD CODE DIARY:

```javascript

```
*/},{"pict-template":141}],222:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderPluckJoinUnique=/*#__PURE__*/function(_libPictTemplate23){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderPluckJoinUnique(pFable,pOptions,pServiceHash){var _this101;_classCallCheck2(this,PictTemplateProviderPluckJoinUnique);_this101=_callSuper(this,PictTemplateProviderPluckJoinUnique,[pFable,pOptions,pServiceHash]);/** @type {any} */_this101.options;/** @type {any} */_this101.log;_this101.addPattern('{~PluckJoinUnique:','~}');_this101.addPattern('{~PJU:','~}');return _this101;}_inherits(PictTemplateProviderPluckJoinUnique,_libPictTemplate23);return _createClass2(PictTemplateProviderPluckJoinUnique,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash;var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Pluck Join Unique [fDataRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>3){this.log.trace("PICT Pluck Join Unique [fDataRender]::[".concat(tmpHash,"]"));}var tmpDataAddresses=tmpHash.split('^');if(tmpDataAddresses.length<3){return'';}// Get the separator string
var tmpSeparator=tmpDataAddresses.shift();var tmpAddress=tmpDataAddresses.shift();var tmpValueList=[];var tmpValueMap={};for(var i=0;i<tmpDataAddresses.length;i++){var tmpValueSet=this.resolveStateFromAddress(tmpDataAddresses[i],tmpData,pContextArray);if(tmpValueSet&&Array.isArray(tmpValueSet)){// This one only works on arrays of objects.
for(var j=0;j<tmpValueSet.length;j++){if(tmpValueSet[j]===null||_typeof(tmpValueSet)!=='object'){continue;}var tmpValue=this.pict.manifest.getValueByHash(tmpValueSet[j],tmpAddress);if(!(tmpValue in tmpValueMap)){tmpValueMap[tmpValue]=true;tmpValueList.push(tmpValue);}}}else if(tmpValueSet){if(!(tmpValueSet in tmpValueMap)){tmpValueMap[tmpValueSet]=true;tmpValueList.push(tmpValueSet);}}}return tmpValueList.join(tmpSeparator);}}]);}(libPictTemplate);module.exports=PictTemplateProviderPluckJoinUnique;},{"pict-template":141}],223:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderBreakpoint=/*#__PURE__*/function(_libPictTemplate24){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderBreakpoint(pFable,pOptions,pServiceHash){var _this102;_classCallCheck2(this,PictTemplateProviderBreakpoint);_this102=_callSuper(this,PictTemplateProviderBreakpoint,[pFable,pOptions,pServiceHash]);/** @type {any} */_this102.log;_this102.addPattern('{~Breakpoint','~}');return _this102;}_inherits(PictTemplateProviderBreakpoint,_libPictTemplate24);return _createClass2(PictTemplateProviderBreakpoint,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpError=new Error("PICT Template Breakpoint: ".concat(tmpHash));this.log.trace("PICT Template Breakpoint: ".concat(tmpHash),tmpError.stack);//throw tmpError;
debugger;// eslint-disable-line no-debugger
return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderBreakpoint;},{"pict-template":141}],224:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderDataValueTree=/*#__PURE__*/function(_libPictTemplate25){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderDataValueTree(pFable,pOptions,pServiceHash){var _this103;_classCallCheck2(this,PictTemplateProviderDataValueTree);_this103=_callSuper(this,PictTemplateProviderDataValueTree,[pFable,pOptions,pServiceHash]);/** @type {any} */_this103.log;_this103.addPattern('{~DataTree:','~}');_this103.addPattern('{~DT:','~}');return _this103;}_inherits(PictTemplateProviderDataValueTree,_libPictTemplate25);return _createClass2(PictTemplateProviderDataValueTree,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpData=_typeof(pRecord)==='object'?pRecord:{};tmpData.TemplateHash=pTemplateHash.trim();tmpData.ValueTreeParameters=tmpData.TemplateHash.split('^');if(tmpData.ValueTreeParameters.length<1){return'';}tmpData.ResolvedValue=this.resolveStateFromAddress(tmpData.ValueTreeParameters[0],tmpData,pContextArray);tmpData.ResolvedValueType=_typeof(tmpData.ResolvedValue);try{tmpData.TreeMaxDepth=tmpData.ValueTreeParameters.length<2?1:parseInt(tmpData.ValueTreeParameters[1]);}catch(_unused8){tmpData.TreeMaxDepth=1;}var tmpPictObjectWrapTemplate=this.pict.TemplateProvider.getTemplate('PICT-Object-Wrap');if(!tmpPictObjectWrapTemplate){// This template is here because it is a default template.  Users can override this template by providing their own as PICT-Object-Wrap
tmpPictObjectWrapTemplate="<div class=\"PICT PICTObjectSet\">{~D:Record.ObjectValueTree~}</div>";}if(tmpData.ResolvedValueType=='object'){tmpData.ObjectValueTree=this.dataValueTreeObjectSet(tmpData.ResolvedValue,tmpData.ResolvedValue,0,tmpData.TreeMaxDepth,pContextArray);}else{this.log.trace("PICT Template Log Value Tree: [".concat(tmpData.TemplateHash,"] resolved data is not an object."),tmpData.ResolvedValue);tmpData.ObjectValueTree=tmpData.ResolveValue;}return this.pict.parseTemplate(tmpPictObjectWrapTemplate,tmpData,null,pContextArray);}},{key:"dataValueTreeObjectSet",value:function dataValueTreeObjectSet(pObject,pRootObject,pCurrentDepth,pMaxDepth,pContextArray){var tmpTemplateResult='';if(_typeof(pObject)!=='object'){return tmpTemplateResult;}var tmpObjectValueKeys=Object.keys(pObject);var tmpPictObjectBranchTemplate=this.pict.TemplateProvider.getTemplate('PICT-Object-Branch');if(!tmpPictObjectBranchTemplate){// This template is here because it is a default template.  Users can override this template by providing their own as PICT-Object-Branch
tmpPictObjectBranchTemplate="\n<div class=\"PICTObjectBranchDepth_{~D:Record.CurrentDepth~}\"><div class=\"PICTObjectBranch\">{~D:Record.BranchKey~}</div><div class=\"PICTObjectBranchValue\">{~D:Record.BranchValue~}</div></div>\n";}for(var i=0;i<tmpObjectValueKeys.length;i++){var tmpBranchType=_typeof(pObject[tmpObjectValueKeys[i]]);var tmpBranchValue='';switch(tmpBranchType){case'object':if(pCurrentDepth+1>pMaxDepth){tmpBranchValue='...';}else{tmpBranchValue=this.dataValueTreeObjectSet(pObject[tmpObjectValueKeys[i]],pRootObject,pCurrentDepth+1,pMaxDepth,pContextArray);}break;default:tmpBranchValue=pObject[tmpObjectValueKeys[i]];break;}var tmpDataValue={AppData:this.pict.AppData,Bundle:this.pict.Bundle,RootContainer:pRootObject,Container:pObject,BranchEntryCount:tmpObjectValueKeys.length,BranchIndex:i,BranchKey:tmpObjectValueKeys[i],BranchValue:tmpBranchValue,BranchDataType:tmpBranchType,CurrentDepth:pCurrentDepth,MaxDepth:pMaxDepth};tmpTemplateResult+=this.pict.parseTemplate(tmpPictObjectBranchTemplate,tmpDataValue,null,pContextArray);}return tmpTemplateResult;}}]);}(libPictTemplate);module.exports=PictTemplateProviderDataValueTree;},{"pict-template":141}],225:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderLogStatement=/*#__PURE__*/function(_libPictTemplate26){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderLogStatement(pFable,pOptions,pServiceHash){var _this104;_classCallCheck2(this,PictTemplateProviderLogStatement);_this104=_callSuper(this,PictTemplateProviderLogStatement,[pFable,pOptions,pServiceHash]);/** @type {any} */_this104.log;_this104.addPattern('{~LogStatement:','~}');_this104.addPattern('{~LS:','~}');return _this104;}_inherits(PictTemplateProviderLogStatement,_libPictTemplate26);return _createClass2(PictTemplateProviderLogStatement,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();this.log.trace("PICT Template Log Message: ".concat(tmpHash));return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderLogStatement;},{"pict-template":141}],226:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderLogValue=/*#__PURE__*/function(_libPictTemplate27){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderLogValue(pFable,pOptions,pServiceHash){var _this105;_classCallCheck2(this,PictTemplateProviderLogValue);_this105=_callSuper(this,PictTemplateProviderLogValue,[pFable,pOptions,pServiceHash]);/** @type {any} */_this105.log;_this105.addPattern('{~LogValue:','~}');_this105.addPattern('{~LV:','~}');return _this105;}_inherits(PictTemplateProviderLogValue,_libPictTemplate27);return _createClass2(PictTemplateProviderLogValue,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpValue=this.resolveStateFromAddress(tmpHash,tmpData,pContextArray);var tmpValueType=_typeof(tmpValue);if(tmpValue==null||tmpValueType=='undefined'){this.log.trace("PICT Template Log Value: [".concat(tmpHash,"] is ").concat(tmpValueType,"."));}else if(tmpValueType=='object'){this.log.trace("PICT Template Log Value: [".concat(tmpHash,"] is an object."),tmpValue);}else{this.log.trace("PICT Template Log Value: [".concat(tmpHash,"] is a ").concat(tmpValueType," = [").concat(tmpValue,"]"));}return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderLogValue;},{"pict-template":141}],227:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderLogValueTree=/*#__PURE__*/function(_libPictTemplate28){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderLogValueTree(pFable,pOptions,pServiceHash){var _this106;_classCallCheck2(this,PictTemplateProviderLogValueTree);_this106=_callSuper(this,PictTemplateProviderLogValueTree,[pFable,pOptions,pServiceHash]);/** @type {any} */_defineProperty2(_this106,"logValueTreeObjectSet",function(pObject,pBaseAddress,pRootObject,pCurrentDepth,pMaxDepth){var tmpTemplateResult='';if(_typeof(pObject)!=='object'){return tmpTemplateResult;}var tmpObjectValueKeys=Object.keys(pObject);for(var i=0;i<tmpObjectValueKeys.length;i++){var tmpBranchType=_typeof(pObject[tmpObjectValueKeys[i]]);var tmpBranchValue='';switch(tmpBranchType){case'object':tmpBranchValue='...';break;default:tmpBranchValue=pObject[tmpObjectValueKeys[i]];break;}_this106.log.trace("[".concat(pBaseAddress,".").concat(tmpObjectValueKeys[i],"] (").concat(tmpBranchType,"):  ").concat(tmpBranchValue));if(pCurrentDepth+1>pMaxDepth){return'';}else if(tmpBranchType=='object'){tmpBranchValue=_this106.logValueTreeObjectSet(pObject[tmpObjectValueKeys[i]],"".concat(pBaseAddress,".").concat(tmpObjectValueKeys[i]),pRootObject,pCurrentDepth+1,pMaxDepth);}}return'';});_this106.log;_this106.addPattern('{~LogValueTree:','~}');_this106.addPattern('{~LVT:','~}');return _this106;}_inherits(PictTemplateProviderLogValueTree,_libPictTemplate28);return _createClass2(PictTemplateProviderLogValueTree,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpData=_typeof(pRecord)==='object'?pRecord:{};tmpData.TemplateHash=pTemplateHash.trim();tmpData.ValueTreeParameters=tmpData.TemplateHash.split('^');if(tmpData.ValueTreeParameters.length<1){return'';}tmpData.ResolvedValue=this.resolveStateFromAddress(tmpData.ValueTreeParameters[0],tmpData,pContextArray);tmpData.ResolvedValueType=_typeof(tmpData.ResolvedValue);try{tmpData.TreeMaxDepth=tmpData.ValueTreeParameters.length<2?1:parseInt(tmpData.ValueTreeParameters[1]);}catch(_unused9){tmpData.TreeMaxDepth=1;}if(tmpData.ResolvedValueType=='object'){this.logValueTreeObjectSet(tmpData.ResolvedValue,tmpData.ValueTreeParameters[0],tmpData.ResolvedValue,0,tmpData.TreeMaxDepth);}else{this.log.trace("PICT Template Log Value Tree: [".concat(tmpData.TemplateHash,"] resolved data is not an object."),tmpData.ResolvedValue);}return'';}}]);}(libPictTemplate);module.exports=PictTemplateProviderLogValueTree;},{"pict-template":141}],228:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderNotEmpty=/*#__PURE__*/function(_libPictTemplate29){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderNotEmpty(pFable,pOptions,pServiceHash){var _this107;_classCallCheck2(this,PictTemplateProviderNotEmpty);_this107=_callSuper(this,PictTemplateProviderNotEmpty,[pFable,pOptions,pServiceHash]);/** @type {any} */_this107.log;_this107.addPattern('{~NotEmpty:','~}');_this107.addPattern('{~NE:','~}');return _this107;}_inherits(PictTemplateProviderNotEmpty,_libPictTemplate29);return _createClass2(PictTemplateProviderNotEmpty,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fNotEmptyRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>2){this.log.trace("PICT Template [fNotEmptyRender]::[".concat(tmpHash,"]"));}var tmpHashParts=tmpHash.split('^');// For now just check truthiness.  Not sure if this is grand.
if(this.resolveStateFromAddress(tmpHashParts[0],tmpData,pContextArray)){return tmpHashParts[1];}else{return'';}}}]);}(libPictTemplate);module.exports=PictTemplateProviderNotEmpty;},{"pict-template":141}],229:[function(require,module,exports){var libPictTemplate=require('pict-template');var PictTemplateProviderTemplateIfBase=/*#__PURE__*/function(_libPictTemplate30){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateIfBase(pFable,pOptions,pServiceHash){_classCallCheck2(this,PictTemplateProviderTemplateIfBase);return _callSuper(this,PictTemplateProviderTemplateIfBase,[pFable,pOptions,pServiceHash]);}_inherits(PictTemplateProviderTemplateIfBase,_libPictTemplate30);return _createClass2(PictTemplateProviderTemplateIfBase,[{key:"compareValues",value:function compareValues(pValueLeft,pOperator,pValueRight){switch(pOperator){case'TRUE':return pValueLeft===true;case'FALSE':return pValueLeft===false;case'LNGT':case'LENGTH_GREATER_THAN':switch(_typeof(pValueLeft)){case'string':return pValueLeft.length>pValueRight;case'object':return pValueLeft.length>pValueRight;default:return false;}case'LNLT':case'LENGTH_LESS_THAN':switch(_typeof(pValueLeft)){case'string':return pValueLeft.length<pValueRight;case'object':return pValueLeft.length<pValueRight;default:return false;}case'!=':return pValueLeft!=pValueRight;case'<':return pValueLeft<pValueRight;case'>':return pValueLeft>pValueRight;case'<=':return pValueLeft<=pValueRight;case'>=':return pValueLeft>=pValueRight;case'===':return pValueLeft===pValueRight;case'==':return pValueLeft==pValueRight;default:return false;}}}]);}(libPictTemplate);module.exports=PictTemplateProviderTemplateIfBase;},{"pict-template":141}],230:[function(require,module,exports){var libPictTemplateIf=require('./Pict-Template-TemplateIf-Base.js');var PictTemplateProviderTemplateIf=/*#__PURE__*/function(_libPictTemplateIf){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateIf(pFable,pOptions,pServiceHash){var _this108;_classCallCheck2(this,PictTemplateProviderTemplateIf);_this108=_callSuper(this,PictTemplateProviderTemplateIf,[pFable,pOptions,pServiceHash]);/** @type {any} */_this108.log;_this108.addPattern('{~TemplateIf:','~}');_this108.addPattern('{~TIf:','~}');return _this108;}_inherits(PictTemplateProviderTemplateIf,_libPictTemplateIf);return _createClass2(PictTemplateProviderTemplateIf,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;var tmpComparisonOperation;var tmpHashParts=tmpHash.split(':');if(tmpHashParts.length<3){this.log.warn("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]"));return"Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]");}tmpTemplateHash=tmpHashParts[0];tmpAddressOfData=tmpHashParts[1];tmpComparisonOperation=tmpHashParts[2];// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]");}// No comparison operation
if(!tmpComparisonOperation){this.log.warn("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]");}// Now try to break the comparison into three parts...
var tmpComparisonParts=tmpComparisonOperation.split('^');if(tmpComparisonParts.length<3){this.log.warn("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]"));return"Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]");}// Now look up the data at the comparison location
try{var tmpComparisonResult=this.compareValues(this.resolveStateFromAddress(tmpComparisonParts[0],tmpData,pContextArray),tmpComparisonParts[1],this.resolveStateFromAddress(tmpComparisonParts[2],tmpData,pContextArray));if(!tmpComparisonResult){return'';}else{if(!tmpAddressOfData){// No address was provided, just render the template with what this template has.
return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),null,pContextArray);}}}catch(pError){this.log.error("Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError),pError);return"Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;var tmpComparisonOperation;var tmpHashParts=tmpHash.split(':');if(tmpHashParts.length<3){this.log.warn("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]")));}tmpTemplateHash=tmpHashParts[0];tmpAddressOfData=tmpHashParts[1];tmpComparisonOperation=tmpHashParts[2];// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]")));}// No comparison operation
if(!tmpComparisonOperation){this.log.warn("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]")));}// Now try to break the comparison into three parts...
var tmpComparisonParts=tmpComparisonOperation.split('^');if(tmpComparisonParts.length<3){this.log.warn("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]")));}// Now look up the data at the comparison location
try{// This is the only thing that's different from the absolute value function above.  Collapse these.
var tmpComparisonResult=this.compareValues(this.resolveStateFromAddress(tmpComparisonParts[0],tmpData,pContextArray),tmpComparisonParts[1],this.resolveStateFromAddress(tmpComparisonParts[2],tmpData,pContextArray));if(!tmpComparisonResult){return tmpCallback(null,'');}else{if(!tmpAddressOfData){return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}catch(pError){this.log.error("Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError),pError);return tmpCallback(pError,'');}}}]);}(libPictTemplateIf);module.exports=PictTemplateProviderTemplateIf;},{"./Pict-Template-TemplateIf-Base.js":229}],231:[function(require,module,exports){var libPictTemplateIf=require('./Pict-Template-TemplateIf-Base.js');var PictTemplateProviderTemplateIfAbsolute=/*#__PURE__*/function(_libPictTemplateIf2){/**
	 * @param {Object} pFable - The Fable Framework instance
	 * @param {Object} pOptions - The options for the service
	 * @param {String} pServiceHash - The hash of the service
	 */function PictTemplateProviderTemplateIfAbsolute(pFable,pOptions,pServiceHash){var _this109;_classCallCheck2(this,PictTemplateProviderTemplateIfAbsolute);_this109=_callSuper(this,PictTemplateProviderTemplateIfAbsolute,[pFable,pOptions,pServiceHash]);/** @type {any} */_this109.log;_this109.addPattern('{~TemplateIfAbsolute:','~}');_this109.addPattern('{~TIfAbs:','~}');return _this109;}_inherits(PictTemplateProviderTemplateIfAbsolute,_libPictTemplateIf2);return _createClass2(PictTemplateProviderTemplateIfAbsolute,[{key:"render",value:function render(pTemplateHash,pRecord,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;var tmpComparisonOperation;var tmpHashParts=tmpHash.split(':');if(tmpHashParts.length<3){this.log.warn("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]"));return"Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]");}tmpTemplateHash=tmpHashParts[0];tmpAddressOfData=tmpHashParts[1];tmpComparisonOperation=tmpHashParts[2];// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]");}// No comparison operation
if(!tmpComparisonOperation){this.log.warn("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]"));return"Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]");}// Now try to break the comparison into three parts...
var tmpComparisonParts=tmpComparisonOperation.split('^');if(tmpComparisonParts.length<3){this.log.warn("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]"));return"Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]");}// Now look up the data at the comparison location
try{var tmpComparisonResult=this.compareValues(this.resolveStateFromAddress(tmpComparisonParts[0],tmpData,pContextArray),tmpComparisonParts[1],tmpComparisonParts[2]);if(!tmpComparisonResult){return'';}else{if(!tmpAddressOfData){// No address was provided, just render the template with what this template has.
return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,null,pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),null,pContextArray);}}}catch(pError){this.log.error("Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError),pError);return"Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError);}}},{key:"renderAsync",value:function renderAsync(pTemplateHash,pRecord,fCallback,pContextArray){var tmpHash=pTemplateHash.trim();var tmpData=_typeof(pRecord)==='object'?pRecord:{};var tmpCallback=typeof fCallback==='function'?fCallback:function(){return'';};if(this.pict.LogNoisiness>4){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"] with tmpData:"),tmpData);}else if(this.pict.LogNoisiness>0){this.log.trace("PICT Template [fTemplateIfAbsoluteValueRender]::[".concat(tmpHash,"]"));}var tmpTemplateHash;var tmpAddressOfData;var tmpComparisonOperation;var tmpHashParts=tmpHash.split(':');if(tmpHashParts.length<3){this.log.warn("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template If Absolute Value Render: TemplateHash not complete for [".concat(tmpHash,"]")));}tmpTemplateHash=tmpHashParts[0];tmpAddressOfData=tmpHashParts[1];tmpComparisonOperation=tmpHashParts[2];// No template hash
if(!tmpTemplateHash){this.log.warn("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: TemplateHash not resolved for [".concat(tmpHash,"]")));}// No comparison operation
if(!tmpComparisonOperation){this.log.warn("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: Comparison Operation not resolved for [".concat(tmpHash,"]")));}// Now try to break the comparison into three parts...
var tmpComparisonParts=tmpComparisonOperation.split('^');if(tmpComparisonParts.length<3){this.log.warn("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]"));return tmpCallback(new Error("Pict: Template Render: Comparison Operation not complete (three parts expected) for [".concat(tmpHash,"]")));}// Now look up the data at the comparison location
try{var tmpComparisonResult=this.compareValues(this.resolveStateFromAddress(tmpComparisonParts[0],tmpData,pContextArray),tmpComparisonParts[1],tmpComparisonParts[2]);if(!tmpComparisonResult){return tmpCallback(null,'');}else{if(!tmpAddressOfData){return this.pict.parseTemplateByHash(tmpTemplateHash,pRecord,function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}else{return this.pict.parseTemplateByHash(tmpTemplateHash,this.resolveStateFromAddress(tmpAddressOfData,tmpData,pContextArray),function(pError,pValue){if(pError){return tmpCallback(pError,'');}return tmpCallback(null,pValue);},pContextArray);}}}catch(pError){this.log.error("Pict: Template Render: Error looking up comparison data for [".concat(tmpHash,"]: ").concat(pError),pError);return tmpCallback(pError,'');}}}]);}(libPictTemplateIf);module.exports=PictTemplateProviderTemplateIfAbsolute;},{"./Pict-Template-TemplateIf-Base.js":229}]},{},[197])(197);});
//# sourceMappingURL=pict.compatible.js.map
